<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Gradle 学习</title>
      <link href="/2025/05/28/2025-05-28-gradle/"/>
      <url>/2025/05/28/2025-05-28-gradle/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/davenkin/p/gradle-learning-1.html">https://www.cnblogs.com/davenkin/p/gradle-learning-1.html</a></p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4.27.2 安卓音频库集成的调试分析</title>
      <link href="/2025/05/28/2025-05-29-ue4_android_audio/"/>
      <url>/2025/05/28/2025-05-29-ue4_android_audio/</url>
      
        <content type="html"><![CDATA[<h2 id="AudioTrack-初始化">AudioTrack 初始化</h2><h3 id="创建音频后端-Device">创建音频后端 Device</h3><p><code>FAudioDeviceManager::LoadDefaultAudioDeviceModule</code> 实现了读取配置文件，创建音频后端 Device</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* frame #0: 0x0000007bd4ae1ba0 libUE4.so`FAudioDeviceManager::LoadDefaultAudioDeviceModule(this=0x0000007c7983e5c0) at AudioDeviceManager.cpp:575:40</span><br><span class="line">  frame #1: 0x0000007bd4ae1a9c libUE4.so`FAudioDeviceManager::InitializeManager(this=0x0000007c7983e5c0) at AudioDeviceManager.cpp:512:6</span><br><span class="line">  frame #2: 0x0000007bd4ae451c libUE4.so`FAudioDeviceManager::Initialize() at AudioDeviceManager.cpp:824:19</span><br><span class="line">  frame #3: 0x0000007bd5889fb0 libUE4.so`UEngine::InitializeAudioDeviceManager(this=0x0000007c780040c0) at UnrealEngine.cpp:3107:2</span><br><span class="line">  frame #4: 0x0000007bd5877f30 libUE4.so`UEngine::Init(this=&lt;unavailable&gt;, InEngineLoop=&lt;unavailable&gt;) at UnrealEngine.cpp:1643:2</span><br><span class="line">  frame #5: 0x0000007bd4e62e34 libUE4.so`UGameEngine::Init(this=0x0000007c780040c0, InEngineLoop=&lt;unavailable&gt;) at GameEngine.cpp:1072:11</span><br><span class="line">  frame #6: 0x0000007bd01c3158 libUE4.so`FEngineLoop::Init(this=&lt;unavailable&gt;) at LaunchEngineLoop.cpp:4017:12</span><br><span class="line">  frame #7: 0x0000007bd01c2458 libUE4.so`AndroidMain(state=&lt;unavailable&gt;) at LaunchAndroid.cpp:501:14</span><br><span class="line">  frame #8: 0x0000007bd01d20fc libUE4.so`android_main(state=0x0000007c9d910d00) at LaunchAndroid.cpp:777:2</span><br><span class="line">  frame #9: 0x0000007bd02015b8 libUE4.so`android_app_entry(param=0x0000007c9d910d00) at android_native_app_glue.c:233:5</span><br><span class="line">  frame #10: 0x0000007d25d1e2a8 libc.so`__pthread_start(void*) + 200</span><br><span class="line">  frame #11: 0x0000007d25d0f624 libc.so`__start_thread + 68</span><br></pre></td></tr></table></figure><p>默认的逻辑是先根据 <code>AudioMixerModuleName</code> 加载，如果加载失败，再根据 <code>AudioDeviceModuleName</code> 加载</p><p>在 &lt;工程根目录&gt;\Saved\Temp\Android\Engine\Config\Android\AndroidEngine.ini 可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Audio]</span><br><span class="line">AudioDeviceModuleName=AndroidAudio</span><br><span class="line">AudioMixerModuleName=AudioMixerAndroid</span><br></pre></td></tr></table></figure><p>于是这里它先读取 AudioMixerAndroid 模块，成功了之后就不再读取 AndroidAudio 模块了</p><h3 id="注册-BufferQueue-回调">注册 BufferQueue 回调</h3><p>BufferQueue 的回调为 <code>FMixerPlatformAndroid::OpenSLBufferQueueCallback</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FMixerPlatformAndroid::OpenSLBufferQueueCallback</span><span class="params">(SLAndroidSimpleBufferQueueItf InQueueInterface, <span class="type">void</span>* pContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FMixerPlatformAndroid* MixerPlatformAndroid = (FMixerPlatformAndroid*)pContext;</span><br><span class="line">    <span class="keyword">if</span> (MixerPlatformAndroid != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MixerPlatformAndroid-&gt;<span class="built_in">ReadNextBuffer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他是在这里注册的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* frame #0: 0x0000007bd5e94d08 libUE4.so`Audio::FMixerPlatformAndroid::OpenAudioStream(this=0x0000007b08ed1c80, Params=&lt;unavailable&gt;) at AudioMixerPlatformAndroid.cpp:291:14</span><br><span class="line">  frame #1: 0x0000007bd3ed27a4 libUE4.so`Audio::FMixerDevice::InitializeHardware(this=0x0000007b086b20e0) at AudioMixerDevice.cpp:403:28</span><br><span class="line">  frame #2: 0x0000007bd446695c libUE4.so`FAudioDevice::Init(this=0x0000007b086b20e0, InDeviceID=&lt;unavailable&gt;, InMaxSources=&lt;unavailable&gt;) at AudioDevice.cpp:513:7</span><br><span class="line">  frame #3: 0x0000007bd44bb224 libUE4.so`FAudioDeviceManager::FAudioDeviceContainer::FAudioDeviceContainer(this=0x0000007be27f32d0, InParams=&lt;unavailable&gt;, InDeviceID=1, DeviceManager=&lt;unavailable&gt;) at AudioDeviceManager.cpp:1672:14</span><br><span class="line">  frame #4: 0x0000007bd44b307c libUE4.so`FAudioDeviceManager::CreateNewDevice(this=0x0000007b0a3cbf40, InParams=0x0000007be27f3418) at AudioDeviceManager.cpp:651:28</span><br><span class="line">  frame #5: 0x0000007bd44b2f40 libUE4.so`FAudioDeviceManager::RequestAudioDevice(this=0x0000007b0a3cbf40, InParams=0x0000007be27f3418) at AudioDeviceManager.cpp:465:10</span><br><span class="line">  frame #6: 0x0000007bd44b5068 libUE4.so`FAudioDeviceManager::CreateMainAudioDevice(this=0x0000007b0a3cbf40) at AudioDeviceManager.cpp:552:27</span><br><span class="line">  frame #7: 0x0000007bd525bfc0 libUE4.so`UEngine::InitializeAudioDeviceManager(this=0x0000007b086b40c0) at UnrealEngine.cpp:3111:23</span><br><span class="line">  frame #8: 0x0000007bd5249f30 libUE4.so`UEngine::Init(this=&lt;unavailable&gt;, InEngineLoop=&lt;unavailable&gt;) at UnrealEngine.cpp:1643:2</span><br><span class="line">  frame #9: 0x0000007bd4834e34 libUE4.so`UGameEngine::Init(this=0x0000007b086b40c0, InEngineLoop=&lt;unavailable&gt;) at GameEngine.cpp:1072:11</span><br><span class="line">  frame #10: 0x0000007bcfb95158 libUE4.so`FEngineLoop::Init(this=&lt;unavailable&gt;) at LaunchEngineLoop.cpp:4017:12</span><br><span class="line">  frame #11: 0x0000007bcfb94458 libUE4.so`AndroidMain(state=&lt;unavailable&gt;) at LaunchAndroid.cpp:501:14</span><br><span class="line">  frame #12: 0x0000007bcfba40fc libUE4.so`android_main(state=0x0000007bdf2881c0) at LaunchAndroid.cpp:777:2</span><br><span class="line">  frame #13: 0x0000007bcfbd35b8 libUE4.so`android_app_entry(param=0x0000007bdf2881c0) at android_native_app_glue.c:233:5</span><br><span class="line">  frame #14: 0x0000007d25d1e2a8 libc.so`__pthread_start(void*) + 200</span><br><span class="line">  frame #15: 0x0000007d25d0f624 libc.so`__start_thread + 68</span><br></pre></td></tr></table></figure><p>搜索 <code>)-&gt;RegisterCallback(</code>，只有七条结果，可以看到，整个 UE 引擎中对 BufferQueue Callback 的注册都是很简单的</p><h3 id="首次播放音频">首次播放音频</h3><p><code>FMixerDevice::InitializeHardware</code> 初始化的时候会播放一次</p><h3 id="首次提交数据">首次提交数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* frame #0: 0x0000007bd64c49bc libUE4.so`Audio::FMixerPlatformAndroid::SubmitBuffer(this=0x0000007c78041280, Buffer=&quot;&quot;) at AudioMixerPlatformAndroid.cpp:410:3</span><br><span class="line">  frame #1: 0x0000007bd44e3a20 libUE4.so`Audio::IAudioMixerPlatformInterface::RunInternal(this=0x0000007c78041280) at AudioMixer.cpp:662:3</span><br><span class="line">  frame #2: 0x0000007bd44e3bdc libUE4.so`Audio::IAudioMixerPlatformInterface::Run(this=0x0000007c78041280) at AudioMixer.cpp:0</span><br><span class="line">  frame #3: 0x0000007bd152b698 libUE4.so`FRunnableThreadPThread::Run(this=0x0000007c780b6c40) at PThreadRunnableThread.cpp:25:24</span><br><span class="line">  frame #4: 0x0000007bd1408078 libUE4.so`FRunnableThreadPThread::_ThreadProc(pThis=0x0000007c780b6c40) at PThreadRunnableThread.h:185:15</span><br><span class="line">  frame #5: 0x0000007d25d1e2a8 libc.so`__pthread_start(void*) + 200</span><br><span class="line">  frame #6: 0x0000007d25d0f624 libc.so`__start_thread + 68</span><br></pre></td></tr></table></figure><p><code>IAudioMixerPlatformInterface::RunInternal</code> 表示，音频线程首次运行的时候提交一次 buffer</p><p><code>IAudioMixerPlatformInterface</code> 派生自 <code>FRunnable</code>，是一个可以运行的线程</p><h2 id="初始化混音数据">初始化混音数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">frame #0: 0x0000007a9f10b1b8 libUE4.so`Audio::FMixerDevice::LoadMasterSoundSubmix(this=0x00000079d3e630d0, InType=Master, InDefaultName=string=u&quot;MasterSubmixDefault&quot;, bInDefaultMuteWhenBackgrounded=&lt;unavailable&gt;, InObjectPath=0x00000079d4fd1630) at AudioMixerDevice.cpp:803</span><br><span class="line">frame #1: 0x0000007a9f10da38 libUE4.so`Audio::FMixerDevice::InitSoundSubmixes(this=0x00000079d3e630d0) at AudioMixerDevice.cpp:957:4</span><br><span class="line">frame #2: 0x0000007a9f103930 libUE4.so`Audio::FMixerDevice::InitializeHardware(this=0x00000079d3e630d0) at AudioMixerDevice.cpp:450:5</span><br><span class="line">frame #3: 0x0000007a9f69795c libUE4.so`FAudioDevice::Init(this=0x00000079d3e630d0, InDeviceID=&lt;unavailable&gt;, InMaxSources=&lt;unavailable&gt;) at AudioDevice.cpp:513:7</span><br><span class="line">frame #4: 0x0000007a9f6ec224 libUE4.so`FAudioDeviceManager::FAudioDeviceContainer::FAudioDeviceContainer(this=0x0000007b009f32d0, InParams=&lt;unavailable&gt;, InDeviceID=1, DeviceManager=&lt;unavailable&gt;) at AudioDeviceManager.cpp:1672:14</span><br><span class="line">frame #5: 0x0000007a9f6e407c libUE4.so`FAudioDeviceManager::CreateNewDevice(this=0x00000079d4fdba00, InParams=0x0000007b009f3418) at AudioDeviceManager.cpp:651:28</span><br><span class="line">frame #6: 0x0000007a9f6e3f40 libUE4.so`FAudioDeviceManager::RequestAudioDevice(this=0x00000079d4fdba00, InParams=0x0000007b009f3418) at AudioDeviceManager.cpp:465:10</span><br><span class="line">frame #7: 0x0000007a9f6e6068 libUE4.so`FAudioDeviceManager::CreateMainAudioDevice(this=0x00000079d4fdba00) at AudioDeviceManager.cpp:552:27</span><br><span class="line">frame #8: 0x0000007aa048cfc0 libUE4.so`UEngine::InitializeAudioDeviceManager(this=0x00000079d3e650b0) at UnrealEngine.cpp:3111:23</span><br><span class="line">frame #9: 0x0000007aa047af30 libUE4.so`UEngine::Init(this=&lt;unavailable&gt;, InEngineLoop=&lt;unavailable&gt;) at UnrealEngine.cpp:1643:2</span><br><span class="line">frame #10: 0x0000007a9fa65e34 libUE4.so`UGameEngine::Init(this=0x00000079d3e650b0, InEngineLoop=&lt;unavailable&gt;) at GameEngine.cpp:1072:11</span><br><span class="line">frame #11: 0x0000007a9adc6158 libUE4.so`FEngineLoop::Init(this=&lt;unavailable&gt;) at LaunchEngineLoop.cpp:4017:12</span><br><span class="line">frame #12: 0x0000007a9adc5458 libUE4.so`AndroidMain(state=&lt;unavailable&gt;) at LaunchAndroid.cpp:501:14</span><br><span class="line">frame #13: 0x0000007a9add50fc libUE4.so`android_main(state=0x0000007ab0383300) at LaunchAndroid.cpp:777:2</span><br><span class="line">frame #14: 0x0000007a9ae045b8 libUE4.so`android_app_entry(param=0x0000007ab0383300) at android_native_app_glue.c:233:5</span><br><span class="line">frame #15: 0x0000007c068ab2a8 libc.so`__pthread_start(void*) + 200</span><br><span class="line">frame #16: 0x0000007c0689c624 libc.so`__start_thread + 68</span><br></pre></td></tr></table></figure><h2 id="BufferQueue-回调在-Tick-中被调用">BufferQueue 回调在 Tick 中被调用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FMixerPlatformAndroid::SubmitBuffer</span><span class="params">(<span class="type">const</span> uint8* Buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">check</span>(DeviceBuffer.<span class="built_in">Num</span>() == NumSamplesPerDeviceCallback);</span><br><span class="line"></span><br><span class="line">    int32 PushResult = CircularOutputBuffer.<span class="built_in">Push</span>((<span class="type">const</span> int16*)Buffer, NumSamplesPerRenderCallback);</span><br><span class="line">    <span class="built_in">check</span>(PushResult == NumSamplesPerRenderCallback)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (CircularOutputBuffer.<span class="built_in">Num</span>() &gt;= NumSamplesPerDeviceCallback)</span><br><span class="line">    &#123;</span><br><span class="line">        int32 PopResult = CircularOutputBuffer.<span class="built_in">Pop</span>(DeviceBuffer.<span class="built_in">GetData</span>(), NumSamplesPerDeviceCallback);</span><br><span class="line">        <span class="built_in">check</span>(PopResult == NumSamplesPerDeviceCallback);</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> BufferSize = NumSamplesPerDeviceCallback * <span class="built_in">sizeof</span>(int16);</span><br><span class="line">        SLresult Result = (*SL_PlayerBufferQueue)-&gt;<span class="built_in">Enqueue</span>(SL_PlayerBufferQueue, Buffer, BufferSize);</span><br><span class="line">        <span class="built_in">OPENSLES_LOG_ON_FAIL</span>(Result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调堆栈如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* frame #0: 0x0000007bcf8c49bc libUE4.so`Audio::FMixerPlatformAndroid::SubmitBuffer(this=0x0000007b03b25b00, Buffer=&quot;&quot;) at AudioMixerPlatformAndroid.cpp:410:3</span><br><span class="line">  frame #1: 0x0000007bcd8e328c libUE4.so`Audio::IAudioMixerPlatformInterface::ReadNextBuffer(this=0x0000007b03b25b00) at AudioMixer.cpp:542:3</span><br><span class="line">  frame #2: 0x0000007d43b68aa0 libwilhelm.so`android::AudioTrackCallback::onMoreData(android::AudioTrack::Buffer const&amp;) - 18446743535702603103</span><br><span class="line">  frame #3: 0x0000007d25997398 libaudioclient.so`android::AudioTrack::processAudioBuffer() + 3304</span><br><span class="line">  frame #4: 0x0000007d25996354 libaudioclient.so`android::AudioTrack::AudioTrackThread::threadLoop() + 340</span><br><span class="line">  frame #5: 0x0000007d49c5f5cc libutils.so`android::Thread::_threadLoop(void*) + 252</span><br><span class="line">  frame #6: 0x0000007d33313490 libandroid_runtime.so`android::AndroidRuntime::javaThreadShell(void*) + 144</span><br><span class="line">  frame #7: 0x0000007d25d1e2a8 libc.so`__pthread_start(void*) + 200</span><br><span class="line">  frame #8: 0x0000007d25d0f624 libc.so`__start_thread + 68</span><br></pre></td></tr></table></figure><p>也就是</p><p><code>FMixerPlatformAndroid::OpenSLBufferQueueCallback</code> -&gt; <code>IAudioMixerPlatformInterface::ReadNextBuffer</code> -&gt; <code>FMixerPlatformAndroid::SubmitBuffer</code></p><p>BufferQueue 回调是在 Tick 中被调用的</p><p>如果当前没有音频播放，那么 Buffer 指向的内存是全 0</p><p>如果当前有音频播放，那么 Buffer 指向的内存是非 0 值，应该就是音频数据</p><h2 id="FAudioDevice-控制播放与暂停">FAudioDevice 控制播放与暂停</h2><p>我是在蓝图里面调用 <code>UAudioComponent::Play</code> 来播放音频的</p><p>它最终调用 <code>UAudioComponent::PlayInternal</code></p><p><code>UAudioComponent::PlayInternal</code> 中核心的部分还是 <code>AudioDevice-&gt;AddNewActiveSound(NewActiveSound);</code></p><p>调用到 <code>FAudioDevice::AddNewActiveSoundInternal</code></p><p>首先，把函数自己转到音频线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsInAudioThread</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DECLARE_CYCLE_STAT</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;FAudioThreadTask.AddNewActiveSound&quot;</span>), STAT_AudioAddNewActiveSound, STATGROUP_AudioThreadCommands);</span><br><span class="line"></span><br><span class="line">    FAudioDevice* AudioDevice = <span class="keyword">this</span>;</span><br><span class="line">    FAudioThread::<span class="built_in">RunCommandOnAudioThread</span>([AudioDevice, NewActiveSound, VirtualLoopToRetrigger]()</span><br><span class="line">    &#123;</span><br><span class="line">        AudioDevice-&gt;<span class="built_in">AddNewActiveSoundInternal</span>(NewActiveSound, VirtualLoopToRetrigger);</span><br><span class="line">    &#125;, <span class="built_in">GET_STATID</span>(STAT_AudioAddNewActiveSound));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后程序化生成、虚拟 loop 等就不说了</p><p>最终添加播放音频</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActiveSounds.<span class="built_in">Add</span>(ActiveSound);</span><br><span class="line"><span class="keyword">if</span> (ActiveSound-&gt;<span class="built_in">GetAudioComponentID</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    AudioComponentIDToActiveSoundMap.<span class="built_in">Add</span>(ActiveSound-&gt;<span class="built_in">GetAudioComponentID</span>(), ActiveSound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>FAudioDevice</code> 中并没有名称很直接的 Play 方法</p><p><code>Exec</code>, <code>Update</code> 这两个方法看上去像一点</p><p>不过看了 <code>Exec</code>，它是处理命令行的</p><p>于是看 <code>FAudioDevice::Update</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* frame #0: 0x0000007bd707402c libUE4.so`FAudioDevice::Update(this=0x0000007b06cb20e0, bGameTicking=&lt;unavailable&gt;) at AudioDevice.cpp:4201:6</span><br><span class="line">  frame #1: 0x0000007bd70aa538 libUE4.so`FAudioDeviceManager::IterateOverAllDevices(TUniqueFunction&lt;void (unsigned int, FAudioDevice*)&gt;) [inlined] UE4Function_Private::TFunctionRefBase&lt;UE4Function_Private::TFunctionStorage&lt;true&gt;, void (unsigned int, FAudioDevice*)&gt;::operator()(this=0x0000007be3ee3c20, Params=1, Params=0x0000007b06cb20e0) const at Function.h:676:11</span><br><span class="line">  frame #2: 0x0000007bd70aa50c libUE4.so`FAudioDeviceManager::IterateOverAllDevices(this=0x0000007b081ebbc0, ForEachDevice=TUniqueFunction&lt;void (unsigned int, FAudioDevice *)&gt; @ 0x0000007be3ee3c20) at AudioDeviceManager.cpp:924</span><br><span class="line">  frame #3: 0x0000007bd70a9a24 libUE4.so`FAudioDeviceManager::UpdateActiveAudioDevices(this=0x0000007b081ebbc0, bGameTicking=&lt;unavailable&gt;) at AudioDeviceManager.cpp:906:2</span><br><span class="line">  frame #4: 0x0000007bd742dc50 libUE4.so`UGameEngine::Tick(this=&lt;unavailable&gt;, DeltaSeconds=&lt;unavailable&gt;, bIdleMode=false) at GameEngine.cpp:1951:27</span><br><span class="line">  frame #5: 0x0000007bd278ffdc libUE4.so`FEngineLoop::Tick(this=&lt;unavailable&gt;) at LaunchEngineLoop.cpp:4915:12</span><br><span class="line">  frame #6: 0x0000007bd2787634 libUE4.so`AndroidMain(state=&lt;unavailable&gt;) at LaunchAndroid.cpp:534:16</span><br><span class="line">  frame #7: 0x0000007bd27970fc libUE4.so`android_main(state=0x0000007c9d910f80) at LaunchAndroid.cpp:777:2</span><br><span class="line">  frame #8: 0x0000007bd27c65b8 libUE4.so`android_app_entry(param=0x0000007c9d910f80) at android_native_app_glue.c:233:5</span><br><span class="line">  frame #9: 0x0000007d25d1e2a8 libc.so`__pthread_start(void*) + 200</span><br><span class="line">  frame #10: 0x0000007d25d0f624 libc.so`__start_thread + 68</span><br></pre></td></tr></table></figure><p>这个调用堆栈也很清晰，可以看到，可能存在有多个 Device</p><p>对于 Update 的内容</p><p>这里面有一个 <code>FAudioDevice::HandlePause</code>，但是他不是用来设置单个 Sound 的暂停的，它是根据游戏全局暂停状态来设置所有的声音的暂停或者恢复的</p><p>然后这里面看到一个 <code>FAudioDevice::ProcessingPendingActiveSoundStops</code> 应该是比较像的</p><p>于是我在蓝图用 AudioComp 暂停音频的时候，断点打到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bDeleteActiveSound)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ActiveSound-&gt;bIsPreviewSound &amp;&amp; bModulationInterfaceEnabled &amp;&amp; ModulationInterface.<span class="built_in">IsValid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ModulationInterface-&gt;<span class="built_in">OnAuditionEnd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ActiveSound-&gt;bAsyncOcclusionPending = <span class="literal">false</span>;</span><br><span class="line">    PendingSoundsToDelete.<span class="built_in">RemoveAtSwap</span>(i, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">delete</span> ActiveSound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实是删除了 Active Sound</p><p>这也说明 FAudioDevice 是 Active Sound 的持有者。毕竟只有持有它的人才有权力销毁他。</p><p>其实回来看 AudioComp，跟播放同理，<code>UAudioComponent::Stop</code> -&gt; <code>FAudioDevice::StopActiveSound</code> -&gt; <code>FAudioDevice::AddSoundToStop</code>。最终 <code>FAudioDevice::AddSoundToStop</code> 中把某个要暂停的 Active Sound 放入 pending 队列 <code>PendingSoundsToStop</code></p><h2 id="双缓冲实现无锁化">双缓冲实现无锁化</h2><p>前面还没有看完 <code>FAudioDevice::Update</code></p><p><code>FAudioDevice::Update</code> 最后一段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Sources.<span class="built_in">Num</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Kill any sources that have finished</span></span><br><span class="line">    <span class="keyword">for</span> (int32 SourceIndex = <span class="number">0</span>; SourceIndex &lt; Sources.<span class="built_in">Num</span>(); SourceIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Source has finished playing (it&#x27;s one shot)</span></span><br><span class="line">        <span class="keyword">if</span> (Sources[ SourceIndex ]-&gt;<span class="built_in">IsFinished</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            Sources[ SourceIndex ]-&gt;<span class="built_in">Stop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Poll audio components for active wave instances (== paths in node tree that end in a USoundWave)</span></span><br><span class="line">    ActiveWaveInstances.<span class="built_in">Reset</span>();</span><br><span class="line">    FirstActiveIndex = <span class="built_in">GetSortedActiveWaveInstances</span>(ActiveWaveInstances, (bGameTicking ? ESortedActiveWaveGetType::FullUpdate : ESortedActiveWaveGetType::PausedUpdate));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop sources that need to be stopped, and touch the ones that need to be kept alive</span></span><br><span class="line">    <span class="built_in">StopSources</span>(ActiveWaveInstances, FirstActiveIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start and/or update any sources that have a high enough priority to play</span></span><br><span class="line">    <span class="built_in">StartSources</span>(ActiveWaveInstances, FirstActiveIndex, bGameTicking);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check which sounds are active from these wave instances and update passive SoundMixes</span></span><br><span class="line">    <span class="built_in">UpdatePassiveSoundMixModifiers</span>(ActiveWaveInstances, FirstActiveIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If not paused, update the playback time of the active sounds after we&#x27;ve processed passive mix modifiers</span></span><br><span class="line">    <span class="comment">// Note that for sounds which play while paused, this will result in longer active sound playback times, which will be ok. If we update the</span></span><br><span class="line">    <span class="comment">// active sound is updated while paused (for a long time), most sounds will be stopped when unpaused.</span></span><br><span class="line">    <span class="built_in">UpdateActiveSoundPlaybackTime</span>(bGameTicking);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该是为了控制高优先级的音频先播放</p><p>然后是一个虚函数 <code>UpdateHardware</code>，这里就可以跳转到 <code>FMixerDevice::UpdateHardware</code></p><p>感觉其中重要的还是这两句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SourceManager-&gt;<span class="built_in">Update</span>();</span><br><span class="line"></span><br><span class="line">AudioMixerPlatform-&gt;<span class="built_in">OnHardwareUpdate</span>();</span><br></pre></td></tr></table></figure><p>于是看 <code>FMixerSourceManager::Update</code> 有段双缓冲实现无锁化的代码，很酷，我还是第一次接触无锁化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the command was triggered, then we want to do a swap of command buffers</span></span><br><span class="line"><span class="keyword">if</span> (CommandsProcessedEvent-&gt;<span class="built_in">Wait</span>(<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    int32 CurrentGameIndex = !RenderThreadCommandBufferIndex.<span class="built_in">GetValue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This flags the audio render thread to be able to pump the next batch of commands</span></span><br><span class="line">    <span class="comment">// And will allow the audio thread to write to a new command slot</span></span><br><span class="line">    <span class="type">const</span> int32 NextIndex = (CurrentGameIndex + <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    FCommands&amp; NextCommandBuffer = CommandBuffers[NextIndex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we&#x27;ve actually emptied the command queue from the render thread before writing to it</span></span><br><span class="line">    <span class="keyword">if</span> (FlushCommandBufferOnTimeoutCvar &amp;&amp; NextCommandBuffer.SourceCommandQueue.<span class="built_in">Num</span>() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogAudioMixer, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Audio render callback stopped. Flushing %d commands.&quot;</span>), NextCommandBuffer.SourceCommandQueue.<span class="built_in">Num</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pop and execute all the commands that came since last update tick</span></span><br><span class="line">        <span class="keyword">for</span> (int32 Id = <span class="number">0</span>; Id &lt; NextCommandBuffer.SourceCommandQueue.<span class="built_in">Num</span>(); ++Id)</span><br><span class="line">        &#123;</span><br><span class="line">            TFunction&lt;<span class="built_in">void</span>()&gt;&amp; CommandFunction = NextCommandBuffer.SourceCommandQueue[Id];</span><br><span class="line">            <span class="built_in">CommandFunction</span>();</span><br><span class="line">            NumCommands.<span class="built_in">Decrement</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NextCommandBuffer.SourceCommandQueue.<span class="built_in">Reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Here we ensure that we block for any pending calls to AudioMixerThreadCommand.</span></span><br><span class="line">    <span class="function">FScopeLock <span class="title">ScopeLock</span><span class="params">(&amp;CommandBufferIndexCriticalSection)</span></span>;</span><br><span class="line">    RenderThreadCommandBufferIndex.<span class="built_in">Set</span>(CurrentGameIndex);</span><br><span class="line"></span><br><span class="line">    CommandsProcessedEvent-&gt;<span class="built_in">Reset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据结构设计">数据结构设计</h3><p>命令缓冲区结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FCommands</span></span><br><span class="line">&#123;</span><br><span class="line">    TArray&lt;TFunction&lt;<span class="built_in">void</span>()&gt;&gt; SourceCommandQueue; <span class="comment">// 存储命令函数的动态数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FCommands CommandBuffers[<span class="number">2</span>]; <span class="comment">// 双缓冲结构</span></span><br></pre></td></tr></table></figure><p>同步控制变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FThreadSafeCounter RenderThreadCommandBufferIndex; <span class="comment">// 原子计数器，表示当前渲染线程使用的缓冲区索引</span></span><br><span class="line">FEvent* CommandsProcessedEvent; <span class="comment">// 事件对象，用于线程同步</span></span><br><span class="line">FCriticalSection CommandBufferIndexCriticalSection; <span class="comment">// 临界区，保护索引交换</span></span><br></pre></td></tr></table></figure><h3 id="双缓冲工作机制">双缓冲工作机制</h3><h4 id="缓冲区索引管理">缓冲区索引管理</h4><p>使用 <code>RenderThreadCommandBufferIndex</code> 原子变量(取值0或1)标识当前渲染线程正在处理的缓冲区</p><p>游戏线程总是向另一个缓冲区(<code>!RenderThreadCommandBufferIndex</code>)写入命令</p><h4 id="工作流程">工作流程</h4><ol><li><p>游戏线程写入阶段：</p><p>游戏线程向非活动缓冲区(与渲染线程当前使用的不同)添加命令</p><p>命令以lambda函数形式存储在SourceCommandQueue数组中</p></li><li><p>缓冲区交换阶段：</p><p>当需要提交命令时(如每帧更新)，游戏线程检查CommandsProcessedEvent</p><p>确认渲染线程已完成前一帧命令处理后，交换缓冲区索引</p></li><li><p>渲染线程处理阶段：</p><p>渲染线程持续检查RenderThreadCommandBufferIndex获取当前命令缓冲区</p><p>按顺序执行缓冲区中的所有命令函数</p><p>处理完成后触发CommandsProcessedEvent</p></li></ol><h4 id="关键同步逻辑">关键同步逻辑</h4><p>缓冲区交换代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取当前渲染线程使用的缓冲区索引</span><br><span class="line">int32 CurrentGameIndex = !RenderThreadCommandBufferIndex.GetValue(); </span><br><span class="line"></span><br><span class="line">// 准备下一个缓冲区索引</span><br><span class="line">const int32 NextIndex = (CurrentGameIndex + 1) &amp; 1; // 0↔1切换</span><br><span class="line"></span><br><span class="line">// 保护索引交换操作</span><br><span class="line">FScopeLock ScopeLock(&amp;CommandBufferIndexCriticalSection);</span><br><span class="line">RenderThreadCommandBufferIndex.Set(CurrentGameIndex);</span><br><span class="line">CommandsProcessedEvent-&gt;Reset();</span><br></pre></td></tr></table></figure><p>超时处理机制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FlushCommandBufferOnTimeoutCvar &amp;&amp; </span><br><span class="line">    NextCommandBuffer.SourceCommandQueue.<span class="built_in">Num</span>() != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 强制处理积压的命令</span></span><br><span class="line">    <span class="keyword">for</span> (int32 Id = <span class="number">0</span>; Id &lt; NextCommandBuffer.SourceCommandQueue.<span class="built_in">Num</span>(); ++Id)</span><br><span class="line">    &#123;</span><br><span class="line">        NextCommandBuffer.SourceCommandQueue[Id](); <span class="comment">// 执行命令</span></span><br><span class="line">        NumCommands.<span class="built_in">Decrement</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    NextCommandBuffer.SourceCommandQueue.<span class="built_in">Reset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FAudioDevice-的-Update-控制-FMixerPlatformAndroid-环形缓冲">FAudioDevice 的 Update 控制 FMixerPlatformAndroid 环形缓冲</h2><p>还是没有找到是谁控制了 <code>FMixerPlatformAndroid</code> 环形缓冲</p><p>于是再回来看 <code>FMixerPlatformAndroid::SubmitBuffer</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FMixerPlatformAndroid::SubmitBuffer</span><span class="params">(<span class="type">const</span> uint8* Buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">check</span>(DeviceBuffer.<span class="built_in">Num</span>() == NumSamplesPerDeviceCallback);</span><br><span class="line"></span><br><span class="line">    int32 PushResult = CircularOutputBuffer.<span class="built_in">Push</span>((<span class="type">const</span> int16*)Buffer, NumSamplesPerRenderCallback);</span><br><span class="line">    <span class="built_in">check</span>(PushResult == NumSamplesPerRenderCallback)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (CircularOutputBuffer.<span class="built_in">Num</span>() &gt;= NumSamplesPerDeviceCallback)</span><br><span class="line">    &#123;</span><br><span class="line">        int32 PopResult = CircularOutputBuffer.<span class="built_in">Pop</span>(DeviceBuffer.<span class="built_in">GetData</span>(), NumSamplesPerDeviceCallback);</span><br><span class="line">        <span class="built_in">check</span>(PopResult == NumSamplesPerDeviceCallback);</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> BufferSize = NumSamplesPerDeviceCallback * <span class="built_in">sizeof</span>(int16);</span><br><span class="line">        SLresult Result = (*SL_PlayerBufferQueue)-&gt;<span class="built_in">Enqueue</span>(SL_PlayerBufferQueue, Buffer, BufferSize);</span><br><span class="line">        <span class="built_in">OPENSLES_LOG_ON_FAIL</span>(Result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我现在才看懂他的意思。先向环形缓冲拷贝数据，拷贝数据的大小为 <code>NumSamplesPerRenderCallback</code>。然后从环形缓冲拷出数据，拷到 <code>DeviceBuffer.GetData()</code>，拷贝数据的大小为 <code>NumSamplesPerDeviceCallback</code>。内部都是 <code>memcpy</code>。</p><p>奇怪的是，它 EnQueue 还是传输的传入的参数 <code>Buffer</code> 而不是 <code>DeviceBuffer.GetData()</code>？</p><p>看看他 Tick 中回调中调用 <code>FMixerPlatformAndroid::SubmitBuffer</code> 的 <code>IAudioMixerPlatformInterface::ReadNextBuffer</code> 中是怎么传入 <code>SubmitBuffer</code> 的参数的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int32 NumSamplesPopped = <span class="number">0</span>;</span><br><span class="line">TArrayView&lt;<span class="type">const</span> uint8&gt; PoppedAudio = OutputBuffer.<span class="built_in">PopBufferData</span>(NumSamplesPopped);</span><br><span class="line"><span class="built_in">SubmitBuffer</span>(PoppedAudio.<span class="built_in">GetData</span>());</span><br></pre></td></tr></table></figure><p>ok，这是一个存储要 EnQueue 实际数据的缓冲</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** List of generated output buffers. */</span></span><br><span class="line">Audio::FOutputBuffer OutputBuffer;</span><br></pre></td></tr></table></figure><p>看看他的使用，应该是在 <code>FOutputBuffer::MixNextBuffer</code></p><p>但是有两个地方都在 while 中调用了它，打个断点看看到底是哪个循环</p><p><code>IAudioMixerPlatformInterface::RunInternal</code> 在 while 循环外调用了一次，这是首次加载时的工作</p><p>然后就一直在 <code>IAudioMixerPlatformInterface::RunInternal</code> 的 while 中被调用</p><p>于是看 <code>FOutputBuffer::MixNextBuffer</code> 做了什么</p><p>他就是调用 Mixer 填充 <code>RenderBuffer</code>，然后把数据从一个 <code>RenderBuffer</code> 拷贝到 <code>CircularBuffer</code> 中</p><p><code>IAudioMixerPlatformInterface</code> 有一个 <code>FOutputBuffer</code> 成员，<code>FOutputBuffer</code> 有一个 <code>CircularBuffer</code> 成员</p><p><code>class FMixerPlatformAndroid : public IAudioMixerPlatformInterface</code> 是派生自 <code>IAudioMixerPlatformInterface</code></p><p>而 <code>FMixerPlatformAndroid</code> 还有一个 <code>CircularOutputBuffer</code> 成员，无敌了，为什么要这么设计</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// This buffer is pushed to and popped from in the SubmitBuffer callback. </span><br><span class="line">// This is required for devices that require frame counts per callback that are not powers of two.</span><br><span class="line">Audio::TCircularAudioBuffer&lt;int16&gt; CircularOutputBuffer;</span><br></pre></td></tr></table></figure><p><code>FMixerDevice</code> 是持有 <code>AudioMixerPlatform</code> 的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** Ptr to the platform interface, which handles streaming audio to the hardware device. */</span><br><span class="line">IAudioMixerPlatformInterface* AudioMixerPlatform;</span><br></pre></td></tr></table></figure><p>这是实现了多态的行为</p><p>最终发现这个 <code>IAudioMixerPlatformInterface</code> 是运行在一个独立的线程，这个线程专门负责生成音频数据</p><p>那么，这个线程是在哪里被发起的呢？谁调用了他的 <code>Run()</code>？暂时没找到。</p><h2 id="Submit-路径">Submit 路径</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* frame #0: 0x0000007aa0ebdb0c libUE4.so`Audio::FMixerPlatformAndroid::SubmitBuffer(this=0x00000079d2e86780, Buffer=&quot;&quot;) at AudioMixerPlatformAndroid.cpp:418:4</span><br><span class="line">  frame #1: 0x0000007a9eedc28c libUE4.so`Audio::IAudioMixerPlatformInterface::ReadNextBuffer(this=0x00000079d2e86780) at AudioMixer.cpp:542:3</span><br><span class="line">  frame #2: 0x0000007bf7ceaaa0 libwilhelm.so`android::AudioTrackCallback::onMoreData(android::AudioTrack::Buffer const&amp;) - 18446743541271057759</span><br><span class="line">  frame #3: 0x0000007c01f1c398 libaudioclient.so`android::AudioTrack::processAudioBuffer() + 3304</span><br><span class="line">  frame #4: 0x0000007c01f1b354 libaudioclient.so`android::AudioTrack::AudioTrackThread::threadLoop() + 340</span><br><span class="line">  frame #5: 0x0000007be492b5cc libutils.so`android::Thread::_threadLoop(void*) + 252</span><br><span class="line">  frame #6: 0x0000007bf99a2490 libandroid_runtime.so`android::AndroidRuntime::javaThreadShell(void*) + 144</span><br><span class="line">  frame #7: 0x0000007c068ab2a8 libc.so`__pthread_start(void*) + 200</span><br></pre></td></tr></table></figure><h2 id="AudioMixerAndroid-总结">AudioMixerAndroid 总结</h2><h3 id="概述">概述</h3><p>音频数据封装成 ActiveSound 类，由 AudioDevice 类维护一个 ActiveSound 的列表。</p><p>有一个专门的音频混合线程，输出混合后的数据</p><p>如果当前设备没有 ActiveSound，那么就填充全 0，有则填充有效数据</p><p>不论有无 ActiveSound，都会向 OutputBuffer 填充数据。</p><p>OpenSL 处理完 BufferQueue 之后，触发混合器注册的回调。该回调从 OutputBuffer 中拷贝数据到环形缓冲，然后把环形缓冲的数据通过 OpenSL 的 EnQueue 方法提交给 OpenSL。这样，OpenSL 又可以开始处理 BufferQueue 了。</p><h3 id="路径">路径</h3><p>注册 BufferQueue 回调到 OpenSL 的路径：</p><p><code>FAudioDevice::Init</code> -&gt; <code>FMixerDevice::InitializeHardware</code> -&gt; <code>FMixerPlatformAndroid::OpenAudioStream</code></p><p>OpenSL 调用的 BufferQueue 回调的工作内容：</p><p><code>FMixerPlatformAndroid::OpenSLBufferQueueCallback</code> -&gt; <code>IAudioMixerPlatformInterface::ReadNextBuffer</code> -&gt; <code>FMixerPlatformAndroid::SubmitBuffer</code></p><p><code>SubmitBuffer</code> 的工作内容是，从环形缓冲拷贝数据，然后把该数据再次 <code>Enqueue</code> 到 OpenSL</p><p>开始音乐播放的路径：</p><p><code>FAudioDevice::AddNewActiveSound</code> -&gt; <code>FAudioDevice::AddNewActiveSoundInternal</code></p><p>它将要播放的 <code>FActiveSound</code> 放入一个待播放的队列</p><p>暂停音乐播放的路径：</p><p><code>FAudioDevice::StopActiveSound</code> -&gt; <code>FAudioDevice::AddSoundToStop</code></p><p>它将要暂停的 <code>FActiveSound</code> 放入一个 pending 队列</p><p>填充音频缓冲的路径：</p><p><code>IAudioMixerPlatformInterface::RunInternal</code> -&gt; <code>FOutputBuffer::MixNextBuffer</code> -&gt; <code>FMixerDevice::OnProcessAudioStream</code></p><p>最终是对所有音频混音得到缓冲数据</p><h2 id="UE-Staff-对-AudioMixerAndroid-的介绍">UE Staff 对 AudioMixerAndroid 的介绍</h2><p><a href="https://forums.unrealengine.com/t/android-new-audiomixerandroid-in-4-17p1-results-in-crackling-audio/392002">https://forums.unrealengine.com/t/android-new-audiomixerandroid-in-4-17p1-results-in-crackling-audio/392002</a></p><p>他这里提到，如果出现噼啪声，是因为 OpenSL 缓冲区数据不够</p><p>为了解决这个问题，Staff 通过把一批缓冲入队来缓解（这算合批吗？）</p><p>这会有效果。但是安卓 CPU 性能欠佳，音频线程可能会被别的工作挤占，所以在负载很高的情况下，合批缓冲可能仍然不够。</p><h2 id="更换音频后端">更换音频后端</h2><p>直接改 ini 是不够的。打包的时候，ini 会被刷新</p><p>看了下 DefaultEngine.ini，这里存了默认地图啥的，也没有相关的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FAudioDeviceManager::LoadDefaultAudioDeviceModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">check</span>(!AudioDeviceModule);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if we&#x27;re going to try to force loading the audio mixer from the command line</span></span><br><span class="line"><span class="type">bool</span> bForceAudioMixer = FParse::<span class="built_in">Param</span>(FCommandLine::<span class="built_in">Get</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;AudioMixer&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> bForceNoAudioMixer = FParse::<span class="built_in">Param</span>(FCommandLine::<span class="built_in">Get</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;NoAudioMixer&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> bForceNonRealtimeRenderer = FParse::<span class="built_in">Param</span>(FCommandLine::<span class="built_in">Get</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;DeterministicAudio&quot;</span>));</span><br></pre></td></tr></table></figure><p>如果在 Configuration 的 Launch Option - Launch Flags 里面添加 <code>-NoAudioMixer</code></p><p>会导致出现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error running &#x27;app&#x27;</span><br><span class="line">Process ID com.YourCompany.&lt;项目名&gt; was not found. Aborting session</span><br></pre></td></tr></table></figure><p>的错误</p><p>问了 AI，说是需要改成 <code>--es CommandLine &quot;-NoAudioMixer&quot;</code> 也没有效果</p><p>于是我在引擎源码直接改为 <code>bForceNoAudioMixer</code> 为 <code>true</code></p><p>构建出来的引擎可以跑，日志中都有一些 Error 了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error        LogAudio                  Submix buffer listener only works with the audio mixer. Please run with audio mixer enabled.</span><br></pre></td></tr></table></figure><p>不过应该不影响</p><p>然后在这里打断点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!AudioDeviceModule &amp;&amp; AudioDeviceModuleName.<span class="built_in">Len</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    AudioDeviceModule = FModuleManager::<span class="built_in">LoadModulePtr</span>&lt;IAudioDeviceModule&gt;(*AudioDeviceModuleName);</span><br></pre></td></tr></table></figure><p>可见他最终加载到 <code>FSLESAudioDeviceModule</code></p><h2 id="创建-FSLESAudioDevice">创建 FSLESAudioDevice</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* frame #0: 0x0000007aa1887230 libUE4.so`FSLESAudioDeviceModule::CreateAudioDevice(this=0x00000079edc682b0) at AndroidAudioDevice.cpp:23:10</span><br><span class="line">  frame #1: 0x0000007a9fc7b010 libUE4.so`FAudioDeviceManager::FAudioDeviceContainer::FAudioDeviceContainer(this=0x0000007b547e42d0, InParams=&lt;unavailable&gt;, InDeviceID=1, DeviceManager=0x00000079d49abd80) at AudioDeviceManager.cpp:1657:46</span><br><span class="line">  frame #2: 0x0000007a9fc7537c libUE4.so`FAudioDeviceManager::CreateNewDevice(this=0x00000079d49abd80, InParams=0x0000007b547e4418) at AudioDeviceManager.cpp:651:28</span><br><span class="line">  frame #3: 0x0000007a9fc75240 libUE4.so`FAudioDeviceManager::RequestAudioDevice(this=0x00000079d49abd80, InParams=0x0000007b547e4418) at AudioDeviceManager.cpp:465:10</span><br><span class="line">  frame #4: 0x0000007a9fc76650 libUE4.so`FAudioDeviceManager::CreateMainAudioDevice(this=0x00000079d49abd80) at AudioDeviceManager.cpp:552:27</span><br><span class="line">  frame #5: 0x0000007aa0c53b3c libUE4.so`UEngine::InitializeAudioDeviceManager(this=0x00000079d30850b0) at UnrealEngine.cpp:3111:23</span><br><span class="line">  frame #6: 0x0000007aa0c41aac libUE4.so`UEngine::Init(this=&lt;unavailable&gt;, InEngineLoop=&lt;unavailable&gt;) at UnrealEngine.cpp:1643:2</span><br><span class="line">  frame #7: 0x0000007aa022c9b0 libUE4.so`UGameEngine::Init(this=0x00000079d30850b0, InEngineLoop=&lt;unavailable&gt;) at GameEngine.cpp:1072:11</span><br><span class="line">  frame #8: 0x0000007a9b58d158 libUE4.so`FEngineLoop::Init(this=&lt;unavailable&gt;) at LaunchEngineLoop.cpp:4017:12</span><br><span class="line">  frame #9: 0x0000007a9b58c458 libUE4.so`AndroidMain(state=&lt;unavailable&gt;) at LaunchAndroid.cpp:501:14</span><br><span class="line">  frame #10: 0x0000007a9b59c0fc libUE4.so`android_main(state=0x0000007ab106db40) at LaunchAndroid.cpp:777:2</span><br><span class="line">  frame #11: 0x0000007a9b5cb5b8 libUE4.so`android_app_entry(param=0x0000007ab106db40) at android_native_app_glue.c:233:5</span><br><span class="line">  frame #12: 0x0000007c068ab2a8 libc.so`__pthread_start(void*) + 200</span><br><span class="line">  frame #13: 0x0000007c0689c624 libc.so`__start_thread + 68</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* frame #0: 0x0000007aa1881cd4 libUE4.so`FSLESAudioDevice::InitializeHardware(this=0x00000079d4162b80) at AndroidAudioDevice.cpp:77:2</span><br><span class="line">  frame #1: 0x0000007a9fe6c000 libUE4.so`FAudioDevice::Init(this=0x00000079d4162b80, InDeviceID=&lt;unavailable&gt;, InMaxSources=&lt;unavailable&gt;) at AudioDevice.cpp:513:7</span><br><span class="line">  frame #2: 0x0000007a9fc7b054 libUE4.so`FAudioDeviceManager::FAudioDeviceContainer::FAudioDeviceContainer(this=0x0000007b547e42d0, InParams=&lt;unavailable&gt;, InDeviceID=1, DeviceManager=&lt;unavailable&gt;) at AudioDeviceManager.cpp:1672:14</span><br><span class="line">  frame #3: 0x0000007a9fc7537c libUE4.so`FAudioDeviceManager::CreateNewDevice(this=0x00000079d49abd80, InParams=0x0000007b547e4418) at AudioDeviceManager.cpp:651:28</span><br><span class="line">  frame #4: 0x0000007a9fc75240 libUE4.so`FAudioDeviceManager::RequestAudioDevice(this=0x00000079d49abd80, InParams=0x0000007b547e4418) at AudioDeviceManager.cpp:465:10</span><br><span class="line">  frame #5: 0x0000007a9fc76650 libUE4.so`FAudioDeviceManager::CreateMainAudioDevice(this=0x00000079d49abd80) at AudioDeviceManager.cpp:552:27</span><br><span class="line">  frame #6: 0x0000007aa0c53b3c libUE4.so`UEngine::InitializeAudioDeviceManager(this=0x00000079d30850b0) at UnrealEngine.cpp:3111:23</span><br><span class="line">  frame #7: 0x0000007aa0c41aac libUE4.so`UEngine::Init(this=&lt;unavailable&gt;, InEngineLoop=&lt;unavailable&gt;) at UnrealEngine.cpp:1643:2</span><br><span class="line">  frame #8: 0x0000007aa022c9b0 libUE4.so`UGameEngine::Init(this=0x00000079d30850b0, InEngineLoop=&lt;unavailable&gt;) at GameEngine.cpp:1072:11</span><br><span class="line">  frame #9: 0x0000007a9b58d158 libUE4.so`FEngineLoop::Init(this=&lt;unavailable&gt;) at LaunchEngineLoop.cpp:4017:12</span><br><span class="line">  frame #10: 0x0000007a9b58c458 libUE4.so`AndroidMain(state=&lt;unavailable&gt;) at LaunchAndroid.cpp:501:14</span><br></pre></td></tr></table></figure><p>在 <code>FSLESAudioDevice::InitializeHardware</code> 这里其实也是有 Mix 的，他创建了 <code>SL_OutputMixObject</code> 对象</p><h2 id="FSLESAudioDevice-播放与暂停">FSLESAudioDevice 播放与暂停</h2><p>但是在 &lt;引擎根目录&gt;\Engine\Source\Runtime\Android\AndroidAudio\Private\AndroidAudioDevice.cpp 看不到其他的 Play 方法之类的</p><p>于是蹲守 <code>UAudioComponent::PlayInternal</code> 的 <code>AudioDevice-&gt;AddNewActiveSound(NewActiveSound);</code></p><p>这个时候进入的 <code>FAudioDevice</code> 其实就是 <code>FSLESAudioDevice</code></p><p>哦……仍然是管理 ActiveSound 的逻辑，很合理，<code>FAudioDevice</code> 是基类</p><p>搜索 <code>)-&gt;RegisterCallback(</code> 看看 <code>FSLESAudioDevice</code> 怎么绑定回调的？</p><p>哦，于是看到了 Engine/Source/Runtime/Android/AndroidAudio/Private/AndroidAudioSource.cpp 底下有播放相关的代码和 RegisterCallback 相关</p><p>他这个就是属于 AndroidAudio 模块的，所以确实是这里</p><p>于是在 <code>FSLESSoundSource::Play</code> 打断点，看到堆栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* frame #0: 0x0000007aa1886614 libUE4.so`FSLESSoundSource::Play(this=0x00000079d39c5500) at AndroidAudioSource.cpp:537:24</span><br><span class="line">  frame #1: 0x0000007a9fe85f94 libUE4.so`FAudioDevice::StartSources(this=0x00000079d4162b80, WaveInstances=size=1, FirstActiveIndex=&lt;unavailable&gt;, bGameTicking=true) at AudioDevice.cpp:4080:17</span><br><span class="line">  frame #2: 0x0000007a9fe871e0 libUE4.so`FAudioDevice::Update(this=0x00000079d4162b80, bGameTicking=&lt;unavailable&gt;) at AudioDevice.cpp:4347:3</span><br><span class="line">  frame #3: 0x0000007a9b5afedc libUE4.so`TGraphTask&lt;TFunctionGraphTaskImpl&lt;void (), (ESubsequentsMode::Type)0&gt;&gt;::ExecuteTask(TArray&lt;FBaseGraphTask*, TSizedDefaultAllocator&lt;32&gt;&gt;&amp;, ENamedThreads::Type) [inlined] UE4Function_Private::TFunctionRefBase&lt;UE4Function_Private::TFunctionStorage&lt;true&gt;, void ()&gt;::operator()(this=&lt;unavailable&gt;) const at Function.h:676:11</span><br><span class="line">  frame #4: 0x0000007a9b5afeb4 libUE4.so`TGraphTask&lt;TFunctionGraphTaskImpl&lt;void (), (ESubsequentsMode::Type)0&gt;&gt;::ExecuteTask(TArray&lt;FBaseGraphTask*, TSizedDefaultAllocator&lt;32&gt;&gt;&amp;, ENamedThreads::Type) [inlined] TFunctionGraphTaskImpl&lt;void (), (ESubsequentsMode::Type)0&gt;::DoTaskImpl(Function=&lt;unavailable&gt;, CurrentThread=AudioThread, MyCompletionGraphEvent=0x00000079eddfc178) at TaskGraphInterfaces.h:1368</span><br><span class="line">  frame #5: 0x0000007a9b5afeb4 libUE4.so`TGraphTask&lt;TFunctionGraphTaskImpl&lt;void (), (ESubsequentsMode::Type)0&gt;&gt;::ExecuteTask(TArray&lt;FBaseGraphTask*, TSizedDefaultAllocator&lt;32&gt;&gt;&amp;, ENamedThreads::Type) [inlined] TFunctionGraphTaskImpl&lt;void (), (ESubsequentsMode::Type)0&gt;::DoTask(this=&lt;unavailable&gt;, CurrentThread=AudioThread, MyCompletionGraphEvent=0x00000079eddfc178) at TaskGraphInterfaces.h:1361</span><br><span class="line">  frame #6: 0x0000007a9b5afeb0 libUE4.so`TGraphTask&lt;TFunctionGraphTaskImpl&lt;void (), (ESubsequentsMode::Type)0&gt;&gt;::ExecuteTask(this=0x00000079eddfc0e0, NewTasks=&lt;unavailable&gt;, CurrentThread=&lt;unavailable&gt;) at TaskGraphInterfaces.h:886</span><br><span class="line">  frame #7: 0x0000007a9c7d8888 libUE4.so`FNamedTaskThread::ProcessTasksNamedThread(int, bool) [inlined] FBaseGraphTask::Execute(this=&lt;unavailable&gt;, NewTasks=&lt;unavailable&gt;, CurrentThread=AudioThread) at TaskGraphInterfaces.h:524:3</span><br><span class="line">  frame #8: 0x0000007a9c7d8858 libUE4.so`FNamedTaskThread::ProcessTasksNamedThread(this=&lt;unavailable&gt;, QueueIndex=&lt;unavailable&gt;, bAllowStall=&lt;unavailable&gt;) at TaskGraph.cpp:710</span><br><span class="line">  frame #9: 0x0000007a9c7d6f84 libUE4.so`FNamedTaskThread::ProcessTasksUntilQuit(this=0x0000007ab52d9ba0, QueueIndex=0) at TaskGraph.cpp:601:4</span><br><span class="line">  frame #10: 0x0000007a9fec8eb8 libUE4.so`FAudioThread::Run() [inlined] AudioThreadMain(TaskGraphBoundSyncEvent=0x00000079d31715e0) at AudioThread.cpp:104:29</span><br><span class="line">  frame #11: 0x0000007a9fec8e78 libUE4.so`FAudioThread::Run(this=&lt;unavailable&gt;) at AudioThread.cpp:210</span><br><span class="line">  frame #12: 0x0000007a9c8f5698 libUE4.so`FRunnableThreadPThread::Run(this=0x00000079d3113fa0) at PThreadRunnableThread.cpp:25:24</span><br><span class="line">  frame #13: 0x0000007a9c7d2078 libUE4.so`FRunnableThreadPThread::_ThreadProc(pThis=0x00000079d3113fa0) at PThreadRunnableThread.h:185:15</span><br><span class="line">  frame #14: 0x0000007c068ab2a8 libc.so`__pthread_start(void*) + 200</span><br><span class="line">  frame #15: 0x0000007c0689c624 libc.so`__start_thread + 68</span><br></pre></td></tr></table></figure><p>似乎涉及到的就是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FSLESSoundSource::EnqueuePCMBuffer</span><span class="params">( <span class="type">bool</span> bLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SLresult result;</span><br><span class="line"><span class="comment">// If looping, register a callback to requeue the buffer</span></span><br><span class="line"><span class="keyword">if</span>( bLoop ) </span><br><span class="line">&#123;</span><br><span class="line">result = (*SL_PlayerBufferQueue)-&gt;<span class="built_in">RegisterCallback</span>(SL_PlayerBufferQueue, OpenSLBufferQueueCallback, (<span class="type">void</span>*)<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (result != SL_RESULT_SUCCESS) &#123; <span class="built_in">UE_LOG</span>(LogAndroidAudio, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;FAILED OPENSL BUFFER QUEUE RegisterCallback 0x%x &quot;</span>), result); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = (*SL_PlayerBufferQueue)-&gt;<span class="built_in">Enqueue</span>(SL_PlayerBufferQueue, SLESBuffer-&gt;AudioData, SLESBuffer-&gt;<span class="built_in">GetSize</span>() );</span><br><span class="line"><span class="keyword">if</span> (result != SL_RESULT_SUCCESS) &#123;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogAndroidAudio, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;FAILED OPENSL BUFFER Enqueue SL_PlayerBufferQueue 0x%x params( %p, %d)&quot;</span>), result, SLESBuffer-&gt;AudioData, <span class="built_in">int32</span>(SLESBuffer-&gt;<span class="built_in">GetSize</span>()));</span><br><span class="line"><span class="keyword">if</span> (bLoop)</span><br><span class="line">&#123;</span><br><span class="line">result = (*SL_PlayerBufferQueue)-&gt;<span class="built_in">RegisterCallback</span>(SL_PlayerBufferQueue, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个 <code>EnqueuePCMRTBuffer</code> 似乎是变体，就跳过了</p><p>于是去看 <code>FSLESSoundSource::OnRequeueBufferCallback</code></p><p>分为流式传输或者非流式传输</p><p>如果是非流式传输，那么直接 EnQueue 同一个缓冲，那就是循环播放本音频</p><p>如果是流式传输，那么从解码任务（可能异步）那边获得一个缓冲区来 EnQueue，然后再去解码</p><p>在我的 case 中，我啥也没配置，直接是 AudioComp 播放，调试居然也进入流式传输</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* frame #0: 0x0000007aa1882d24 libUE4.so`FSLESSoundSource::OnRequeueBufferCallback(this=0x00000079d39c5500, InQueueInterface=&lt;unavailable&gt;) at AndroidAudioSource.cpp:34:7</span><br><span class="line">  frame #1: 0x0000007bf7ceaaa0 libwilhelm.so`android::AudioTrackCallback::onMoreData(android::AudioTrack::Buffer const&amp;) - 18446743541271057759</span><br><span class="line">  frame #2: 0x0000007c01f1c398 libaudioclient.so`android::AudioTrack::processAudioBuffer() + 3304</span><br><span class="line">  frame #3: 0x0000007c01f1b354 libaudioclient.so`android::AudioTrack::AudioTrackThread::threadLoop() + 340</span><br><span class="line">  frame #4: 0x0000007be492b5cc libutils.so`android::Thread::_threadLoop(void*) + 252</span><br><span class="line">  frame #5: 0x0000007bf99a2490 libandroid_runtime.so`android::AndroidRuntime::javaThreadShell(void*) + 144</span><br><span class="line">  frame #6: 0x0000007c068ab2a8 libc.so`__pthread_start(void*) + 200</span><br><span class="line">  frame #7: 0x0000007c0689c624 libc.so`__start_thread + 68</span><br></pre></td></tr></table></figure><p>它读取数据的方法 <code>FSLESSoundSource::ReadMorePCMData</code> 我是调试跳到 <code>FSLESSoundBuffer::ReadCompressedData</code> -&gt; <code>FVorbisAudioInfo::ReadCompressedData</code>。这里面用了 <code>ov_read</code> 来实现数据读取</p><p>Stop 的时候就把 OpenSL BufferQueue 回调注销了</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Unreal Engine 4 </tag>
            
            <tag> OpenSL ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4.27.2 在不想卸载新版 Android Studio 的条件下怎么编译安卓</title>
      <link href="/2025/05/28/2025-05-28-ue4_compile_android_when_not_to_uninstall_newer_version_of_Android_Studio/"/>
      <url>/2025/05/28/2025-05-28-ue4_compile_android_when_not_to_uninstall_newer_version_of_Android_Studio/</url>
      
        <content type="html"><![CDATA[<p>报错类似于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)): java.lang.NoClassDefFoundError: Could not initialize class org.codehaus.groovy.vmplugin.v7.Java7</span><br><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)):  at org.codehaus.groovy.vmplugin.VMPluginFactory.&lt;clinit&gt;(VMPluginFactory.java:43)</span><br><span class="line">// 我这里省略掉堆栈</span><br><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)): Caused by: java.lang.ExceptionInInitializerError: Exception org.codehaus.groovy.GroovyBugError [in thread &quot;Daemon worker&quot;]</span><br><span class="line">// 我这里省略掉堆栈</span><br><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)):  ... 128 more</span><br><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)): FAILURE: Build failed with an exception.</span><br><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)): * What went wrong:</span><br><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)): Could not initialize class org.codehaus.groovy.reflection.ReflectionCache</span><br><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)): &gt; Exception java.lang.NoClassDefFoundError: Could not initialize class org.codehaus.groovy.vmplugin.v7.Java7 [in thread &quot;Daemon worker&quot;]</span><br><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)): * Try:</span><br><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)): Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.</span><br><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)): * Get more help at https://help.gradle.org</span><br><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)): BUILD FAILED in 4s</span><br><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)): ERROR: cmd.exe failed with args /c &quot;&lt;Project Root&gt;\SimpleDemo\Intermediate\Android\armv7\gradle\rungradle.bat&quot; :app:assembleDebug</span><br><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)):        (see &lt;Engine Root&gt;\Engine\Programs\AutomationTool\Saved\Logs\Log.txt for full exception trace)</span><br><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)): AutomationTool exiting with ExitCode=1 (Error_Unknown)</span><br><span class="line">UATHelper: Packaging (Android (Multi:ASTC,DXT,ETC2)): BUILD FAILED</span><br><span class="line">PackagingResults: Error: Unknown Error</span><br></pre></td></tr></table></figure><p>UE 4.27.2 设置 SDK 和 NDK 的流程</p><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/setting-up-android-sdk-and-ndk-for-unreal?application_version=4.27">https://dev.epicgames.com/documentation/zh-cn/unreal-engine/setting-up-android-sdk-and-ndk-for-unreal?application_version=4.27</a></p><p>下载一个免安装的 Android Studio 4.0 May 28, 2020，也就是下载 zip 文件</p><p>从 Android Studio 4.0 可以看到下载的 SDK 和 NDK 等工具都是和已经安装的高版本 Android Studio 是一样的</p><p>于是看配置安卓的这个脚本</p><p>Engine\Extras\Android\SetupAndroid.bat</p><p>里面核心就是下载这些组件嘛</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call &quot;%SDKMANAGER%&quot; &quot;platform-tools&quot; &quot;platforms;android-28&quot; &quot;build-tools;28.0.3&quot; &quot;cmake;3.10.2.4988404&quot; &quot;ndk;21.4.7075529&quot;</span><br></pre></td></tr></table></figure><p>于是尝试，是不是只要有这些组件就好了</p><p>于是给 Project Setting | Platforms | Android SDK | SDKConfig 中设置为</p><p>|:-:|:-:|<br>|Android SDK|<User Name>/AppData/Local/Android/Sdk|<br>|Android NDK|<User Name>/AppData/Local/Android/Sdk/ndk/21.4.7075529|<br>|Home of JAVA|<Android Studio Install Dir>/Android Studio/jre|</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Unreal Engine 4 </tag>
            
            <tag> Render </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4.27.2 纹理 Reimport With New File 的调试分析</title>
      <link href="/2025/05/21/2025-05-21_ue4_texture_reimport_with_new_file/"/>
      <url>/2025/05/21/2025-05-21_ue4_texture_reimport_with_new_file/</url>
      
        <content type="html"><![CDATA[<h2 id="Reimport-With-New-File-入口">Reimport With New File 入口</h2><p><code>FAssetFileContextMenu::ExecuteReimportWithNewFile</code> 收集所有重新导入的资产，传给 <code>FReimportManager::ValidateAllSourceFileAndReimport</code></p><p><code>FReimportManager::ValidateAllSourceFileAndReimport</code> 处理那些丢失的资产对象 missing file，然后把剩下的那些资产对象传给 <code>FReimportManager::ReimportMultiple</code></p><p><code>FReimportManager::ReimportMultiple</code> 遍历资产对象，对每一个资产对象调用 <code>FReimportManager::Reimport</code> 进行重新导入</p><p><code>FReimportManager::Reimport</code> 对这一个资产对象的所有源文件检查是否丢失等，然后寻找合适的 <code>FReimportHandler</code>，最终调用 <code>FReimportHandler::Reimport</code> 来重新导入</p><p>这是一个虚函数，以实现导入行为的多态</p><p>对于重新加载纹理，进入的是 <code>UReimportTextureFactory::Reimport</code></p><p>最终到 <code>UTextureFactory::FactoryCreateBinary</code>，堆栈如下，就不分析了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UTextureFactory::FactoryCreateBinary(UClass *, UObject *, FName, EObjectFlags, UObject *, const wchar_t *, const unsigned char *&amp;, const unsigned char *, FFeedbackContext *) EditorFactories.cpp:4337</span><br><span class="line">UFactory::FactoryCreateBinary(UClass *, UObject *, FName, EObjectFlags, UObject *, const wchar_t *, const unsigned char *&amp;, const unsigned char *, FFeedbackContext *, bool &amp;) Factory.h:354</span><br><span class="line">UFactory::FactoryCreateFile(UClass *, UObject *, FName, EObjectFlags, const FString &amp;, const wchar_t *, FFeedbackContext *, bool &amp;) Factory.cpp:112</span><br><span class="line">UFactory::ImportObject(UClass *, UObject *, FName, EObjectFlags, const FString &amp;, const wchar_t *, bool &amp;) Factory.cpp:201</span><br><span class="line">UReimportTextureFactory::Reimport(UObject *) EditorFactories.cpp:6018</span><br><span class="line">FReimportHandler::Reimport(UObject *, int) EditorReimportHandler.h:238</span><br><span class="line">FReimportManager::Reimport(UObject *, bool, bool, FString, FReimportHandler *, int, bool, bool) Editor.cpp:375</span><br><span class="line">FReimportManager::ReimportMultiple(TArrayView&lt;…&gt;, bool, bool, FString, FReimportHandler *, int, bool, bool) Editor.cpp:622</span><br><span class="line">FReimportManager::ValidateAllSourceFileAndReimport(TArray&lt;…&gt; &amp;, bool, int, bool, bool) Editor.cpp:583</span><br><span class="line">FAssetFileContextMenu::ExecuteReimportWithNewFile(int) AssetFileContextMenu.cpp:1444</span><br></pre></td></tr></table></figure><h2 id="UTextureFactory-FactoryCreateBinary">UTextureFactory::FactoryCreateBinary</h2><p>删掉了类型检查、事件、UDIM、保存图片导入设置、guid、法线贴图、LOD 组、恢复图片导入设置、纹理数组、自动创建纹理等内容，精简为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UObject* <span class="title">UTextureFactory::FactoryCreateBinary</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">UClass*Class,</span></span></span><br><span class="line"><span class="params"><span class="function">UObject*InParent,</span></span></span><br><span class="line"><span class="params"><span class="function">FNameName,</span></span></span><br><span class="line"><span class="params"><span class="function">EObjectFlagsFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">UObject*Context,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> TCHAR*Type,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> uint8*&amp;Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> uint8*BufferEnd,</span></span></span><br><span class="line"><span class="params"><span class="function">FFeedbackContext*Warn</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FName TextureName = Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if the texture already exists, remember the user settings</span></span><br><span class="line">UTexture* ExistingTexture = <span class="built_in">FindObject</span>&lt;UTexture&gt;( InParent, *TextureName.<span class="built_in">ToString</span>() );</span><br><span class="line">UTexture2D* ExistingTexture2D = <span class="built_in">FindObject</span>&lt;UTexture2D&gt;( InParent, *TextureName.<span class="built_in">ToString</span>() );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ExistingTexture2D)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Update with new settings, which should disable streaming...</span></span><br><span class="line">ExistingTexture2D-&gt;<span class="built_in">UpdateResource</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ExistingTexture)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Wait for InitRHI() to complete before the FTextureReferenceReplacer calls ReleaseRHI() to follow the workflow.</span></span><br><span class="line"><span class="comment">// Static texture needs to avoid having pending InitRHI() before enqueuing ReleaseRHI() to safely track access of the PlatformData on the renderthread.</span></span><br><span class="line">ExistingTexture-&gt;<span class="built_in">WaitForPendingInitOrStreaming</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FTextureReferenceReplacer <span class="title">RefReplacer</span><span class="params">(ExistingTexture)</span></span>;</span><br><span class="line"></span><br><span class="line">UTexture* Texture = <span class="literal">nullptr</span>;</span><br><span class="line">Texture = <span class="built_in">ImportTexture</span>(Class, InParent, TextureName, Flags, Type, Buffer, BufferEnd, Warn);</span><br><span class="line">    <span class="keyword">if</span> (Texture)</span><br><span class="line">    &#123;</span><br><span class="line">        Texture-&gt;AssetImportData-&gt;<span class="built_in">Update</span>(CurrentFilename, FileHash.<span class="built_in">IsValid</span>() ? &amp;FileHash : <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!Texture)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ExistingTexture)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// We failed to import over the existing texture. Make sure the resource is ready in the existing texture.</span></span><br><span class="line">ExistingTexture-&gt;<span class="built_in">UpdateResource</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Replace the reference for the new texture with the existing one so that all current users still have valid references.</span></span><br><span class="line">RefReplacer.<span class="built_in">Replace</span>(Texture);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Texture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面是确保被替换的纹理已经初始化了 RHI 资源</p><p>然后就是替换的核心逻辑了 <code>RefReplacer.Replace(Texture);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* Replaces the RHI reference of one texture with another.</span></span><br><span class="line"><span class="comment">* Allows one texture to be replaced with another at runtime and have all existing references to it remain valid.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FTextureReferenceReplacer</span></span><br><span class="line">&#123;</span><br><span class="line">FTextureReferenceRHIRef OriginalRef;</span><br><span class="line"></span><br><span class="line"><span class="built_in">FTextureReferenceReplacer</span>(UTexture* OriginalTexture)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (OriginalTexture)</span><br><span class="line">&#123;</span><br><span class="line">OriginalTexture-&gt;<span class="built_in">ReleaseResource</span>();</span><br><span class="line">OriginalRef = OriginalTexture-&gt;TextureReference.TextureReferenceRHI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">OriginalRef = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Replace</span><span class="params">(UTexture* NewTexture)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (OriginalRef)</span><br><span class="line">&#123;</span><br><span class="line">NewTexture-&gt;TextureReference.TextureReferenceRHI = OriginalRef;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>搜索了整个引擎，只有 Editor 的这个 reimport 的功能使用了 <code>FTextureReferenceReplacer</code> 这个结构体</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Unreal Engine 4 </tag>
            
            <tag> Render </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4.27.2 不透明物体延迟渲染 Draw Call 的调试分析</title>
      <link href="/2025/05/20/2025-05-20_ue4_deferred_render_mesh_opaque_draw_call/"/>
      <url>/2025/05/20/2025-05-20_ue4_deferred_render_mesh_opaque_draw_call/</url>
      
        <content type="html"><![CDATA[<h2 id="ENQUEUE-RENDER-COMMAND">ENQUEUE_RENDER_COMMAND</h2><p>一个最常见的东西</p><p><code>ENQUEUE_RENDER_COMMAND</code> 传进来，就是接受一个 lambda，然后内层</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TSTR, <span class="keyword">typename</span> LAMBDA&gt;</span></span><br><span class="line"><span class="function">FORCEINLINE_DEBUGGABLE <span class="type">void</span> <span class="title">EnqueueUniqueRenderCommand</span><span class="params">(LAMBDA&amp;&amp; Lambda)</span></span></span><br></pre></td></tr></table></figure><p>根据当前是渲染线程还是 game 线程来决定如何执行这个 lambda</p><h2 id="谁调用了-BasePass">谁调用了 BasePass</h2><p>因为截帧的时候看到 BasePass 里面是处理 mesh 的材质</p><p>于是打算从这里开始看</p><h3 id="Rendering-Thread">Rendering Thread</h3><p>在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FDeferredShadingSceneRenderer::RenderBasePassInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">FRDGBuilder&amp; GraphBuilder,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> FRenderTargetBindingSlots&amp; BasePassRenderTargets,</span></span></span><br><span class="line"><span class="params"><span class="function">FExclusiveDepthStencil::Type BasePassDepthStencilAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">FRDGTextureRef ForwardScreenSpaceShadowMask,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span> bParallelBasePass,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span> bRenderLightmapDensity)</span></span></span><br></pre></td></tr></table></figure><p>打断点，是在 <code>FRunnableThreadWin</code> 触发</p><p>于是可以看到，UE 是把 Game 线程和 Render 线程分开的</p><p>从堆栈底层往上，看到 <code>void RenderingThreadMain( FEvent* TaskGraphBoundSyncEvent )</code></p><p>这里面除了性能分析插桩、事件，主要部分是，把 TaskGraph 的当前线程设置为 render 线程，然后 TaskGraph 进入任务处理循环，直到 return</p><p>于是看到 <code>ENQUEUE_RENDER_COMMAND</code> 的 lambda 最终是加到了 task 里面，处理 task 就是处理 render command</p><p>那么 base pass 这个相关的 render command 是 <code>FRendererModule::BeginRenderingViewFamily</code> 里面发起的</p><h3 id="FRendererModule-BeginRenderingViewFamily">FRendererModule::BeginRenderingViewFamily</h3><p>之前的分析已经可以看到，render thread 的工作就是不停地执行 TaskGraph 内的任务</p><p>所以渲染框架的逻辑还是在 game thread</p><p>之前看到一个 base pass 相关的 render command 是在 <code>FRendererModule::BeginRenderingViewFamily</code> 里面发起的</p><p>于是现在在 <code>FRendererModule::BeginRenderingViewFamily</code> 打断点，看看 game thread 这边的逻辑</p><p>从底层上来是 <code>UGameEngine::Tick</code>，这里也就是各个功能的 tick，不出所料，gameobject, slate 等</p><p>然后是 <code>FViewport::Draw</code>，这里更多是准备 canvas</p><p><code>UGameViewportClient::Draw</code> 再对 canvas 做一些操作，然后就到了 <code>FRendererModule::BeginRenderingViewFamily</code> 了</p><p>那其实 <code>FSceneViewFamily* ViewFamily</code> 这个东西已经包含了渲染世界所需要的信息了</p><p>查看这个变量，确实</p><p><img src="/images/ue4_deferred_render_mesh_opaque_draw_call/FRendererModule_BeginRenderingViewFamily.png" alt="alt text"></p><p>既有 World 又有 Primitives、Lights，已经够了</p><p><code>FRendererModule::BeginRenderingViewFamily</code> 内，有一个 <code>World-&gt;SendAllEndOfFrameUpdates();</code> 更新 component 的状态，然后就是发送 render command</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ENQUEUE_RENDER_COMMAND</span>(FDrawSceneCommand)(</span><br><span class="line">    [SceneRenderer, DrawSceneEnqueue](FRHICommandListImmediate&amp; RHICmdList)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="built_in">RenderViewFamily_RenderThread</span>(RHICmdList, SceneRenderer);</span><br><span class="line">        <span class="built_in">FlushPendingDeleteRHIResources_RenderThread</span>();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="从-game-thread-进到-render-thread：RenderViewFamily-RenderThread">从 game thread 进到 render thread：RenderViewFamily_RenderThread</h3><p>于是查看 <code>RenderViewFamily_RenderThread</code></p><p>前面是等待所有未完成的渲染任务、更新延迟资源，处理鼠标点击拾取物体的功能，然后是渲染场景</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SceneRenderer-&gt;<span class="built_in">Render</span>(RHICmdList);</span><br></pre></td></tr></table></figure><p>奇怪的是这后面还写了头发的渲染</p><p>感觉这个调用层级有点不协调，算了，在看框架的时候这不是重点</p><p>然后这个 render 就到了 <code>FDeferredShadingSceneRenderer::Render</code></p><h3 id="FDeferredShadingSceneRenderer-Render">FDeferredShadingSceneRenderer::Render</h3><p>一开始，<code>Scene-&gt;UpdateAllPrimitiveSceneInfos</code> 应该是更新 mesh 相关的渲染信息？</p><p>然后是视口矩形、天空大气、多 GPU、等待 RT 可写、VT 分配、深度缓冲，暂时略过不看</p><p>然后是找到所有的可见物体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the visible primitives.</span></span><br><span class="line">RHICmdList.<span class="built_in">ImmediateFlush</span>(EImmediateFlushType::DispatchToRHIThread);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> bDoInitViewAftersPrepass = <span class="literal">false</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">SCOPED_GPU_STAT</span>(RHICmdList, VisibilityCommands);</span><br><span class="line">    bDoInitViewAftersPrepass = <span class="built_in">InitViews</span>(RHICmdList, BasePassDepthStencilAccess, ILCTaskData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是有一个 GPU 场景更新 <code>UpdateGPUScene(RHICmdList, *Scene);</code> 不细看的话，暂时不知道是指什么场景</p><p>然后是 Pre Z Pass、延迟渲染的 GBuffer 相关的计算、Early occlusion queries、Early Shadow depth rendering、体积云初始化、大气 LUT、用于间接光照的 Light Propagation Volumes、体积雾计算、体积云计算、头发计算、forward 阴影渲染等</p><p>然后是 BasePass</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RenderBasePass</span>(GraphBuilder, BasePassDepthStencilAccess, SceneColorTexture.Target, SceneDepthTexture.Target, DepthLoadAction, ForwardScreenSpaceShadowMaskTexture);</span><br></pre></td></tr></table></figure><p>然后是速度矢量渲染（TAA 相关）、毛发渲染 BasePass、天光 RayTracing、Pre-lighting composition lighting stage（用于 SSAO 和延迟贴花等）、用于延迟渲染的毛发渲染 BasePass、自定义纹理的重建（用于 velocity, custom depth, and SSAO）、然后又是一些反射和天空光照渲染、体积云等</p><p>然后是渲染半透明物体，这里可以看到半透明物体也是可以渲染速度向量的</p><p>然后是后处理 pass，之后应该没有啥了</p><h3 id="FDeferredShadingSceneRenderer-RenderBasePass">FDeferredShadingSceneRenderer::RenderBasePass</h3><p><code>FDeferredShadingSceneRenderer::Render</code> 发起了很多渲染对象的渲染，不透明，半透明，体积云，体积雾，头发，阴影</p><p>最简单的还是看不透明物体是怎么渲染的</p><p>于是进入 <code>FDeferredShadingSceneRenderer::RenderBasePass</code></p><p>可以看到，它也只是一层包装。前面是关于如何 clear 纹理，然后进入 impl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RenderBasePassInternal</span>(GraphBuilder, BasePassRenderTargets, BasePassDepthStencilAccess, ForwardShadowMaskTexture, bDoParallelBasePass, bRenderLightmapDensity);</span><br></pre></td></tr></table></figure><p>进来，显而易见是两个 <code>View.ParallelMeshDrawCommandPasses[EMeshPass::BasePass].DispatchDraw</code> 可能在画不透明物体，因为其他的绘制命令都是 <code>EditorPrimitives</code> 和 <code>SkyPass</code>，一看就不相关</p><p>我调试的时候是进入了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GraphBuilder.<span class="built_in">AddPass</span>(</span><br><span class="line">    <span class="built_in">RDG_EVENT_NAME</span>(<span class="string">&quot;BasePassParallel&quot;</span>),</span><br><span class="line">    PassParameters,</span><br><span class="line">    ERDGPassFlags::Raster | ERDGPassFlags::SkipRenderPass,</span><br><span class="line">    [<span class="keyword">this</span>, &amp;View, PassParameters](FRHICommandListImmediate&amp; RHICmdList)</span><br><span class="line">&#123;</span><br><span class="line">    Scene-&gt;UniformBuffers.<span class="built_in">UpdateViewUniformBuffer</span>(View);</span><br><span class="line">    FRDGParallelCommandListSet <span class="built_in">ParallelCommandListSet</span>(RHICmdList, <span class="built_in">GET_STATID</span>(STAT_CLP_BasePass), *<span class="keyword">this</span>, View, <span class="built_in">FParallelCommandListBindings</span>(PassParameters));</span><br><span class="line">    View.ParallelMeshDrawCommandPasses[EMeshPass::BasePass].<span class="built_in">DispatchDraw</span>(&amp;ParallelCommandListSet, RHICmdList);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="BasePass-内的逻辑">BasePass 内的逻辑</h2><h3 id="分发绘制-command">分发绘制 command</h3><p>于是进到 <code>void FParallelMeshDrawCommandPass::DispatchDraw(FParallelCommandListSet* ParallelCommandListSet, FRHICommandList&amp; RHICmdList) const</code> 看</p><p>这个函数是负责拆分渲染任务，均分到多个线程并行工作</p><p>前面是准备上传顶点缓冲到 GPU Scene 然后是均分 task</p><p>分配循环内的循环体内的这两句，分配 task，应该会进到下一层，负责实际绘制逻辑把</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FGraphEventRef AnyThreadCompletionEvent = TGraphTask&lt;FDrawVisibleMeshCommandsAnyThreadTask&gt;::<span class="built_in">CreateTask</span>(&amp;Prereqs, RenderThread)</span><br><span class="line">    .<span class="built_in">ConstructAndDispatchWhenReady</span>(*CmdList, TaskContext.MeshDrawCommands, TaskContext.MinimalPipelineStatePassSet, PrimitiveIdsBuffer, BasePrimitiveIdsOffset, TaskContext.bDynamicInstancing, TaskContext.InstanceFactor, TaskIndex, NumTasks);</span><br><span class="line">ParallelCommandListSet-&gt;<span class="built_in">AddParallelCommandList</span>(CmdList, AnyThreadCompletionEvent, NumDraws);</span><br></pre></td></tr></table></figure><p>它分配完了 task 之后就退出来了</p><p>这个 task 实际执行还是在 render thread <code>ProcessTasksUntilQuit</code> 里</p><p>最终调用到 <code>FDrawVisibleMeshCommandsAnyThreadTask</code> 的 <code>DoTask</code>，它也只是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SubmitMeshDrawCommandsRange</span>(VisibleMeshDrawCommands, GraphicsMinimalPipelineStateSet, PrimitiveIdsBuffer, BasePrimitiveIdsOffset, bDynamicInstancing, StartIndex, NumDraws, InstanceFactor, RHICmdList);</span><br></pre></td></tr></table></figure><p>的包装</p><p>但是我突然意识到，这里的 <code>VisibleMeshDrawCommands</code> 已经是涉及到了要画什么 mesh 了</p><p>可能是我的 mesh 比较少吧，我这一个 <code>FDrawVisibleMeshCommandsAnyThreadTask</code> 的 <code>VisibleMeshDrawCommands</code> 就已经包含所有要画的 mesh，因为我通过 renderdoc 看到的就是这个数量</p><p><code>SubmitMeshDrawCommandsRange</code> 里面就是遍历这个传入的 <code>VisibleMeshDrawCommands</code>，对每一个 command 提交</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMeshDrawCommand::<span class="built_in">SubmitDraw</span>(*VisibleMeshDrawCommand.MeshDrawCommand, GraphicsMinimalPipelineStateSet, PrimitiveIdsBuffer, PrimitiveIdBufferOffset, InstanceFactor, RHICmdList, StateCache);</span><br></pre></td></tr></table></figure><h3 id="发起-draw-call">发起 draw call</h3><p>前面看的是怎么分配</p><p>现在这个 <code>FMeshDrawCommand::SubmitDraw</code> 就是怎么绘制网格了</p><p>前面是获取并设置图形管线状态、设置模板测试参考值、设置顶点流、设置着色器绑定（绑定常量缓冲、纹理、采样器等资源）</p><p>然后就是 draw call</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MeshDrawCommand.IndexBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (MeshDrawCommand.NumPrimitives &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        RHICmdList.<span class="built_in">DrawIndexedPrimitive</span>(</span><br><span class="line">            MeshDrawCommand.IndexBuffer,</span><br><span class="line">            MeshDrawCommand.VertexParams.BaseVertexIndex,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            MeshDrawCommand.VertexParams.NumVertices,</span><br><span class="line">            MeshDrawCommand.FirstIndex,</span><br><span class="line">            MeshDrawCommand.NumPrimitives,</span><br><span class="line">            MeshDrawCommand.NumInstances * InstanceFactor</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        RHICmdList.<span class="built_in">DrawIndexedPrimitiveIndirect</span>(</span><br><span class="line">            MeshDrawCommand.IndexBuffer, </span><br><span class="line">            MeshDrawCommand.IndirectArgs.Buffer, </span><br><span class="line">            MeshDrawCommand.IndirectArgs.Offset</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (MeshDrawCommand.NumPrimitives &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    RHICmdList.<span class="built_in">DrawPrimitive</span>(</span><br><span class="line">        MeshDrawCommand.VertexParams.BaseVertexIndex + MeshDrawCommand.FirstIndex,</span><br><span class="line">        MeshDrawCommand.NumPrimitives,</span><br><span class="line">            MeshDrawCommand.NumInstances * InstanceFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        RHICmdList.<span class="built_in">DrawPrimitiveIndirect</span>(</span><br><span class="line">            MeshDrawCommand.IndirectArgs.Buffer,</span><br><span class="line">            MeshDrawCommand.IndirectArgs.Offset</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这熟悉的结构</p><p>可能别的我都不熟，但是这个有 index buffer 就 draw indexed 否则直接 draw 的 draw call 形式，在我自己写的渲染器都是这样的，感动了</p><h3 id="DrawCall-Debug">DrawCall Debug</h3><p>可以看到他 <code>FMeshDrawCommand::SubmitDraw</code> 这里还有 debug 示例</p><p>看 <code>MeshDrawCommand.DebugData.MaterialName</code> 和 <code>MeshDrawCommand.DebugData.ResourceName</code> 就可以看到 mesh 来源，还有材质名称，方便定位问题</p><h2 id="BasePass-DrawCall-是如何绑定渲染着色器资源的">BasePass DrawCall 是如何绑定渲染着色器资源的</h2><p>现在我有一些自己的着色器资源，有纹理，有 uniform 等等，它们是怎么传进来的？</p><h3 id="从-draw-call-找着色器绑定，没找到">从 draw call 找着色器绑定，没找到</h3><p>于是看到 <code>FMeshDrawCommand::SubmitDraw</code> 的绑定着色器相关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MeshDrawCommand.ShaderBindings.<span class="built_in">SetOnCommandList</span>(RHICmdList, MeshPipelineState.BoundShaderState.<span class="built_in">AsBoundShaderState</span>(), StateCache.ShaderBindings);</span><br></pre></td></tr></table></figure><p>进到 <code>FMeshDrawShaderBindings::SetOnCommandList</code>，可以看到他只是根据一个 frequency 变量确认 shader 类型</p><p>最终不同的 shader 类型都是要调用 <code>SetShaderBindings</code>，但是参数不同</p><p>于是看到 <code>FMeshDrawShaderBindings::SetShaderBindings</code></p><p>一开始看到 Uniform Buffers 绑定</p><ol><li><p>从 SingleShaderBindings 中获取所有 Uniform Buffer 指针和对应的参数信息。</p></li><li><p>遍历所有 Uniform Buffer，检查当前绑定状态是否与缓存不同，避免重复绑定。</p></li><li><p>绑定 Uniform Buffer。</p></li><li><p>更新缓存状态</p></li></ol><p>这个利用缓存的逻辑之后也是一样的</p><p>所以就可以看一下各自的命令了</p><p>Uniform Buffers 绑定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RHICmdList.<span class="built_in">SetShaderUniformBuffer</span>(Shader, Parameter.BaseIndex, UniformBuffer);</span><br></pre></td></tr></table></figure><p>Sampler 绑定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RHICmdList.<span class="built_in">SetShaderSampler</span>(Shader, Parameter.BaseIndex, Sampler);</span><br></pre></td></tr></table></figure><p>SRV（Shader Resource View）绑定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RHICmdList.<span class="built_in">SetShaderResourceViewParameter</span>(Shader, Parameter.BaseIndex, SRV);</span><br></pre></td></tr></table></figure><p>Texture 绑定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RHICmdList.<span class="built_in">SetShaderTexture</span>(Shader, Parameter.BaseIndex, Texture);</span><br></pre></td></tr></table></figure><p>还有一个 LooseParameter，不知道干啥的，先跳过吧</p><p>但是当我对这些绑定的代码打断点的时候，发现代码从来没击中断点</p><p>一开始我还以为是，这些绑定只在物体新添加到场景的时候绑定一次，之后就利用缓存了</p><p>于是重新启动游戏，发现我的断点从来没有击中过</p><p>那就非常神奇了，不知道是谁绑定了纹理？</p><h3 id="从-PSSetShaderResources-找纹理绑定，没找到">从 PSSetShaderResources 找纹理绑定，没找到</h3><p>因为我在 RenderDoc 可以看到它绑定纹理的 API 是 PSSetShaderResources</p><p>于是去 UE 源码查他这个绑定的 API</p><p>发现他在源码里面的使用都是在 UE 的 UI 库 slate 中才有使用</p><p>要不然就是一个 <code>ClearShaderResource</code> 有在使用</p><p>这，完全找不到是怎么绑定的……</p><h3 id="从着色器资源类找">从着色器资源类找</h3><p>看别人的博客，发现这方面也有讲述</p><p><code>FShaderParameter</code> 是着色器的寄存器绑定参数, 它的类型可以是float1/2/3/4，数组, UAV等.</p><p><code>FShaderResourceParameter</code> 是着色器资源绑定(纹理或采样器)</p><p><code>FRWShaderParameter</code> 与 UAV or SRV 相关</p><p><code>TShaderUniformBufferParameter</code> 与 uniform 相关</p><p>但是我在 <code>FShaderResourceParameter::Bind</code> 和 <code>FRWShaderParameter::SetTexture</code> 打断点，都没有命中</p><p>后来我开 Editor 发现可以命中，但是命中的都是 uniform shader parameter，堆栈里面显示的是 editor primitives 的绘制</p><p>感觉这并不是 Editor 或者 Game 的构建配置的问题，纯粹是 Editor 有一些特殊调用而已</p><p>这种异常看上去是编译器优化了什么东西</p><p>于是使用 <code>PRAGMA_DISABLE_OPTIMIZATION</code> <code>PRAGMA_ENABLE_OPTIMIZATION</code> 但是还是没有效果</p><h3 id="从-SetShaderParameters-找">从 SetShaderParameters 找</h3><p>看别人博客 <a href="https://logins.github.io/graphics/2021/03/31/UE4ShadersIntroduction.html">https://logins.github.io/graphics/2021/03/31/UE4ShadersIntroduction.html</a>，他说</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TRHICmdList, <span class="keyword">typename</span> TShaderClass, <span class="keyword">typename</span> TShaderRHI&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SetShaderParameters</span><span class="params">(TRHICmdList&amp; RHICmdList, <span class="type">const</span> TShaderRef&lt;TShaderClass&gt;&amp; Shader, TShaderRHI* ShadeRHI, <span class="type">const</span> <span class="keyword">typename</span> TShaderClass::FParameters&amp; Parameters)</span></span></span><br></pre></td></tr></table></figure><p>是最常用的绑定函数</p><p>看了一下，确实有很多绑定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> FShaderParameterBindings::FResourceParameter&amp; ParameterBinding : Bindings.ResourceParameters)</span><br><span class="line">&#123;</span><br><span class="line">    EUniformBufferBaseType BaseType = (EUniformBufferBaseType)ParameterBinding.BaseType;</span><br><span class="line">    <span class="keyword">switch</span> (BaseType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> UBMT_TEXTURE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> ShaderParameterRef = *(FRHITexture**)(Base + ParameterBinding.ByteOffset);</span><br><span class="line">            RTBindingsWriter.<span class="built_in">SetTexture</span>(ParameterBinding.BaseIndex, ShaderParameterRef);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UBMT_SRV:</span><br><span class="line">        &#123;</span><br><span class="line">            FRHIShaderResourceView* ShaderParameterRef = *(FRHIShaderResourceView**)(Base + ParameterBinding.ByteOffset);</span><br><span class="line">            RTBindingsWriter.<span class="built_in">SetSRV</span>(ParameterBinding.BaseIndex, ShaderParameterRef);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UBMT_UAV:</span><br><span class="line">        &#123;</span><br><span class="line">            FRHIUnorderedAccessView* ShaderParameterRef = *(FRHIUnorderedAccessView**)(Base + ParameterBinding.ByteOffset);</span><br><span class="line">            RTBindingsWriter.<span class="built_in">SetUAV</span>(ParameterBinding.BaseIndex, ShaderParameterRef);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UBMT_SAMPLER:</span><br><span class="line">        &#123;</span><br><span class="line">            FRHISamplerState* ShaderParameterRef = *(FRHISamplerState**)(Base + ParameterBinding.ByteOffset);</span><br><span class="line">            RTBindingsWriter.<span class="built_in">SetSampler</span>(ParameterBinding.BaseIndex, ShaderParameterRef);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UBMT_RDG_TEXTURE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> GraphTexture = *<span class="built_in">reinterpret_cast</span>&lt;FRDGTexture* <span class="type">const</span>*&gt;(Base + ParameterBinding.ByteOffset);</span><br><span class="line">            <span class="built_in">checkSlow</span>(GraphTexture);</span><br><span class="line">            GraphTexture-&gt;<span class="built_in">MarkResourceAsUsed</span>();</span><br><span class="line">            RTBindingsWriter.<span class="built_in">SetTexture</span>(ParameterBinding.BaseIndex, GraphTexture-&gt;<span class="built_in">GetRHI</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UBMT_RDG_TEXTURE_SRV:</span><br><span class="line">        <span class="keyword">case</span> UBMT_RDG_BUFFER_SRV:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> GraphSRV = *<span class="built_in">reinterpret_cast</span>&lt;FRDGShaderResourceView* <span class="type">const</span>*&gt;(Base + ParameterBinding.ByteOffset);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">checkSlow</span>(GraphSRV);</span><br><span class="line">            GraphSRV-&gt;<span class="built_in">MarkResourceAsUsed</span>();</span><br><span class="line">            RTBindingsWriter.<span class="built_in">SetSRV</span>(ParameterBinding.BaseIndex, GraphSRV-&gt;<span class="built_in">GetRHI</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UBMT_RDG_TEXTURE_UAV:</span><br><span class="line">        <span class="keyword">case</span> UBMT_RDG_BUFFER_UAV:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> UAV = *<span class="built_in">reinterpret_cast</span>&lt;FRDGUnorderedAccessView* <span class="type">const</span>*&gt;(Base + ParameterBinding.ByteOffset);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">checkSlow</span>(UAV);</span><br><span class="line">            UAV-&gt;<span class="built_in">MarkResourceAsUsed</span>();</span><br><span class="line">            RTBindingsWriter.<span class="built_in">SetUAV</span>(ParameterBinding.BaseIndex, UAV-&gt;<span class="built_in">GetRHI</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">checkf</span>(<span class="literal">false</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Unhandled resource type?&quot;</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我查找了一下它的引用，怎么都是 RayTracing 在用？没有别人在用了。</p><p>打断点，发现还是有一个 <code>UpdateGPUScene(RHICmdList, *Scene);</code> 在用，最终到 <code>FComputeShaderUtils::Dispatch</code>。但是似乎和 Base Pass 怎么绑定 mesh 的没有关系</p><h3 id="在-FShaderResourceParameter-加-Log">在 FShaderResourceParameter 加 Log</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FShaderResourceParameter::Bind</span><span class="params">(<span class="type">const</span> FShaderParameterMap&amp; ParameterMap,<span class="type">const</span> TCHAR* ParameterName,EShaderParameterFlags Flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;FShaderResourceParameter::Bind here!!!!!&quot;</span>));</span><br></pre></td></tr></table></figure><p>也没有输出</p><h3 id="重新看一下渲染流程">重新看一下渲染流程</h3><p>看了</p><p><a href="https://github.com/donaldwuid/unreal_source_explained/blob/master/main/rendering.md">https://github.com/donaldwuid/unreal_source_explained/blob/master/main/rendering.md</a></p><p>也没有解决我的问题，就是纹理是从哪里加载过来的</p><h3 id="从-UTexture2D-出发">从 UTexture2D 出发</h3><p>那些地方都打不到断点，于是从 <code>UTexture2D</code> 出发打断点</p><p>研究了一下，觉得 <code>UTexture::SetResource</code> 很像是跟渲染资源相关的地方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UTexture::SetResource</span><span class="params">(FTextureResource* InResource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">check</span> (!<span class="built_in">IsInActualRenderingThread</span>() &amp;&amp; !<span class="built_in">IsInRHIThread</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each PrivateResource value must be updated in it&#x27;s own thread because any</span></span><br><span class="line"><span class="comment">// rendering code trying to access the Resource from this UTexture will</span></span><br><span class="line"><span class="comment">// crash if it suddenly sees nullptr or a new resource that has not had it&#x27;s InitRHI called.</span></span><br><span class="line"></span><br><span class="line">PrivateResource = InResource;</span><br><span class="line"><span class="built_in">ENQUEUE_RENDER_COMMAND</span>(SetResourceRenderThread)([<span class="keyword">this</span>, InResource](FRHICommandListImmediate&amp; RHICmdList)</span><br><span class="line">&#123;</span><br><span class="line">PrivateResourceRenderThread = InResource;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还说了需要 init 资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UTexture::SetResource(FTextureResource *) Texture.cpp:147</span><br><span class="line">UTexture::UpdateResource() Texture.cpp:190</span><br><span class="line">UTexture2D::UpdateResource() Texture2D.cpp:440</span><br><span class="line">UTexture::PostLoad() Texture.cpp:481</span><br><span class="line">UTexture2D::PostLoad() Texture2D.cpp:377</span><br><span class="line">UObject::ConditionalPostLoad() Obj.cpp:1092</span><br><span class="line">FAsyncPackage::PostLoadObjects() AsyncLoading.cpp:6424</span><br><span class="line">FAsyncPackage::TickAsyncPackage(bool, bool, float &amp;, FFlushTree *) AsyncLoading.cpp:5590</span><br><span class="line">FAsyncLoadingThread::ProcessAsyncLoading(int &amp;, bool, bool, float, FFlushTree *) AsyncLoading.cpp:4098</span><br><span class="line">FAsyncLoadingThread::TickAsyncThread(bool, bool, float, bool &amp;, FFlushTree *) AsyncLoading.cpp:4856</span><br><span class="line">FAsyncLoadingThread::TickAsyncLoading(bool, bool, float, FFlushTree *) AsyncLoading.cpp:4556</span><br><span class="line">FAsyncLoadingThread::FlushLoading(int) AsyncLoading.cpp:7022</span><br><span class="line">FlushAsyncLoading(int) AsyncPackageLoader.cpp:643</span><br><span class="line">LoadPackageInternal(UPackage *, const wchar_t *, unsigned int, FLinkerLoad *, FArchive *, const FLinkerInstancingContext *) UObjectGlobals.cpp:1144</span><br><span class="line">LoadPackage(UPackage *, const wchar_t *, unsigned int, FArchive *, const FLinkerInstancingContext *) UObjectGlobals.cpp:1469</span><br></pre></td></tr></table></figure><p>这个调用堆栈也很清晰</p><p>感觉上一层的 update 应该是核心逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UTexture::UpdateResource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Release the existing texture resource.</span></span><br><span class="line"><span class="built_in">ReleaseResource</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dedicated servers have no texture internals</span></span><br><span class="line"><span class="keyword">if</span>( FApp::<span class="built_in">CanEverRender</span>() &amp;&amp; !<span class="built_in">HasAnyFlags</span>(RF_ClassDefaultObject) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Create a new texture resource.</span></span><br><span class="line">FTextureResource* NewResource = <span class="built_in">CreateResource</span>();</span><br><span class="line"><span class="built_in">SetResource</span>(NewResource);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (NewResource)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init the texture reference, which needs to be set from a render command, since TextureReference.TextureReferenceRHI is gamethread coherent.</span></span><br><span class="line"><span class="built_in">ENQUEUE_RENDER_COMMAND</span>(SetTextureReference)([<span class="keyword">this</span>, NewResource](FRHICommandListImmediate&amp; RHICmdList)</span><br><span class="line">&#123;</span><br><span class="line">NewResource-&gt;<span class="built_in">SetTextureReference</span>(TextureReference.TextureReferenceRHI);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">BeginInitResource</span>(NewResource);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>SetResource</code> 和 <code>SetTextureReference</code> 就是简单的 set，没有做别的事情，很舒服</p><p>但是在看的时候，发现他这个注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * The rendering resource which represents a texture.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FTextureResource</span> : <span class="keyword">public</span> FTexture</span><br></pre></td></tr></table></figure><p>他的成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A FRHITextureReference to update whenever the FTexture::TextureRHI changes.</span></span><br><span class="line"><span class="comment">// It allows to prevent dereferencing the UAsset pointers when updating a texture resource.</span></span><br><span class="line">FTextureReferenceRHIRef TextureReferenceRHI;</span><br></pre></td></tr></table></figure><p>似乎有点关系</p><p>也看到 <code>class UTexture : public UStreamableRenderAsset, public IInterface_AssetUserData</code></p><p>的成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The texture&#x27;s resource, can be NULL */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FTextureResource</span>* PrivateResource;</span><br><span class="line"><span class="comment">/** Value updated and returned by the render-thread to allow</span></span><br><span class="line"><span class="comment">    * fenceless update from the game-thread without causing</span></span><br><span class="line"><span class="comment">    * potential crash in the render thread.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FTextureResource</span>* PrivateResourceRenderThread;</span><br></pre></td></tr></table></figure><p>说明它是考虑了运行时重新加载纹理的</p><p>然后在 <code>FRenderResource::InitResource</code> 打断点，蹲到纹理资源的 init</p><p>调用到 <code>FStreamableTextureResource::InitRHI</code></p><p>这其中重要的应该是</p><p><code>FTexture2DResource::CreateTexture</code> 还有一个 <code>RHIUpdateTextureReference(TextureReferenceRHI, TextureRHI);</code></p><p>create 就是调用平台特定的 API 去创建 GPU 资源句柄</p><p>reference 这里还是不知道干什么的</p><p>reload package 之后，再会调用一次 texture 的 <code>UTexture2D::PostLoad</code>，跟之前一样</p><p>回来看 <code>UTexture</code>，我想知道 Material 是怎么使用到这个材质的，或者是别的什么，总之，渲染器是怎么获取并绑定这个纹理的</p><p>于是看到这个 getter</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Get the texture&#x27;s resource, can be NULL */</span></span><br><span class="line"><span class="function">ENGINE_API FTextureResource* <span class="title">GetResource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the const texture&#x27;s resource, can be NULL */</span></span><br><span class="line"><span class="function">ENGINE_API <span class="type">const</span> FTextureResource* <span class="title">GetResource</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>这个 getter 是绑定了 <code>UTexture</code> 的 <code>TFieldPtrAccessor&lt;FTextureResource&gt; Resource;</code> 成员</p><p>不断蹲，蹲到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">UTexture::GetResource() Texture.cpp:132</span><br><span class="line">UE4Function_Private::TFunctionRefCaller::Call(void *) Function.h:539</span><br><span class="line">UE4Function_Private::TFunctionRefBase::operator()() Function.h:676</span><br><span class="line">FUniformExpressionSet::FillUniformBuffer(const FMaterialRenderContext &amp;, const FUniformExpressionCache &amp;, unsigned char *, int) MaterialUniformExpressions.cpp:1433</span><br><span class="line">FMaterialRenderProxy::EvaluateUniformExpressions(FUniformExpressionCache &amp;, const FMaterialRenderContext &amp;, FRHICommandList *) MaterialShared.cpp:2956</span><br><span class="line">&lt;lambda_4b8eb6ac...&gt;::operator()(Type) MaterialShared.cpp:3213</span><br><span class="line">UMaterialInterface::IterateOverActiveFeatureLevels&lt;…&gt;(&lt;lambda_4b8eb6ac...&gt;) MaterialInterface.h:861</span><br><span class="line">FMaterialRenderProxy::UpdateDeferredCachedUniformExpressions() MaterialShared.cpp:3205</span><br><span class="line">TEnqueueUniqueRenderCommandType&lt;`FRendererModule::BeginRenderingViewFamily&#x27;::`2&#x27;::UpdateDeferredCachedUniformExpressionsName,&lt;lambda_af3a665d491aaad33361bc0d189d73fc&gt; &gt;::DoTask(Type,const TRefCountPtr&lt;FGraphEvent&gt; &amp;) RenderingThread.h:183</span><br><span class="line">TGraphTask&lt;TEnqueueUniqueRenderCommandType&lt;`FRendererModule::BeginRenderingViewFamily&#x27;::`2&#x27;::UpdateDeferredCachedUniformExpressionsName,&lt;lambda_af3a665d491aaad33361bc0d189d73fc&gt; &gt; &gt;::ExecuteTask(TArray&lt;FBaseGraphTask *,TSizedDefaultAllocator&lt;32&gt; &gt; &amp;,Type) TaskGraphInterfaces.h:886</span><br><span class="line">FNamedTaskThread::ProcessTasksNamedThread(int, bool) TaskGraph.cpp:710</span><br><span class="line">FNamedTaskThread::ProcessTasksUntilQuit(int) TaskGraph.cpp:601</span><br><span class="line">FTaskGraphImplementation::ProcessThreadUntilRequestReturn(Type) TaskGraph.cpp:1480</span><br><span class="line">RenderingThreadMain(FEvent *) RenderingThread.cpp:372</span><br></pre></td></tr></table></figure><p>这个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FUniformExpressionSet::FillUniformBuffer</span><span class="params">(<span class="type">const</span> FMaterialRenderContext&amp; MaterialRenderContext, <span class="type">const</span> FUniformExpressionCache&amp; UniformExpressionCache, uint8* TempBuffer, <span class="type">int</span> TempBufferSize)</span> <span class="type">const</span></span></span><br></pre></td></tr></table></figure><p>看上去像是建立起材质和纹理之间的关系的部分</p><p>这里包含多个纹理类型的绑定，取其中 Texture2D 的来看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int32 ExpressionIndex = <span class="number">0</span>; ExpressionIndex &lt; <span class="built_in">GetNumTextures</span>(EMaterialTextureParameterType::Standard2D); ExpressionIndex++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> FMaterialTextureParameterInfo&amp; Parameter = <span class="built_in">GetTextureParameter</span>(EMaterialTextureParameterType::Standard2D, ExpressionIndex);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> UTexture* Value = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">GetTextureValue</span>(EMaterialTextureParameterType::Standard2D, ExpressionIndex, MaterialRenderContext, MaterialRenderContext.Material, Value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 资源有效性检查和日志警告</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算纹理和采样器指针在缓冲区中的位置</span></span><br><span class="line">    <span class="type">void</span>** ResourceTableTexturePtr = (<span class="type">void</span>**)((uint8*)BufferCursor + <span class="number">0</span> * SHADER_PARAMETER_POINTER_ALIGNMENT);</span><br><span class="line">    <span class="type">void</span>** ResourceTableSamplerPtr = (<span class="type">void</span>**)((uint8*)BufferCursor + <span class="number">1</span> * SHADER_PARAMETER_POINTER_ALIGNMENT);</span><br><span class="line">    BufferCursor = ((uint8*)BufferCursor) + (SHADER_PARAMETER_POINTER_ALIGNMENT * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">check</span>(BufferCursor &lt;= TempBuffer + TempBufferSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许的纹理类型掩码</span></span><br><span class="line">    <span class="type">const</span> uint32 ValidTextureTypes = MCT_Texture2D | MCT_TextureVirtual | MCT_TextureExternal;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> bValueValid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 资源有效性判断</span></span><br><span class="line">    <span class="keyword">if</span> (Value &amp;&amp; Value-&gt;Resource &amp;&amp; Value-&gt;TextureReference.TextureReferenceRHI &amp;&amp; (Value-&gt;<span class="built_in">GetMaterialType</span>() &amp; ValidTextureTypes) != <span class="number">0u</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FSamplerStateRHIRef* SamplerSource = &amp;Value-&gt;Resource-&gt;SamplerStateRHI;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据采样器来源模式选择采样器</span></span><br><span class="line">        <span class="type">const</span> ESamplerSourceMode SourceMode = Parameter.SamplerSource;</span><br><span class="line">        <span class="keyword">if</span> (SourceMode == SSM_Wrap_WorldGroupSettings)</span><br><span class="line">        &#123;</span><br><span class="line">            SamplerSource = &amp;Wrap_WorldGroupSettings-&gt;SamplerStateRHI;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (SourceMode == SSM_Clamp_WorldGroupSettings)</span><br><span class="line">        &#123;</span><br><span class="line">            SamplerSource = &amp;Clamp_WorldGroupSettings-&gt;SamplerStateRHI;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*SamplerSource)</span><br><span class="line">        &#123;</span><br><span class="line">            *ResourceTableTexturePtr = Value-&gt;TextureReference.TextureReferenceRHI;</span><br><span class="line">            *ResourceTableSamplerPtr = *SamplerSource;</span><br><span class="line">            bValueValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ensureMsgf</span>(<span class="literal">false</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Texture %s had invalid sampler source.&quot;</span>), *Value-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果资源无效，绑定默认白色纹理和采样器</span></span><br><span class="line">    <span class="keyword">if</span> (!bValueValid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">check</span>(GWhiteTexture-&gt;TextureRHI);</span><br><span class="line">        *ResourceTableTexturePtr = GWhiteTexture-&gt;TextureRHI;</span><br><span class="line">        <span class="built_in">check</span>(GWhiteTexture-&gt;SamplerStateRHI);</span><br><span class="line">        *ResourceTableSamplerPtr = GWhiteTexture-&gt;SamplerStateRHI;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，Material 一开始就存储了 <code>UTexture*</code>，纹理和材质的关系是已经建立好了</p><p>现在是要建立 Uniform buffer 和 texture 之间的关系</p><p>简单来说就是，计算缓冲区写入位置，写入纹理和采样器指针</p><p>如果，我是说如果，这个材质的渲染对我这个 2D 纹理的获取完全是依赖于 UniformExpression 的，那么就可以确定，材质仅仅通过这个路径被 GPU 获取</p><h2 id="研究-FMaterialRenderProxy">研究 FMaterialRenderProxy</h2><h3 id="第一次更新-UniformExpression">第一次更新 UniformExpression</h3><p>第一次调用应该是在 <code>FRendererModule::BeginRenderingViewFamily</code></p><p>在这里有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ENQUEUE_RENDER_COMMAND</span>(UpdateDeferredCachedUniformExpressions)(</span><br><span class="line">    [](FRHICommandList&amp; RHICmdList)</span><br><span class="line">    &#123;</span><br><span class="line">        FMaterialRenderProxy::<span class="built_in">UpdateDeferredCachedUniformExpressions</span>();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>调用到 <code>FMaterialRenderProxy::UpdateDeferredCachedUniformExpressions</code></p><h3 id="更新-UniformExpression-时如何遍历-FMaterialRenderProxy">更新 UniformExpression 时如何遍历 FMaterialRenderProxy</h3><p><code>FMaterialRenderProxy::UpdateDeferredCachedUniformExpressions</code> 这里可以看到是如何遍历 <code>FMaterialRenderProxy</code> 的</p><p>精简之后是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FMaterialRenderProxy::UpdateDeferredCachedUniformExpressions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (TSet&lt;FMaterialRenderProxy*&gt;::TConstIterator <span class="built_in">It</span>(DeferredUniformExpressionCacheRequests); It; ++It)</span><br><span class="line">&#123;</span><br><span class="line">FMaterialRenderProxy* MaterialProxy = *It;</span><br><span class="line">UMaterialInterface::<span class="built_in">IterateOverActiveFeatureLevels</span>([&amp;](ERHIFeatureLevel::Type InFeatureLevel)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Don&#x27;t bother caching if we&#x27;ll be falling back to a different FMaterialRenderProxy for rendering anyway</span></span><br><span class="line"><span class="type">const</span> FMaterial* Material = MaterialProxy-&gt;<span class="built_in">GetMaterialNoFallback</span>(InFeatureLevel);</span><br><span class="line"><span class="keyword">if</span> (Material &amp;&amp; Material-&gt;<span class="built_in">GetRenderingThreadShaderMap</span>())</span><br><span class="line">&#123;</span><br><span class="line">FMaterialRenderContext <span class="built_in">MaterialRenderContext</span>(MaterialProxy, *Material, <span class="literal">nullptr</span>);</span><br><span class="line">MaterialProxy-&gt;<span class="built_in">EvaluateUniformExpressions</span>(MaterialProxy-&gt;UniformExpressionCache[(int32)InFeatureLevel], MaterialRenderContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DeferredUniformExpressionCacheRequests.<span class="built_in">Reset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他这里是遍历一个 <code>DeferredUniformExpressionCacheRequests</code>，跳转可见，这是一个类的全局变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TSet&lt;FMaterialRenderProxy*&gt; FMaterialRenderProxy::MaterialRenderProxyMap;</span><br><span class="line">TSet&lt;FMaterialRenderProxy*&gt; FMaterialRenderProxy::DeferredUniformExpressionCacheRequests;</span><br></pre></td></tr></table></figure><h3 id="FMaterialRenderProxy-全局列表">FMaterialRenderProxy 全局列表</h3><p>找 <code>DeferredUniformExpressionCacheRequests</code> 的增删。Add 的逻辑在 <code>FMaterialRenderProxy::CacheUniformExpressions</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FMaterialRenderProxy::CacheUniformExpressions</span><span class="params">(<span class="type">bool</span> bRecreateUniformBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Register the render proxy&#x27;s as a render resource so it can receive notifications to free the uniform buffer.</span></span><br><span class="line"><span class="built_in">InitResource</span>();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">DeferredUniformExpressionCacheRequests.<span class="built_in">Add</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">InvalidateUniformExpressionCache</span>(bRecreateUniformBuffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!GDeferUniformExpressionCaching)</span><br><span class="line">&#123;</span><br><span class="line">FMaterialRenderProxy::<span class="built_in">UpdateDeferredCachedUniformExpressions</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先把自己加到全局变量的列表</p><p>如果重建，那么有一个专门的 invalidate 的函数 <code>InvalidateUniformExpressionCache</code></p><p>然后如果设置了 cache，那么之后 update UniformExpression</p><p>如果没有设置 cache，那么立即 update UniformExpression</p><p>看下他这个 invalidate 的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FMaterialRenderProxy::InvalidateUniformExpressionCache</span><span class="params">(<span class="type">bool</span> bRecreateUniformBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">++UniformExpressionCacheSerialNumber;</span><br><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; ERHIFeatureLevel::Num; ++i)</span><br><span class="line">&#123;</span><br><span class="line">UniformExpressionCache[i].bUpToDate = <span class="literal">false</span>;</span><br><span class="line">UniformExpressionCache[i].CachedUniformExpressionShaderMap = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bRecreateUniformBuffer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// This is required if the FMaterial is being recompiled (the uniform buffer layout will change).</span></span><br><span class="line"><span class="comment">// This should only be done if the calling code is using FMaterialUpdateContext to recreate the rendering state of primitives using this material, </span></span><br><span class="line"><span class="comment">// Since cached mesh commands also cache uniform buffer pointers.</span></span><br><span class="line">UniformExpressionCache[i].UniformBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注释似乎指的是，材质重新编译的时候，需要重建 uniform buffer，因为 uniform buffer 的 layout 会发生改变</p><p>and 不得不说的是，UE 里面的 uniform buffer 和 glsl 中的 uniform 变量，是不一样的概念。好令人错乱。</p><p>然后这个重建函数应该被 <code>FMaterialUpdateContext</code> 调用，因为 mesh command 的缓存里面，缓存了 uniform buffer 的指针，所以重建还需要把 mesh command 的缓存里面的 uniform buffer 的指针缓存给清了</p><p>那么他的意思应该是，<code>FMaterialUpdateContext</code> 可以这样清缓存</p><h3 id="添加-FMaterialRenderProxy-到全局列表的源头">添加 FMaterialRenderProxy 到全局列表的源头</h3><p>找谁调用了 <code>FMaterialRenderProxy::CacheUniformExpressions</code></p><p>除了 Material 类自己的方法，还看到一个 <code>FExternalTextureRegistry::RegisterExternalTexture</code> 很酷</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FExternalTextureRegistry::RegisterExternalTexture</span><span class="params">(<span class="type">const</span> FGuid&amp; InGuid, FTextureRHIRef&amp; InTextureRHI, FSamplerStateRHIRef&amp; InSamplerStateRHI, <span class="type">const</span> FLinearColor&amp; InCoordinateScaleRotation, <span class="type">const</span> FLinearColor&amp; InCoordinateOffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">TextureEntries.<span class="built_in">Add</span>(InGuid, <span class="built_in">FExternalTextureEntry</span>(InTextureRHI, InSamplerStateRHI, InCoordinateScaleRotation, InCoordinateOffset));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> FMaterialRenderProxy* MaterialRenderProxy : ReferencingMaterialRenderProxies)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">const_cast</span>&lt;FMaterialRenderProxy*&gt;(MaterialRenderProxy)-&gt;<span class="built_in">CacheUniformExpressions</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是可以直接遍历所有相关联的 <code>MaterialRenderProxy</code> 然后直接遍历 cache</p><p>搜了一下他这个成员 <code>TSet&lt;const FMaterialRenderProxy*&gt; ReferencingMaterialRenderProxies;</code> 的类型 <code>TSet&lt;const FMaterialRenderProxy*&gt;</code>，结果发现只有它有</p><p>我还希望 Texture 相关的类型也有这个相关性呢，如果有，那就很好了</p><p>回到 Material 相关的搜索结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Updates a parameter on the material instance from the game thread.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ParameterType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameThread_UpdateMIParameter</span><span class="params">(<span class="type">const</span> UMaterialInstance* Instance, <span class="type">const</span> ParameterType&amp; Parameter)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FMaterialRenderProxy::CacheUniformExpressions_GameThread</span><span class="params">(<span class="type">bool</span> bRecreateUniformBuffer)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetShaderMapsOnMaterialResources_RenderThread</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList, FMaterialsToUpdateMap&amp; MaterialsToUpdate)</span></span></span><br></pre></td></tr></table></figure><p>都感觉很像</p><p>随便选了一个 <code>FMaterialRenderProxy::CacheUniformExpressions_GameThread</code> 开始不断找 usage，最终找到 <code>UMaterial::PostLoad</code></p><p>删掉编辑器相关的、兼容性相关的、统计相关的，精简为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMaterial::PostLoad</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// needed for UMaterial as it doesn&#x27;t have the InitResources() override where this is called</span></span><br><span class="line"><span class="built_in">PropagateDataToMaterialProxy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before caching shader resources we have to make sure all referenced textures have been post loaded</span></span><br><span class="line">    <span class="comment">// as we depend on their resources being valid.</span></span><br><span class="line">    <span class="keyword">for</span> (UObject* Texture : CachedExpressionData.ReferencedTextures)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Texture)</span><br><span class="line">        &#123;</span><br><span class="line">            Texture-&gt;<span class="built_in">ConditionalPostLoad</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CacheResourceShadersForRendering</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先传播 data，然后保证纹理加载正常，然后缓存 shader 资源用于渲染</p><p>其中 <code>UMaterial::CacheResourceShadersForRendering</code> 是和 uniform buffer 相关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMaterial::CacheResourceShadersForRendering</span><span class="params">(<span class="type">bool</span> bRegenerateId, EMaterialShaderPrecompileMode PrecompileMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bRegenerateId)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Regenerate this material&#x27;s Id if requested</span></span><br><span class="line"><span class="built_in">FlushResourceShaderMaps</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resources cannot be deleted before uniform expressions are recached because</span></span><br><span class="line"><span class="comment">// UB layouts will be accessed and they are owned by material resources</span></span><br><span class="line">FMaterialResourceDeferredDeletionArray ResourcesToFree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FApp::<span class="built_in">CanEverRender</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> EMaterialQualityLevel::Type ActiveQualityLevel = <span class="built_in">GetCachedScalabilityCVars</span>().MaterialQualityLevel;</span><br><span class="line">uint32 FeatureLevelsToCompile = <span class="built_in">GetFeatureLevelsToCompileForRendering</span>();</span><br><span class="line"></span><br><span class="line">TArray&lt;FMaterialResource*&gt; ResourcesToCache;</span><br><span class="line"><span class="keyword">while</span> (FeatureLevelsToCompile != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> ERHIFeatureLevel::Type FeatureLevel = (ERHIFeatureLevel::Type)FBitSet::<span class="built_in">GetAndClearNextBit</span>(FeatureLevelsToCompile);</span><br><span class="line"><span class="type">const</span> EShaderPlatform ShaderPlatform = GShaderPlatformForFeatureLevel[FeatureLevel];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only cache shaders for the quality level that will actually be used to render</span></span><br><span class="line"><span class="comment">// In cooked build, there is no shader compilation but this is still needed</span></span><br><span class="line"><span class="comment">// to register the loaded shadermap</span></span><br><span class="line">FMaterialResource* CurrentResource = <span class="built_in">FindOrCreateMaterialResource</span>(MaterialResources, <span class="keyword">this</span>, <span class="literal">nullptr</span>, FeatureLevel, ActiveQualityLevel);</span><br><span class="line"><span class="built_in">check</span>(CurrentResource);</span><br><span class="line"></span><br><span class="line">ResourcesToCache.<span class="built_in">Reset</span>();</span><br><span class="line">ResourcesToCache.<span class="built_in">Add</span>(CurrentResource);</span><br><span class="line"><span class="built_in">CacheShadersForResources</span>(ShaderPlatform, ResourcesToCache, PrecompileMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">RecacheUniformExpressions</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ResourcesToFree.<span class="built_in">Num</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ENQUEUE_RENDER_COMMAND</span>(CmdFreeUnusedMaterialResources)(</span><br><span class="line">[ResourcesToFreeRT = <span class="built_in">MoveTemp</span>(ResourcesToFree)](FRHICommandList&amp;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (int32 Idx = <span class="number">0</span>; Idx &lt; ResourcesToFreeRT.<span class="built_in">Num</span>(); ++Idx)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> ResourcesToFreeRT[Idx];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这里是先缓存 <code>FMaterialResource</code> 类型的对象，然后缓存 <code>UniformExpression</code></p><p><code>UMaterial::RecacheUniformExpressions</code> 内部对默认的 Material 实例调用我之前想找的 <code>CacheUniformExpressions_GameThread</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMaterial::RecacheUniformExpressions</span><span class="params">(<span class="type">bool</span> bRecreateUniformBuffer)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> bUsingNewLoader = EVENT_DRIVEN_ASYNC_LOAD_ACTIVE_AT_RUNTIME &amp;&amp; GEventDrivenLoaderEnabled;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure that default material is available before caching expressions.</span></span><br><span class="line"><span class="keyword">if</span> (!bUsingNewLoader)</span><br><span class="line">&#123;</span><br><span class="line">UMaterial::<span class="built_in">GetDefaultMaterial</span>(MD_Surface);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (DefaultMaterialInstance)</span><br><span class="line">&#123;</span><br><span class="line">DefaultMaterialInstance-&gt;<span class="built_in">CacheUniformExpressions_GameThread</span>(bRecreateUniformBuffer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去，一个材质是一个抽象的概念，实际逻辑一定有一个实例来完成，是这个意思？</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Unreal Engine 4 </tag>
            
            <tag> Render </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4.27.2 调试 Standalone 游戏的方法</title>
      <link href="/2025/05/14/2025-05-14-ue4_debug_standalone_game/"/>
      <url>/2025/05/14/2025-05-14-ue4_debug_standalone_game/</url>
      
        <content type="html"><![CDATA[<h2 id="从任务管理器发起调试">从任务管理器发起调试</h2><p>使用 Debug 或者 DebugGame 构建选项来打包游戏</p><p>应该会在如下目录出现对应配置的 exe 和 pdb，文件名类似 <code>&lt;Your Project Name&gt;-Win64-Debug.exe</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Your Project Root&gt;\&lt;Your Project Name&gt;\Binaries\Win64\</span><br></pre></td></tr></table></figure><p>把这个 exe 和 pdb 复制到如下目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Your Package Game Root&gt;\WindowsNoEditor\&lt;Your Project Name&gt;\Binaries\Win64\</span><br></pre></td></tr></table></figure><p>然后启动 exe，在任务管理器右键游戏进程，调试，选 VS 作为调试器，然后把要调试的文件拖进 IDE，打断点，应该可以看到断点正常，没有显示“未加载符号，断点无法命中”的错</p><h2 id="其他失败的尝试">其他失败的尝试</h2><p>如果复制到别的目录，比如直觉上是打包后的根目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Your Package Game Root&gt;\WindowsNoEditor\&lt;Your Project Name&gt;\</span><br></pre></td></tr></table></figure><p>或者如果就是游戏工程里的目录放在那里不动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Your Project Root&gt;\&lt;Your Project Name&gt;\Binaries\Win64\</span><br></pre></td></tr></table></figure><p>则会出现 content 路径找不到的错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">game files required to initialize the global shader library are missing from:</span><br><span class="line">&lt;Your Project Root&gt;\&lt;Your Project Name&gt;/Content/</span><br><span class="line">Please make sure the game is installed correctly</span><br></pre></td></tr></table></figure><p>题外话，不确定为什么，我把 pdb 复制到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Your Package Game Root&gt;\WindowsNoEditor\&lt;Your Project Name&gt;\</span><br></pre></td></tr></table></figure><p>调试时 VS 也无法加载 pdb，难道是因为我之前有编译过 shipping 导致的？</p><h2 id="从任务管理器发起调试的问题：看不到变量的值">从任务管理器发起调试的问题：看不到变量的值</h2><p>这样虽然可以调试</p><p>但是看不到变量的值</p><p><img src="/images/ue4_debug_standalone_game/cannot_see_variables.png" alt="alt text"></p><p>只能说，可以看到 log 还是有点用的</p><h2 id="兼得查看变量值的方法：调试-Game-Target">兼得查看变量值的方法：调试 Game Target</h2><p>在 IDE 构建配置里面的 Target 配置里面选择 Game，开启调试</p><p>也会遇到 content 路径找不到的错误</p><p>于是先按照之前说的，把游戏工程里构建出来的 exe 和 pdb 复制到打包工程的路径 \Binaries\Win64，然后把 IDE（以 Rider 为例）调试设置里面的 exe 路径从</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(LocalDebuggerCommand)</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Your Package Game Root&gt;\WindowsNoEditor\&lt;Your Project Name&gt;\Binaries\Win64\&lt;Your Project Name&gt;-Win64-Debug.exe</span><br></pre></td></tr></table></figure><p>这样调试就可以看到变量值了</p><p><img src="/images/ue4_debug_standalone_game/can_see_variables.png" alt="alt text"></p><p>具体原因不想思考了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Unreal Engine 4 </tag>
            
            <tag> Package </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4.27.2 PAK 文件运行时加载的调试分析</title>
      <link href="/2025/05/14/2025-05-14-ue4_load_pak_at_runtime/"/>
      <url>/2025/05/14/2025-05-14-ue4_load_pak_at_runtime/</url>
      
        <content type="html"><![CDATA[<h2 id="分析目标：挂载了-pak-之后怎么加载其中的资产？">分析目标：挂载了 pak 之后怎么加载其中的资产？</h2><p>脑子里暂时比较乱，在网上查了一些东西也没看懂</p><p><code>AssetRegistry.bin</code> 是干什么的，为什么我在 Cooked 文件夹中看到了它，但是在我的 pak 文件的解压结果中却没有？它会影响我挂载 pak 时的资源查找吗？</p><p><code>AssetRegistry.ScanPathsSynchronous</code> 实际干了什么？为什么我挂载了 pak 之后，调用了它，我还是找不到我 pak 中的资产？</p><p><code>FPakPlatformFile::MountAllPakFiles</code> 是游戏开始时加载所有 pak 的入口，这个内部也是调用 <code>FPakPlatformFile::Mount</code></p><p><code>LoadObject</code> 怎么找到这些文件的？</p><h2 id="挂载-PAK-文件">挂载 PAK 文件</h2><p>通过 <code>FPakPlatformFile::Mount</code> 来挂载 pak 文件</p><p>前半部分是创建 <code>FPakFile</code> 对象，加到 <code>FPakPlatformFile</code> 自己的数组里面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRefCountPtr&lt;FPakFile&gt; Pak = <span class="keyword">new</span> <span class="built_in">FPakFile</span>(LowerLevel, InPakFilename, bSigned, bLoadIndex);</span><br></pre></td></tr></table></figure><p>那么其实这里相当于仅仅是创建对象而已</p><p>要么具体从磁盘加载到 package 的逻辑在后面，要么在 <code>FPakFile</code> 构造函数里面</p><p>那么可以看到 <code>FPakFile</code> 构造函数调用了 <code>FPakFile::Initialize</code>。这里面也仅仅是读取 pak 文件信息，而不是读取所有内容。</p><p>于是看到 <code>FPakPlatformFile::Mount</code> 的后面的部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FIoDispatcher::<span class="built_in">IsInitialized</span>())</span><br><span class="line">&#123;</span><br><span class="line">FIoStoreEnvironment IoStoreEnvironment;</span><br><span class="line">IoStoreEnvironment.<span class="built_in">InitializeFileEnvironment</span>(FPaths::<span class="built_in">ChangeExtension</span>(InPakFilename, <span class="built_in">FString</span>()), PakOrder);</span><br><span class="line">FIoStatus IoStatus = FIoDispatcher::<span class="built_in">Get</span>().<span class="built_in">Mount</span>(IoStoreEnvironment, EncryptionKeyGuid, EncryptionKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FIoDispatcher::Mount</code> -&gt; <code>FIoDispatcherImpl::Mount</code> -&gt; <code>FFileIoStore::Mount</code></p><p>于是看到是要加载 utoc 文件</p><p>这跟我想看的不一样</p><p>所以我还是没有看到 pak mount 之后，是怎么影响 package 的</p><h2 id="LoadObject">LoadObject</h2><p><code>LoadObject</code> 是 <code>StaticLoadObject</code> 的一层包装，只是转换参数，没做别的事</p><p><code>StaticLoadObject</code> 是 <code>StaticLoadObjectInternal</code> 的一层包装，检查了线程状态和返回值</p><p><code>StaticLoadObjectInternal</code> 决定了从哪里加载对象。</p><p>如果允许重用且名称完整，先尝试在内存中查找对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we have a full UObject name then attempt to find the object in memory first,</span></span><br><span class="line"><span class="keyword">if</span> (bAllowObjectReconciliation &amp;&amp; (bContainsObjectName</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_EDITOR</span></span><br><span class="line">|| GIsImportingT3D</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">))</span><br><span class="line">&#123;</span><br><span class="line">Result = <span class="built_in">StaticFindObjectFast</span>(ObjectClass, InOuter, *StrName);</span><br><span class="line"><span class="keyword">if</span> (Result &amp;&amp; Result-&gt;<span class="built_in">HasAnyFlags</span>(RF_NeedLoad | RF_NeedPostLoad | RF_NeedPostLoadSubobjects | RF_WillBeLoaded))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Object needs loading so load it before returning</span></span><br><span class="line">Result = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对象未找到且Outer所在包不是编译进来的，加载整个包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Result)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!InOuter-&gt;<span class="built_in">GetOutermost</span>()-&gt;<span class="built_in">HasAnyPackageFlags</span>(PKG_CompiledIn))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// now that we have one asset per package, we load the entire package whenever a single object is requested</span></span><br><span class="line"><span class="built_in">LoadPackage</span>(<span class="literal">NULL</span>, *InOuter-&gt;<span class="built_in">GetOutermost</span>()-&gt;<span class="built_in">GetName</span>(), LoadFlags &amp; ~LOAD_Verify, <span class="literal">nullptr</span>, InstancingContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包加载后再次查找对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// now, find the object in the package</span></span><br><span class="line">Result = <span class="built_in">StaticFindObjectFast</span>(ObjectClass, InOuter, *StrName);</span><br><span class="line"><span class="keyword">if</span> (GEventDrivenLoaderEnabled &amp;&amp; Result &amp;&amp; Result-&gt;<span class="built_in">HasAnyFlags</span>(RF_NeedLoad | RF_NeedPostLoad | RF_NeedPostLoadSubobjects | RF_WillBeLoaded))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogUObjectGlobals, Fatal, <span class="built_in">TEXT</span>(<span class="string">&quot;Return an object still needing load from StaticLoadObjectInternal %s&quot;</span>), *<span class="built_in">GetFullNameSafe</span>(Result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没找到对象，且允许重定向，尝试查找重定向器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the object was not found, check for a redirector and follow it if the class matches</span></span><br><span class="line"><span class="keyword">if</span> (!Result &amp;&amp; !(LoadFlags &amp; LOAD_NoRedirects))</span><br><span class="line">&#123;</span><br><span class="line">UObjectRedirector* Redirector = <span class="built_in">FindObjectFast</span>&lt;UObjectRedirector&gt;(InOuter, *StrName);</span><br><span class="line"><span class="keyword">if</span> (Redirector &amp;&amp; Redirector-&gt;DestinationObject &amp;&amp; Redirector-&gt;DestinationObject-&gt;<span class="built_in">IsA</span>(ObjectClass))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Redirector-&gt;DestinationObject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有找到对象，且名称不包含<code>.</code>，则假设对象是包内主资产，构造完整名称后递归调用自身加载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Result &amp;&amp; !bContainsObjectName)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Assume that the object we&#x27;re trying to load is the main asset inside of the package </span></span><br><span class="line"><span class="comment">// which usually has the same name as the short package name.</span></span><br><span class="line">StrName = InName;</span><br><span class="line">StrName += <span class="built_in">TEXT</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">StrName += FPackageName::<span class="built_in">GetShortName</span>(InName);</span><br><span class="line">Result = <span class="built_in">StaticLoadObjectInternal</span>(ObjectClass, InOuter, *StrName, Filename, LoadFlags, Sandbox, bAllowObjectReconciliation, InstancingContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LoadPackage">LoadPackage</h2><h3 id="挣扎于-LoadPackageInternal-的前半部分">挣扎于 LoadPackageInternal 的前半部分</h3><p><code>LoadPackage</code> 是 <code>LoadPackageInternal</code> 的包装，该包装添加了 debug 信息</p><p><code>LoadPackageInternal</code> 内部处理包装名参数 <code>InLongPackageNameOrFilename</code>，然后调用 <code>LoadPackageAsync</code> 去异步加载包</p><p><code>LoadPackageAsync</code> 是发起加载请求的包装。该包装获取 <code>IAsyncPackageLoader</code> 单例调用 <code>FAsyncLoadingThread::LoadPackage</code></p><p><code>FAsyncLoadingThread::LoadPackage</code> 把请求入队</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add new package request</span></span><br><span class="line"><span class="function">FAsyncPackageDesc <span class="title">PackageDesc</span><span class="params">(RequestID, *PackageName, *PackageNameToLoad, InGuid ? *InGuid : FGuid(), MoveTemp(CompletionDelegatePtr), InPackageFlags, InPIEInstanceID, InPackagePriority)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (InstancingContext)</span><br><span class="line">&#123;</span><br><span class="line">  PackageDesc.<span class="built_in">SetInstancingContext</span>(*InstancingContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">QueuePackage</span>(PackageDesc);</span><br></pre></td></tr></table></figure><p>入队的存储在 <code>QueuedPackages</code></p><p>通过查找引用可以看到 <code>FAsyncLoadingThread::CreateAsyncPackagesFromQueue</code> 处理了 <code>QueuedPackages</code></p><p><code>FAsyncLoadingThread::ProcessAsyncLoading</code> 被 <code>FAsyncLoadingThread::ProcessAsyncLoading</code> 和 <code>FAsyncLoadingThread::TickAsyncThread</code> 调用</p><p>对于我目前的调试，在 <code>FAsyncLoadingThread::ProcessAsyncLoading</code> 打断点，可以看到是 <code>FAsyncLoadingThread::TickAsyncThread</code> 调用了它</p><p>来源是 <code>LoadPackageInternal</code> 调用了一个 flush 方法，这个方法最终调用到 <code>FAsyncLoadingThread::FlushLoading</code>, 它调用到 <code>TickAsyncThread</code></p><p>那么继续看 <code>FAsyncLoadingThread::ProcessAsyncPackageRequest</code> 是怎么处理包加载的</p><p>先在AsyncPackageNameLookup（异步加载队列的包名查找表）中查找是否已有对应包。</p><p>如果找到，说明包已经在异步加载队列中，调用UpdateExistingPackagePriorities确保该包及其依赖包的优先级至少和当前请求的优先级一样高，避免优先级倒置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FAsyncPackage* Package = <span class="built_in">FindExistingPackageAndAddCompletionCallback</span>(InRequest, AsyncPackageNameLookup, FlushTree);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Package)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// The package is already sitting in the queue. Make sure the its priority, and the priority of all its</span></span><br><span class="line">  <span class="comment">// dependencies is at least as high as the priority of this request</span></span><br><span class="line">  <span class="built_in">UpdateExistingPackagePriorities</span>(Package, InRequest-&gt;Priority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果未找到，尝试在已加载包集合中查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Package)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// [BLOCKING] LoadedPackages are accessed on the main thread too, so lock to be able to add a completion callback</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> THREADSAFE_UOBJECTS</span></span><br><span class="line">  FScopeLock <span class="built_in">LoadedLock</span>(&amp;LoadedPackagesCritical);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  Package = <span class="built_in">FindExistingPackageAndAddCompletionCallback</span>(InRequest, LoadedPackagesNameLookup, FlushTree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果仍未找到，尝试在待处理加载包集合中查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Package)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// [BLOCKING] LoadedPackagesToProcess are modified on the main thread, so lock to be able to add a completion callback</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> THREADSAFE_UOBJECTS</span></span><br><span class="line">  <span class="function">FScopeLock <span class="title">LoadedLock</span><span class="params">(&amp;LoadedPackagesToProcessCritical)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  Package = <span class="built_in">FindExistingPackageAndAddCompletionCallback</span>(InRequest, LoadedPackagesToProcessNameLookup, FlushTree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果依然没找到，创建新包并加入队列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Package)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// New package that needs to be loaded or a package has already been loaded long time ago</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// GC can&#x27;t run in here</span></span><br><span class="line">    FGCScopeGuard GCGuard;</span><br><span class="line">    Package = <span class="keyword">new</span> <span class="built_in">FAsyncPackage</span>(*<span class="keyword">this</span>, *InRequest, EDLBootNotificationManager);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (InRequest-&gt;PackageLoadedDelegate.<span class="built_in">IsValid</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bInternalCallback = <span class="literal">false</span>;</span><br><span class="line">    Package-&gt;<span class="built_in">AddCompletionCallback</span>(<span class="built_in">MoveTemp</span>(InRequest-&gt;PackageLoadedDelegate), bInternalCallback);</span><br><span class="line">  &#125;</span><br><span class="line">  Package-&gt;<span class="built_in">SetDependencyRootPackage</span>(InRootPackage);</span><br><span class="line">  <span class="keyword">if</span> (FlushTree)</span><br><span class="line">  &#123;</span><br><span class="line">    Package-&gt;<span class="built_in">PopulateFlushTree</span>(FlushTree);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add to queue according to priority.</span></span><br><span class="line">  <span class="built_in">InsertPackage</span>(Package, <span class="literal">false</span>, EAsyncPackageInsertMode::InsertAfterMatchingPriorities);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For all other cases this is handled in FindExistingPackageAndAddCompletionCallback</span></span><br><span class="line">  <span class="type">const</span> int32 QueuedPackagesCount = QueuedPackagesCounter.<span class="built_in">Decrement</span>();</span><br><span class="line">  <span class="built_in">NotifyAsyncLoadingStateHasMaybeChanged</span>();</span><br><span class="line">  <span class="built_in">check</span>(QueuedPackagesCount &gt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑也只有一个 <code>InsertPackage</code> 把包插入到 <code>AsyncPackages</code> 了</p><p>我还是没有看到包是怎么被查找的</p><p>重新看 <code>LoadPackageInternal</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int32 RequestID = <span class="built_in">LoadPackageAsync</span>(InName, <span class="literal">nullptr</span>, *InPackageName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RequestID != INDEX_NONE)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">FlushAsyncLoading</span>(RequestID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Result = (InOuter ? InOuter : <span class="built_in">FindObjectFast</span>&lt;UPackage&gt;(<span class="literal">nullptr</span>, PackageFName));</span><br><span class="line"><span class="keyword">return</span> Result;</span><br></pre></td></tr></table></figure><p>他这里还是进入了 <code>FindObjectFast</code></p><p>fine，最终还是没有看到是怎么创建的</p><p>之后去看了一些别人的分析，我才发现，这个 <code>LoadPackage</code> 不负责加载资源</p><p>它更多是负责抽象出来资源包的状态管理？比如管理加载这个状态之类的？但是真正的加载函数，他也是调用别人的？</p><h3 id="为什么一直留在-LoadPackageInternal-前半部分">为什么一直留在 LoadPackageInternal 前半部分</h3><p>其实我前面一直困顿于这段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((FPlatformProperties::<span class="built_in">RequiresCookedData</span>() &amp;&amp; GEventDrivenLoaderEnabled</span><br><span class="line">&amp;&amp; EVENT_DRIVEN_ASYNC_LOAD_ACTIVE_AT_RUNTIME)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_IOSTORE_IN_EDITOR</span></span><br><span class="line">|| FIoDispatcher::<span class="built_in">IsInitialized</span>()</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">FString InName;</span><br><span class="line">FString InPackageName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FPackageName::<span class="built_in">IsPackageFilename</span>(InLongPackageNameOrFilename))</span><br><span class="line">&#123;</span><br><span class="line">FPackageName::<span class="built_in">TryConvertFilenameToLongPackageName</span>(InLongPackageNameOrFilename, InPackageName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">InPackageName = InLongPackageNameOrFilename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (InOuter)</span><br><span class="line">&#123;</span><br><span class="line">InName = InOuter-&gt;<span class="built_in">GetPathName</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">InName = InPackageName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FName <span class="title">PackageFName</span><span class="params">(*InPackageName)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_IOSTORE_IN_EDITOR</span></span><br><span class="line"><span class="comment">// Use the old loader if an uncooked package exists on disk</span></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bDoesUncookedPackageExist = FPackageName::<span class="built_in">DoesPackageExist</span>(InPackageName, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">true</span>) &amp;&amp; !<span class="built_in">DoesPackageExistInIoStore</span>(<span class="built_in">FName</span>(*InPackageName));</span><br><span class="line"><span class="keyword">if</span> (!bDoesUncookedPackageExist)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (FCoreDelegates::OnSyncLoadPackage.<span class="built_in">IsBound</span>())</span><br><span class="line">&#123;</span><br><span class="line">FCoreDelegates::OnSyncLoadPackage.<span class="built_in">Broadcast</span>(InName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int32 RequestID = <span class="built_in">LoadPackageAsync</span>(InName, <span class="literal">nullptr</span>, *InPackageName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RequestID != INDEX_NONE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">FlushAsyncLoading</span>(RequestID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Result = (InOuter ? InOuter : <span class="built_in">FindObjectFast</span>&lt;UPackage&gt;(<span class="literal">nullptr</span>, PackageFName));</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是因为，在我调试 standalone game 的时候，这个 if 一直为真</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((FPlatformProperties::<span class="built_in">RequiresCookedData</span>() &amp;&amp; GEventDrivenLoaderEnabled</span><br><span class="line">&amp;&amp; EVENT_DRIVEN_ASYNC_LOAD_ACTIVE_AT_RUNTIME)</span><br></pre></td></tr></table></figure><p><code>FPlatformProperties::RequiresCookedData()</code> 会为真，它是取 template 参数</p><p><img src="/images/ue4_load_pak_at_runtime/FPlatformProperties_RequiresCookedData.png" alt="alt text"></p><p><code>GEventDrivenLoaderEnabled</code> 等宏也是类似</p><p>我这里查找的 result 总是 null</p><p>在 <code>LoadPackageInternal</code> 开头打断点，正确挂载了 pak file 时，没有触发断点</p><p>尝试加载一个刚刚挂载的 pack pak 中的蓝图类型，一下子就找到了 package</p><p>看来，package 的更新都不是都走的 <code>LoadPackageInternal</code> 的流程</p><h3 id="LoadPackageInternal-的后面的部分">LoadPackageInternal 的后面的部分</h3><p>后面的部分就可以看到，核心是调用 <code>Linker-&gt;LoadAllObjects</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Linker = <span class="built_in">GetPackageLinker</span>(InOuter, *FileToLoad, LoadFlags, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, InReaderOverride, &amp;InOutLoadContext, ImportLinker, InstancingContext);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((LoadFlags &amp; DoNotLoadExportsFlags) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Linker-&gt;<span class="built_in">LoadAllObjects</span>(GEventDrivenLoaderEnabled);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetPackageLinker</code> 里面就是从 package 查找 linker，如果找不到，就创建 linker，并且把它关联到这个 package</p><p>所以是 package 拥有 linker</p><h3 id="FLinkerLoad-被创建之后立即-Tick-一次">FLinkerLoad 被创建之后立即 Tick 一次</h3><p>看别人博客说是，<code>LoadPackageIntenal()</code> 中会根据路径创建一个对应的 <code>FLinkerLoad</code>，它被创建完后会马上执行自身的 <code>Tick()</code></p><p>在哪里？</p><p>于是看到 <code>GetPackageLinker</code> -&gt; <code>FLinkerLoad::CreateLinker</code></p><p>这里确实是，先 <code>FLinkerLoad::CreateLinkerAsync</code> 再 <code>Linker-&gt;Tick</code></p><h2 id="FLinkerLoad">FLinkerLoad</h2><h3 id="导入导出表">导入导出表</h3><p><code>FLinkerLoad</code> 继承自 <code>FLinkerTables</code>，<code>FLinkerTables</code> 里面就有网上教程里面经常提到的 uasset 结构中的导入表导出表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FLinkerTables</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/** The list of FObjectImports found in the package */</span></span><br><span class="line">TArray&lt;FObjectImport&gt; ImportMap;</span><br><span class="line"><span class="comment">/** The list of FObjectExports found in the package */</span></span><br><span class="line">TArray&lt;FObjectExport&gt; ExportMap;</span><br><span class="line"><span class="comment">/** List of dependency lists for each export */</span></span><br><span class="line">TArray&lt;TArray&lt;FPackageIndex&gt; &gt; DependsMap;</span><br><span class="line"><span class="comment">/** List of packages that are soft referenced by this package */</span></span><br><span class="line">TArray&lt;FName&gt; SoftPackageReferenceList;</span><br><span class="line"><span class="comment">/** List of Searchable Names, by object containing them. Not in MultiMap to allow sorting, and sizes are usually small enough where TArray makes sense */</span></span><br><span class="line">TMap&lt;FPackageIndex, TArray&lt;FName&gt; &gt; SearchableNamesMap;</span><br></pre></td></tr></table></figure><h3 id="FLinkerLoad-Tick">FLinkerLoad::Tick</h3><p>因为是创建之后先调用一次 Tick 所以先看这个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ticks an in-flight linker and spends InTimeLimit seconds on creation. This is a soft time limit used</span></span><br><span class="line"><span class="comment"> * if bInUseTimeLimit is true.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @paramInTimeLimitSoft time limit to use if bInUseTimeLimit is true</span></span><br><span class="line"><span class="comment"> * @parambInUseTimeLimitWhether to use a (soft) timelimit</span></span><br><span class="line"><span class="comment"> * @parambInUseFullTimeLimitWhether to use the entire time limit, even if blocked on I/O</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @returntrue if linker has finished creation, false if it is still in flight</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">FLinkerLoad::ELinkerStatus <span class="title">FLinkerLoad::Tick</span><span class="params">( <span class="type">float</span> InTimeLimit, <span class="type">bool</span> bInUseTimeLimit, <span class="type">bool</span> bInUseFullTimeLimit, TMap&lt;TPair&lt;FName, FPackageIndex&gt;, FPackageIndex&gt;* ObjectNameWithOuterToExportMap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ELinkerStatus Status = LINKER_Loaded;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( bHasFinishedInitialization == <span class="literal">false</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Store variables used by functions below.</span></span><br><span class="line">TickStartTime= FPlatformTime::<span class="built_in">Seconds</span>();</span><br><span class="line">bTimeLimitExceeded= <span class="literal">false</span>;</span><br><span class="line">bUseTimeLimit= bInUseTimeLimit;</span><br><span class="line">bUseFullTimeLimit= bInUseFullTimeLimit;</span><br><span class="line">TimeLimit= InTimeLimit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> bCanSerializePackageFileSummary = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (GEventDrivenLoaderEnabled)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">check</span>(Loader || bDynamicClassLinker);</span><br><span class="line">bCanSerializePackageFileSummary = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Create loader, aka FArchive used for serialization and also precache the package file summary.</span></span><br><span class="line"><span class="comment">// false is returned until any precaching is complete.</span></span><br><span class="line"><span class="built_in">SCOPED_LOADTIMER</span>(LinkerLoad_CreateLoader);</span><br><span class="line">Status = <span class="built_in">CreateLoader</span>(<span class="built_in">TFunction</span>&lt;<span class="built_in">void</span>()&gt;([]() &#123;&#125;));</span><br><span class="line"></span><br><span class="line">bCanSerializePackageFileSummary = (Status == LINKER_Loaded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serialize the package file summary and presize the various arrays (name, import &amp; export map)</span></span><br><span class="line"><span class="keyword">if</span> (bCanSerializePackageFileSummary)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SCOPED_LOADTIMER</span>(LinkerLoad_SerializePackageFileSummary);</span><br><span class="line">Status = <span class="built_in">SerializePackageFileSummary</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serialize the name map and register the names.</span></span><br><span class="line"><span class="keyword">if</span>( Status == LINKER_Loaded )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SCOPED_LOADTIMER</span>(LinkerLoad_SerializeNameMap);</span><br><span class="line">Status = <span class="built_in">SerializeNameMap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serialize the gatherable text data map.</span></span><br><span class="line"><span class="keyword">if</span>( Status == LINKER_Loaded )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SCOPED_LOADTIMER</span>(LinkerLoad_SerializeGatherableTextDataMap);</span><br><span class="line">Status = <span class="built_in">SerializeGatherableTextDataMap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serialize the import map.</span></span><br><span class="line"><span class="keyword">if</span>( Status == LINKER_Loaded )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SCOPED_LOADTIMER</span>(LinkerLoad_SerializeImportMap);</span><br><span class="line">Status = <span class="built_in">SerializeImportMap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serialize the export map.</span></span><br><span class="line"><span class="keyword">if</span>( Status == LINKER_Loaded )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SCOPED_LOADTIMER</span>(LinkerLoad_SerializeExportMap);</span><br><span class="line">Status = <span class="built_in">SerializeExportMap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_TEXT_ARCHIVE_SUPPORT</span></span><br><span class="line"><span class="comment">// Reconstruct the import and export maps for text assets</span></span><br><span class="line"><span class="keyword">if</span> (Status == LINKER_Loaded)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SCOPED_LOADTIMER</span>(LinkerLoad_ReconstructImportAndExportMap);</span><br><span class="line">Status = <span class="built_in">ReconstructImportAndExportMap</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fix up import map for backward compatible serialization.</span></span><br><span class="line"><span class="keyword">if</span>( Status == LINKER_Loaded )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SCOPED_LOADTIMER</span>(LinkerLoad_FixupImportMap);</span><br><span class="line">Status = <span class="built_in">FixupImportMap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Populate the linker instancing context for instance loading if needed.</span></span><br><span class="line"><span class="keyword">if</span> (Status == LINKER_Loaded)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SCOPED_LOADTIMER</span>(LinkerLoad_PopulateInstancingContext);</span><br><span class="line">Status = <span class="built_in">PopulateInstancingContext</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fix up export map for object class conversion </span></span><br><span class="line"><span class="keyword">if</span>( Status == LINKER_Loaded )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SCOPED_LOADTIMER</span>(LinkerLoad_FixupExportMap);</span><br><span class="line">Status = <span class="built_in">FixupExportMap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serialize the dependency map.</span></span><br><span class="line"><span class="keyword">if</span>( Status == LINKER_Loaded )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SCOPED_LOADTIMER</span>(LinkerLoad_SerializeDependsMap);</span><br><span class="line">Status = <span class="built_in">SerializeDependsMap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hash exports.</span></span><br><span class="line"><span class="keyword">if</span>( Status == LINKER_Loaded )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SCOPED_LOADTIMER</span>(LinkerLoad_CreateExportHash);</span><br><span class="line">Status = <span class="built_in">CreateExportHash</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find existing objects matching exports and associate them with this linker.</span></span><br><span class="line"><span class="keyword">if</span>( Status == LINKER_Loaded )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SCOPED_LOADTIMER</span>(LinkerLoad_FindExistingExports);</span><br><span class="line">Status = <span class="built_in">FindExistingExports</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Status == LINKER_Loaded)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SCOPED_LOADTIMER</span>(LinkerLoad_SerializePreloadDependencies);</span><br><span class="line">Status = <span class="built_in">SerializePreloadDependencies</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finalize creation process.</span></span><br><span class="line"><span class="keyword">if</span>( Status == LINKER_Loaded )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SCOPED_LOADTIMER</span>(LinkerLoad_FinalizeCreation);</span><br><span class="line">Status = <span class="built_in">FinalizeCreation</span>(ObjectNameWithOuterToExportMap);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Loop till we are done if no time limit is specified, or loop until the real time limit is up if we want to use full time</span></span><br><span class="line"><span class="keyword">while</span> (Status == LINKER_TimedOut &amp;&amp; </span><br><span class="line">(!bUseTimeLimit || (bUseFullTimeLimit &amp;&amp; !<span class="built_in">IsTimeLimitExceeded</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Checking Full Timer&quot;</span>))))</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Status == LINKER_Failed)</span><br><span class="line">&#123;</span><br><span class="line">LinkerRoot-&gt;LinkerLoad = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_EDITOR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (LoadProgressScope)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> LoadProgressScope;</span><br><span class="line">LoadProgressScope = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return whether we completed or not.</span></span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个看得就很爽，每一步要做什么都很清楚</p><h3 id="FLinkerLoad-LoadAllObjects">FLinkerLoad::LoadAllObjects</h3><p>于是看到 <code>FLinkerLoad::LoadAllObjects</code> 预期这里是实现了怎么从磁盘加载内容到内存中</p><p>他的核心部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UObject* LoadedObject = <span class="built_in">CreateExportAndPreload</span>(ExportIndex, bForcePreload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!GEventDrivenLoaderEnabled || !EVENT_DRIVEN_ASYNC_LOAD_ACTIVE_AT_RUNTIME)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// DynamicClass could be created without calling CreateImport. The imported objects will be required later when a CDO is created.</span></span><br><span class="line"><span class="keyword">if</span> (UDynamicClass* DynamicClass = <span class="built_in">Cast</span>&lt;UDynamicClass&gt;(LoadedObject))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (int32 ImportIndex = <span class="number">0</span>; ImportIndex &lt; ImportMap.<span class="built_in">Num</span>(); ++ImportIndex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CreateImport</span>(ImportIndex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就很短，但是这里居然没有一个函数名明显地写从磁盘加载</p><p>于是还是要挨个函数看</p><h3 id="FLinkerLoad-CreateExportAndPreload">FLinkerLoad::CreateExportAndPreload</h3><p>也很短</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UObject* <span class="title">FLinkerLoad::CreateExportAndPreload</span><span class="params">(int32 ExportIndex, <span class="type">bool</span> bForcePreload <span class="comment">/* = false */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UObject *Object = <span class="built_in">CreateExport</span>(ExportIndex);</span><br><span class="line"><span class="keyword">if</span> (Object &amp;&amp; (bForcePreload || <span class="built_in">dynamic_cast</span>&lt;UClass*&gt;(Object) || Object-&gt;<span class="built_in">IsTemplate</span>() || <span class="built_in">dynamic_cast</span>&lt;UObjectRedirector*&gt;(Object)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Preload</span>(Object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一印象是首先创建导出表，然后 load 一些东西</p><p>于是进来看到 <code>FLinkerLoad::Preload</code></p><h3 id="FLinkerLoad-Preload">FLinkerLoad::Preload</h3><p>前面一些检查就不说了</p><p>定位并读取对象数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int32 <span class="type">const</span> ExportIndex = Object-&gt;<span class="built_in">GetLinkerIndex</span>();</span><br><span class="line">FObjectExport&amp; Export = ExportMap[ExportIndex];</span><br><span class="line"><span class="built_in">check</span>(Export.Object==Object);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> int64 SavedPos = Loader-&gt;<span class="built_in">Tell</span>();</span><br><span class="line"><span class="built_in">Seek</span>(Export.SerialOffset);</span><br></pre></td></tr></table></figure><p>这部分的内容是</p><p>获取对象在导出表中的索引和导出信息</p><p>保存当前文件读取位置</p><p>定位到对象数据在文件中的偏移</p><p>然后有一些预缓存数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FAsyncArchive* AsyncLoader = <span class="built_in">GetAsyncLoader</span>();</span><br><span class="line"><span class="keyword">if</span> (AsyncLoader)</span><br><span class="line">&#123;</span><br><span class="line">    AsyncLoader-&gt;<span class="built_in">PrecacheWithTimeLimit</span>(...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Loader-&gt;<span class="built_in">Precache</span>(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂时不知道是干什么的</p><p>然后应该就是反序列化对象数据的部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Object-&gt;<span class="built_in">HasAnyFlags</span>(RF_ClassDefaultObject))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Maintain the current SerializedObjects.</span></span><br><span class="line">UObject* PrevSerializedObject = CurrentLoadContext-&gt;SerializedObject;</span><br><span class="line">CurrentLoadContext-&gt;SerializedObject = Object;</span><br><span class="line">Object-&gt;<span class="built_in">GetClass</span>()-&gt;<span class="built_in">SerializeDefaultObject</span>(Object, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Maintain the current SerializedObjects.</span></span><br><span class="line">UObject* PrevSerializedObject = CurrentLoadContext-&gt;SerializedObject;</span><br><span class="line">CurrentLoadContext-&gt;SerializedObject = Object;</span><br><span class="line">Object-&gt;<span class="built_in">Serialize</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中还区分了是否是 CDO</p><p>这里还涉及到递归调用 Preload，也就是递归加载</p><p>涉及到通过延迟加载来解决循环依赖的问题，就不看了</p><p>总之，这里最终调用到 <code>UObject::Serialize</code></p><h2 id="UObject-Serialize">UObject::Serialize</h2><p>各个博客已经讲得很清楚，<code>UObject::Serialize</code> 实现了访问者模式</p><p>也就是它只调用一个算子，各个访问者重载这个算子，就可以实现不同的访问者有不同的逻辑</p><p>这里应该是，输入 FLinkerLoad 就是读取 uasset（磁盘）到内存，输入 FLinkerSave 就是从内存保存到 uasset（磁盘）</p><p>该函数内部最主要的就是调用了 <code>UObject::SerializeScriptProperties</code>，其他的逻辑比如确保预加载，事务（Undo/Redo）支持等，就不看了</p><p>于是看 <code>UObject::SerializeScriptProperties</code></p><h2 id="回顾">回顾</h2><p>看到别人对相关代码的反序列化分析</p><p><a href="https://zhuanlan.zhihu.com/p/96870468">深入理解UE4：反序列化流程详细分析</a></p><p>我之后也不想自己看实际 <code>FMemory::Memcpy</code> 读数据的部分了，就看这篇文章大概了解，在 <code>FArchiveFileReaderGeneric::Serialize</code></p><p>因为感觉到这里，已经和 pak 加载相隔很远了</p><p>而且其实我前面看代码，虽然大概看了每个函数都在干什么，但是不是很懂整体关系</p><p>看了这个文章，大概知道，回顾 <code>FLinkerLoad::LoadAllObjects</code> 他的核心部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UObject* LoadedObject = <span class="built_in">CreateExportAndPreload</span>(ExportIndex, bForcePreload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!GEventDrivenLoaderEnabled || !EVENT_DRIVEN_ASYNC_LOAD_ACTIVE_AT_RUNTIME)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// DynamicClass could be created without calling CreateImport. The imported objects will be required later when a CDO is created.</span></span><br><span class="line"><span class="keyword">if</span> (UDynamicClass* DynamicClass = <span class="built_in">Cast</span>&lt;UDynamicClass&gt;(LoadedObject))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (int32 ImportIndex = <span class="number">0</span>; ImportIndex &lt; ImportMap.<span class="built_in">Num</span>(); ++ImportIndex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CreateImport</span>(ImportIndex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先创建 export 对象，为 export 对象预先加载一些值，这个时候所有的 export 对象就是摸具就创建完了</p><p>这个时候再遍历模具，对每一个模具 import，就完成了对象最终的加载</p><p>我大概的概念是这样，但是我还是不知道 pak 加载之后对象是怎么被加载的</p><h2 id="先尝试-ReloadPackages">先尝试 ReloadPackages</h2><p>我一开始看的是</p><p>Engine/Source/Editor/UnrealEd/Private/PackageTools.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UPackageTools::ReloadPackages</span><span class="params">( <span class="type">const</span> TArray&lt;UPackage*&gt;&amp; TopLevelPackages, FText&amp; OutErrorMessage, <span class="type">const</span> EReloadPackagesInteractionMode InteractionMode )</span></span></span><br></pre></td></tr></table></figure><p>一开始只是想不求甚解直接用，但是发现它是 UnrealEd 模块，不可以编译到非 Editor 的模块中</p><p>于是仔细看他的函数，发现他也只是把传入的 package 列表放在一起，然后把 in memory 的 package 挑出来不重载</p><p>然后再判断要处理的包是否在当前世界中，如果在的话，当前世界就要先卸载，等包 reload 之后，世界再重新加载</p><p>之后就是具体处理 package reload 的逻辑</p><p>Engine/Source/Runtime/CoreUObject/Private/UObject/PackageReload.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReloadPackages</span><span class="params">(<span class="type">const</span> TArrayView&lt;FReloadPackageData&gt;&amp; InPackagesToReload, TArray&lt;UPackage*&gt;&amp; OutReloadedPackages, int32 InNumPackagesPerBatch)</span></span></span><br></pre></td></tr></table></figure><p>这个函数在 CoreUObject 模块，所以还是可以在游戏中使用的！</p><p>这里面只传入了一个 package 对象，但是代码里面是明显有新旧包的概念</p><p>要被替换的旧包被 <code>PackageReloadInternal::ValidateAndPreparePackageForReload</code> 处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> FReloadPackageData&amp; PackageToReloadData : InPackagesToReload)</span><br><span class="line">&#123;</span><br><span class="line">PreparingPackagesForReloadSlowTask.<span class="built_in">EnterProgressFrame</span>(<span class="number">1.0f</span>);</span><br><span class="line">ExistingPackages.Refs.<span class="built_in">Emplace</span>(PackageReloadInternal::<span class="built_in">ValidateAndPreparePackageForReload</span>(PackageToReloadData.PackageToReload));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先对 package 做 validation：如果这个 package 是 in memory only 的，也就是仅存在内存中的，那么就没有从磁盘重新加载这一说了</p><p>然后把 package 的 <code>FLinkerLoad</code> 成员重置，相当于断开了这个 package 和旧的磁盘数据之间的桥梁</p><p>新包概念出现的位置在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PackageReloadInternal::FNewPackageReferences NewPackages;</span><br><span class="line">NewPackages.Refs.<span class="built_in">Reserve</span>(ExistingPackages.Refs.<span class="built_in">Num</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; PackageIndex &lt; ExistingPackages.Refs.<span class="built_in">Num</span>(); ++PackageIndex)</span><br><span class="line">&#123;</span><br><span class="line">    UPackage* ExistingPackage = ExistingPackages.Refs[PackageIndex].RawRef;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    NewPackages.Refs.<span class="built_in">Emplace</span>(PackageReloadInternal::<span class="built_in">LoadReplacementPackage</span>(ExistingPackage, InPackagesToReload[PackageIndex].LoadFlags));</span><br><span class="line"></span><br><span class="line">    UPackage* NewPackage = NewPackages.Refs[PackageIndex].Package;</span><br><span class="line">    NewPackages.Refs[PackageIndex].EventData = PackageReloadInternal::<span class="built_in">GeneratePackageReloadEvent</span>(ExistingPackage, NewPackage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PackageReloadInternal::LoadReplacementPackage</code> 里面涉及到替换的逻辑，主要是两个</p><p>一个是把旧包重命名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ERenameFlags PkgRenameFlags = REN_ForceNoResetLoaders | REN_DoNotDirty | REN_DontCreateRedirectors | REN_NonTransactional | REN_SkipGeneratedClasses;</span><br><span class="line">InExistingPackage-&gt;<span class="built_in">Rename</span>(</span><br><span class="line">    *<span class="built_in">MakeUniqueObjectName</span>(</span><br><span class="line">        <span class="built_in">Cast</span>&lt;UPackage&gt;(InExistingPackage-&gt;<span class="built_in">GetOuter</span>()), </span><br><span class="line">        UPackage::<span class="built_in">StaticClass</span>(), </span><br><span class="line">        *FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%s_DEADPACKAGE&quot;</span>), *InExistingPackage-&gt;<span class="built_in">GetName</span>())</span><br><span class="line">    ).<span class="built_in">ToString</span>(), </span><br><span class="line">    <span class="literal">nullptr</span>, </span><br><span class="line">    PkgRenameFlags</span><br><span class="line">);</span><br><span class="line"><span class="built_in">MarkPackageReplaced</span>(InExistingPackage);</span><br></pre></td></tr></table></figure><p>一个是加载新包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPackage* NewPackage = <span class="built_in">LoadPackage</span>(<span class="built_in">Cast</span>&lt;UPackage&gt;(InExistingPackage-&gt;<span class="built_in">GetOuter</span>()), *ExistingPackageName, InLoadFlags);</span><br></pre></td></tr></table></figure><p>此外还有逻辑来处理加载新包时的失败逻辑，这里就不看了</p><p>重新反序列化对象的逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main pass to go through and fix-up any references pointing to data from the old package to point to data from the new package</span></span><br><span class="line"><span class="comment">// todo: multi-thread this like FHotReloadModule::ReplaceReferencesToReconstructedCDOs?</span></span><br><span class="line"><span class="keyword">for</span> (FThreadSafeObjectIterator <span class="built_in">ObjIter</span>(UObject::<span class="built_in">StaticClass</span>(), <span class="literal">false</span>, RF_NoFlags, EInternalObjectFlags::PendingKill); ObjIter; ++ObjIter)</span><br><span class="line">&#123;</span><br><span class="line">UObject* PotentialReferencer = *ObjIter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mutating the old versions of classes can result in us replacing the SuperStruct pointer, which results</span></span><br><span class="line"><span class="comment">// in class layout change and subsequently crashes because instances will not match this new class layout:</span></span><br><span class="line">UClass* AsClass = <span class="built_in">Cast</span>&lt;UClass&gt;(PotentialReferencer);</span><br><span class="line"><span class="keyword">if</span> (!AsClass)</span><br><span class="line">&#123;</span><br><span class="line">AsClass = PotentialReferencer-&gt;<span class="built_in">GetTypedOuter</span>&lt;UClass&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(AsClass)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( AsClass-&gt;<span class="built_in">HasAnyClassFlags</span>(CLASS_NewerVersionExists) || </span><br><span class="line">AsClass-&gt;<span class="built_in">HasAnyFlags</span>(RF_NewerVersionExists))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PackageReloadInternal::FReplaceObjectReferencesArchive <span class="title">ReplaceRefsArchive</span><span class="params">(PotentialReferencer, OldObjectToNewData, ExistingPackages.Refs, NewPackages.Refs)</span></span>;</span><br><span class="line">PotentialReferencer-&gt;<span class="built_in">Serialize</span>(ReplaceRefsArchive); <span class="comment">// Deal with direct references during Serialization</span></span><br><span class="line">PotentialReferencer-&gt;<span class="built_in">GetClass</span>()-&gt;<span class="built_in">CallAddReferencedObjects</span>(PotentialReferencer, ReplaceRefsArchive); <span class="comment">// Deal with indirect references via AddReferencedObjects</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是遍历所有的 UObject</p><p>这个迭代器是构造的时候指向一个全局变量，它是一个存储了 UObject 的数组（内部实现还是有一些说法的，但是这里先跳过）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Engine/Source/Runtime/CoreUObject/Private/UObject/UObjectHash.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Global UObject array instance</span></span><br><span class="line">FUObjectArray GUObjectArray;</span><br></pre></td></tr></table></figure><p>首先判断对象所属的类是否标记为“有新版本存在”（CLASS_NewerVersionExists或RF_NewerVersionExists）。</p><p>这类对象通常是热重载或重新构建的类的旧版本实例，跳过它们避免因类布局变化导致崩溃。</p><p>之后的逻辑就是对于当前遍历到的 UObject 替换引用，然后反序列化</p><p>试用了一下，简直完美！直接就成功了！</p><h2 id="运行时替换纹理导致的偶发性问题">运行时替换纹理导致的偶发性问题</h2><p>这是一个偶发性的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FRHIResource::Release() RHIResources.h:54</span><br><span class="line">TArray::~TArray&lt;…&gt;() Array.h:621</span><br><span class="line">FD3D11UniformBuffer::~FD3D11UniformBuffer() D3D11UniformBuffer.cpp:381</span><br><span class="line">&lt;lambda_84e30748...&gt;::operator()(TArray&lt;…&gt; &amp;) RHI.cpp:599</span><br><span class="line">FRHIResource::FlushPendingDeletes(bool) RHI.cpp:629</span><br><span class="line">FlushPendingDeleteRHIResources_RenderThread() RenderingThread.cpp:1303</span><br><span class="line">&lt;lambda_83aa676a...&gt;::operator()(FRHICommandListImmediate &amp;) SceneRendering.cpp:4008</span><br><span class="line">TEnqueueUniqueRenderCommandType&lt;`FRendererModule::BeginRenderingViewFamily&#x27;::`43&#x27;::FDrawSceneCommandName,&lt;lambda_83aa676af25f62e876425d334fdfc6e4&gt; &gt;::DoTask(Type,const TRefCountPtr&lt;FGraphEvent&gt; &amp;) RenderingThread.h:183</span><br><span class="line">TGraphTask&lt;TEnqueueUniqueRenderCommandType&lt;`FRendererModule::BeginRenderingViewFamily&#x27;::`43&#x27;::FDrawSceneCommandName,&lt;lambda_83aa676af25f62e876425d334fdfc6e4&gt; &gt; &gt;::ExecuteTask(TArray&lt;FBaseGraphTask *,TSizedDefaultAllocator&lt;32&gt; &gt; &amp;,Type) TaskGraphInterfaces.h:886</span><br><span class="line">FNamedTaskThread::ProcessTasksNamedThread(int, bool) TaskGraph.cpp:710</span><br><span class="line">FNamedTaskThread::ProcessTasksUntilQuit(int) TaskGraph.cpp:601</span><br><span class="line">FTaskGraphImplementation::ProcessThreadUntilRequestReturn(Type) TaskGraph.cpp:1480</span><br><span class="line">RenderingThreadMain(FEvent *) RenderingThread.cpp:372</span><br><span class="line">FRenderingThread::Run() RenderingThread.cpp:526</span><br><span class="line">FRunnableThreadWin::Run() WindowsRunnableThread.cpp:84</span><br><span class="line">FRunnableThreadWin::GuardedRun() WindowsRunnableThread.cpp:27</span><br><span class="line">FRunnableThreadWin::_ThreadProc(void *) WindowsRunnableThread.h:37</span><br></pre></td></tr></table></figure><p>这段报错的原因是，在 <code>FD3D11UniformBuffer</code> 中，有一个存储资源的 table</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Resource table containing RHI references. */</span></span><br><span class="line">TArray&lt;TRefCountPtr&lt;FRHIResource&gt; &gt; ResourceTable;</span><br></pre></td></tr></table></figure><p>在 <code>FD3D11UniformBuffer</code> 销毁时，这个 TArray 也一起销毁</p><p>TArray 析构时，对每一个成员先调用析构</p><p>在这里，一个 <code>TRefCountPtr&lt;FRHIResource&gt;</code> 已经是野指针了</p><p>这个是 delete 队列里面去调用 <code>FD3D11UniformBuffer</code> 的析构的，于是还是要看谁发起了这个析构 <code>FD3D11UniformBuffer</code></p><p>因为看到 release 方法是把 RHI 资源放入删除队列中，并且 <code>class FD3D11UniformBuffer : public FRHIUniformBuffer</code>, <code>class FRHIUniformBuffer : public FRHIResource</code> 所以应该是有人调用了 <code>FRHIUniformBuffer</code> 的 <code>Release()</code></p><p>我在 <code>FRHIUniformBuffer::Release</code> 这里加上 Log，这个 <code>FRHIUniformBuffer::Release()</code> 调用非常频繁，有来自 <code>FRHICommandSetShaderUniformBuffer</code>, <code>FRHICommandSetGraphicsPipelineState</code></p><p>但是我还是不知道 <code>ResourceTable</code> 的成员为什么变成野指针了，所以我还不知道这个问题怎么解决</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Unreal Engine 4 </tag>
            
            <tag> Package </tag>
            
            <tag> PAK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4.27.2 UnrealPAK Repack 功能分析</title>
      <link href="/2025/05/13/2025-05-13-ue4_UnrealPAK_repack/"/>
      <url>/2025/05/13/2025-05-13-ue4_UnrealPAK_repack/</url>
      
        <content type="html"><![CDATA[<p>从入口进来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Engine/Source/Developer/PakFileUtilities/Private/PakFileUtilities.cpp: </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ExecuteUnrealPak</span><span class="params">(<span class="type">const</span> TCHAR* CmdLine)</span></span></span><br></pre></td></tr></table></figure><p>进到 Repack 选项这个 if else</p><p>这里可以读取相同文件名后缀所有 pak 文件，输出的 pak 文件一一对应</p><p>然后可以配置 ExcludeDeleted 选项，是否跳过输入的 pak 文件中被删除的内容，这个很有意思</p><p>然后就是具体的重新打包的逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Engine/Source/Developer/PakFileUtilities/Private/PakFileUtilities.cpp: </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Repack</span><span class="params">(<span class="type">const</span> FString&amp; InputPakFile, <span class="type">const</span> FString&amp; OutputPakFile, <span class="type">const</span> FPakCommandLineParameters&amp; CmdLineParameters, <span class="type">const</span> FKeyChain&amp; InKeyChain, <span class="type">bool</span> bIncludeDeleted)</span></span></span><br></pre></td></tr></table></figure><p>这里一开始就是剔除掉删除的文件的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">ExtractFilesFromPak</span>(*InputPakFile, Hashes, *TempDir, <span class="literal">false</span>, InKeyChain, <span class="literal">nullptr</span>, &amp;Entries, &amp;DeletedEntries, &amp;OrderMap, &amp;EncryptionKeys, &amp;bAnySigned))</span><br><span class="line">&#123;</span><br><span class="line">  TArray&lt;FPakInputPair&gt; FilesToAdd;</span><br><span class="line">  <span class="built_in">CollectFilesToAdd</span>(FilesToAdd, Entries, OrderMap, CmdLineParameters);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bIncludeDeleted)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">const</span> FPakInputPair&amp; Entry : DeletedEntries )</span><br><span class="line">    &#123;</span><br><span class="line">      FilesToAdd.<span class="built_in">Add</span>(Entry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (DeletedEntries.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">UE_LOG</span>(LogPakFile, Display, <span class="built_in">TEXT</span>(<span class="string">&quot;%s has %d delete records - these will not be included in the repackage. Specify -IncludeDeleted to include them&quot;</span>), *InputPakFile, DeletedEntries.<span class="built_in">Num</span>() );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>具体进到 <code>ExtractFilesFromPak</code> 里面是可以看到，如果传入的 <code>OutDeletedEntries</code> 不是 null，那么也会把源 PAK 中 tag 被标记为 deleted 的文件给解压出来</p><p>之后就是重新压缩的事了</p><p>其实比较简单，但是就是需要走他自己的一些特殊处理的流程</p><p>本来我想修改这个函数来实现自己的目的，但是这是一个私有文件</p><p>如果要把函数暴露出来，就要改源码</p><p>如果是一些非得改不可的功能，那公开了也行</p><p>但是仔细考虑的话，其实我从 cpp 调用 command 也不是不能接受</p><p>因为已经看过了 cpp 的 repack 实现，跟我自己通过 command 解压再压缩是一样的</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Unreal Engine 4 </tag>
            
            <tag> Package </tag>
            
            <tag> PAK </tag>
            
            <tag> Repack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4.27.2 转换虚拟资产路径到实际资产路径</title>
      <link href="/2025/05/13/2025-05-13-ue4_find_asset_file_path/"/>
      <url>/2025/05/13/2025-05-13-ue4_find_asset_file_path/</url>
      
        <content type="html"><![CDATA[<p>通过 <code>FAssetData.PackageName</code> 可以知道资产不带扩展名的虚拟路径</p><p>有的时候想要知道它对应磁盘上的实际资产绝对路径</p><p>Engine/Source/Runtime/CoreUObject/Private/Misc/PackageName.cpp 的 <code>FLongPackagePathsSingleton</code> 存储了虚拟路径根目录到实际路径根目录绝对路径的转化</p><p>这个映射关系存成 pair，需要转化的时候，遍历这个 pair 来对比，找到了就替换，然后返回替换后的路径</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FPackageName::TryConvertLongPackageNameToFilename</span><span class="params">(<span class="type">const</span> FString&amp; InLongPackageName, FString&amp; OutFilename, <span class="type">const</span> FString&amp; InExtension)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; Paths = FLongPackagePathsSingleton::<span class="built_in">Get</span>();</span><br><span class="line"><span class="function">FReadScopeLock <span class="title">ScopeLock</span><span class="params">(ContentMountPointCriticalSection)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; Pair : Paths.ContentRootToPath)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (InLongPackageName.<span class="built_in">StartsWith</span>(Pair.RootPath))</span><br><span class="line">&#123;</span><br><span class="line">OutFilename = Pair.ContentPath + InLongPackageName.<span class="built_in">Mid</span>(Pair.RootPath.<span class="built_in">Len</span>()) + InExtension;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is not a long package name or the root folder is not handled in the above cases</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终这个方法被封装成 <code>FPackageName::LongPackageNameToFilename</code></p><p>至于后缀所有的可能，已经在 Engine/Source/Runtime/CoreUObject/Private/Misc/PackageName.cpp 给出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FString FPackageName::AssetPackageExtension = <span class="built_in">TEXT</span>(<span class="string">&quot;.uasset&quot;</span>);</span><br><span class="line">FString FPackageName::MapPackageExtension = <span class="built_in">TEXT</span>(<span class="string">&quot;.umap&quot;</span>);</span><br><span class="line">FString FPackageName::TextAssetPackageExtension = <span class="built_in">TEXT</span>(<span class="string">&quot;.utxt&quot;</span>);</span><br><span class="line">FString FPackageName::TextMapPackageExtension = <span class="built_in">TEXT</span>(<span class="string">&quot;.utxtmap&quot;</span>);</span><br></pre></td></tr></table></figure><p>FPackageName 对它们有一层 getter 的封装</p><p>知道了这些，给定任意一个资产，就可以知道它不带后缀的路径</p><p>给定任意一个资产，怎么知道他对应的后缀是什么呢？</p><p>感觉这就需要客户端自己安排了</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Unreal Engine 4 </tag>
            
            <tag> Asset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4.27.2 构建项目放在 SolutionDirectory</title>
      <link href="/2025/05/12/2025-05-12-ue4_build_target_is_in_SolutionDirectory/"/>
      <url>/2025/05/12/2025-05-12-ue4_build_target_is_in_SolutionDirectory/</url>
      
        <content type="html"><![CDATA[<h2 id="UnrealPakViewer">UnrealPakViewer</h2><p>我是希望构建别人的一个查看 pak 的工具，来学习 PAK 的使用的</p><p><a href="https://github.com/jashking/UnrealPakViewer">https://github.com/jashking/UnrealPakViewer</a></p><p>根据他的介绍，把他源码放到 Engine\Source\Programs 就可以了</p><p>我虽然放了，但是运行 <code>GenerateProjectFiles.bat</code>，重新编译之后没有出现 UnrealPakViewer 的项目</p><p>刚好看过 UE 构建系统，于是想找下问题在哪</p><h2 id="调试-UnrealBuildTool-生成项目">调试 UnrealBuildTool 生成项目</h2><p>调试到 <code>ProjectFileGenerator.AddProjectsForAllTargets</code></p><p>这个函数开头遍历 <code>AllTargetFiles</code></p><p>每一个 Target 判断是否在特定目录下，在才执行之后的逻辑</p><p>这个判断的结果存在 <code>WantProjectFileForTarget</code>，我调试的时候，UnrealPakViewer 也是通过了的</p><p>于是之后一堆生成项目的逻辑，假设暂时跳过</p><p>最后调试到生成项目的代码都是可以击中的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ProjectTarget ProjectTarget = <span class="keyword">new</span> <span class="built_in">ProjectTarget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    TargetRules = TargetRulesObject,</span><br><span class="line">    TargetFilePath = TargetFilePath,</span><br><span class="line">    ProjectFilePath = ProjectFilePath,</span><br><span class="line">    UnrealProjectFilePath = CheckProjectFile,</span><br><span class="line">    SupportedPlatforms = TargetRulesObject.<span class="built_in">GetSupportedPlatforms</span>().<span class="built_in">Where</span>(</span><br><span class="line">                            x =&gt; UEBuildPlatform.<span class="built_in">GetBuildPlatform</span>(x, <span class="literal">true</span>) != null &amp;&amp; </span><br><span class="line">                            (TargetRulesObject.LinkType != TargetLinkType.Modular || !UEBuildPlatform.<span class="built_in">PlatformRequiresMonolithicBuilds</span>(x, TargetRulesObject.Configuration))</span><br><span class="line">                            ).<span class="built_in">ToArray</span>(),</span><br><span class="line">    CreateRulesDelegate = (Platform, Configuration) =&gt; RulesAssembly.<span class="built_in">CreateTargetRules</span>(TargetName, Platform, Configuration, <span class="string">&quot;&quot;</span>, CheckProjectFile, <span class="keyword">new</span> <span class="built_in">CommandLineArguments</span>(<span class="built_in">GetTargetArguments</span>(Arguments)))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里给出了生成的路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path to engine&gt;\UnrealEngine\Engine\Intermediate\ProjectFiles\UnrealPakViewer.vcxproj</span><br></pre></td></tr></table></figure><p>我一看，也是有的。构建也会成功，也会生成 exe。</p><p>那为什么我在 VS 项目视图看不到呢</p><h2 id="刷新项目的方法">刷新项目的方法</h2><p>于是看了别人是怎么做的。别人是</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Engine\Binaries\DotNET\UnrealBuildTool.exe -ProjectFiles Engine\Source\Programs\UnrealPakViewer</span><br></pre></td></tr></table></figure><p>然后用 Visual Studio 重新打开 VS 项目，我这里还真的就可以了。</p><p>我再重新用 Rider 打开，就看不到新项目。所以这还是 IDE 的问题。</p><p>好吧，后来才发现，是这个插件写到了 <code>ExternalPrograms</code> 文件夹下，这个是写在 UnrealPakViewer.Target.cs 的 <code>SolutionDirectory</code> 的</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Unreal Engine 4 </tag>
            
            <tag> Build System </tag>
            
            <tag> UnrealBuildTool </tag>
            
            <tag> Package </tag>
            
            <tag> PAK </tag>
            
            <tag> UnrealPakViewer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4.27.2 构建系统 UnrealBuildTool 的调试分析</title>
      <link href="/2025/05/11/2025-05-11-ue4_build_system/"/>
      <url>/2025/05/11/2025-05-11-ue4_build_system/</url>
      
        <content type="html"><![CDATA[<h2 id="模块以及目标类型">模块以及目标类型</h2><p>不再赘述</p><h2 id="构建-UBT，创建-VS-工程">构建 UBT，创建 VS 工程</h2><p><code>GenerateProjectFiles.bat</code> 调用 <code>Engine\Build\BatchFiles\GenerateProjectFiles.bat</code></p><p>该脚本前面的部分是准备编译环境，比如找到 MSBuild，然后调用 MSBuild 构建 UnrealBuildTool</p><p><code>UnrealBuildTool.csproj</code> 是提前写好的，所以可以直接编译</p><p>然后就是调用 UnrealBuildTool 来构建 VS 工程。于是开始看 UnrealBuildTool 代码。</p><h2 id="如何调试-UnrealBuildTool-生成项目">如何调试 UnrealBuildTool 生成项目</h2><p><code>Engine\Build\BatchFiles\GenerateProjectFiles.bat</code> 里面写得很清楚了，就是用这个命令行参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-ProjectFiles</span><br></pre></td></tr></table></figure><p>UnrealBuildTool 入口函数根据参数选择创建 <code>ToolMode</code> 调用 <code>Execute</code> 虚函数。不同的 mode 对应不同的构建行为</p><p>显然 <code>GenerateProjectFilesMode</code> 类对应构建 VS 工程的逻辑。</p><p>我想知道自己创建出来的模块是怎么让 UE 识别到的，于是还是要看看他是怎么生成项目文件的</p><h2 id="生成项目时，自定义模块如何被识别">生成项目时，自定义模块如何被识别</h2><p>查看 <code>GenerateProjectFilesMode</code> 类的 <code>Execute</code> 实现</p><p>可以看到他对于不同平台有不同的项目生成器 <code>Generator</code>，最终调用 <code>Generator.GenerateProjectFiles</code></p><p>点进来看 <code>Generator.GenerateProjectFiles</code>，前面的配置就不说了</p><p>然后是他寻找 game, target 和 module 的部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Build the list of games to generate projects for</span></span><br><span class="line">List&lt;FileReference&gt; AllGameProjects = <span class="built_in">FindGameProjects</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all of the target files.  This will filter out any modules or targets that don&#x27;t</span></span><br><span class="line"><span class="comment">// belong to platforms we&#x27;re generating project files for.</span></span><br><span class="line">List&lt;FileReference&gt; AllTargetFiles = <span class="built_in">DiscoverTargets</span>(AllGameProjects);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all of the module files.  This will filter out any modules or targets that don&#x27;t belong to platforms</span></span><br><span class="line"><span class="comment">// we&#x27;re generating project files for.</span></span><br><span class="line">List&lt;FileReference&gt; AllModuleFiles = <span class="built_in">DiscoverModules</span>(AllGameProjects);</span><br></pre></td></tr></table></figure><p>之后就是把找到的这些目标添加到工程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ProjectFile EngineProject;</span><br><span class="line">ProjectFile EnterpriseProject;</span><br><span class="line">List&lt;ProjectFile&gt; GameProjects;</span><br><span class="line">List&lt;ProjectFile&gt; ModProjects;</span><br><span class="line">Dictionary&lt;FileReference, ProjectFile&gt; ProgramProjects;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Setup buildable projects for all targets</span></span><br><span class="line">  <span class="built_in">AddProjectsForAllTargets</span>( PlatformProjectGenerators, AllGameProjects, AllTargetFiles, Arguments, out EngineProject, out EnterpriseProject, out GameProjects, out ProgramProjects );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add projects for mods</span></span><br><span class="line">  <span class="built_in">AddProjectsForMods</span>(GameProjects, out ModProjects);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add all game projects and game config files</span></span><br><span class="line">  <span class="built_in">AddAllGameProjects</span>(GameProjects, SupportedPlatformNames, RootFolder);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup &quot;stub&quot; projects for all modules</span></span><br><span class="line"><span class="built_in">AddProjectsForAllModules</span>(AllGameProjects, ProgramProjects, ModProjects, AllModuleFiles, bGatherThirdPartySource);</span><br></pre></td></tr></table></figure><h2 id="如何调试-UnrealBuildTool-构建项目">如何调试 UnrealBuildTool 构建项目</h2><p>已经配置好 VS 项目后，直接在 VS 工程中点击调试，在输出窗口中可以看到构建命令</p><p>比如我这里的构建命令是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path to engine&gt;\Engine\Build\BatchFiles\Build.bat -Target=&quot;&lt;project name&gt;Editor Win64 Development -Project=\&quot;E:\Unreal Projects\&lt;project name&gt;\&lt;project name&gt;.uproject\&quot;&quot; -Target=&quot;ShaderCompileWorker Win64 Development -Quiet&quot; -WaitMutex -FromMsBuild</span><br></pre></td></tr></table></figure><p>去看一下 <code>&lt;path to engine&gt;\Engine\Build\BatchFiles\Build.bat</code> 就可以看到，他只是 <code>UnrealBuildTool.exe</code> 的简单包装</p><p>所以完全可以复制粘贴后面的命令行参数，以调试 UnrealBuildTool 项目</p><h2 id="UnrealBuildTool-构建模式的逻辑">UnrealBuildTool 构建模式的逻辑</h2><p>显然，<code>BuildMode</code> 类对应构建逻辑。</p><p>其 <code>Execute</code> 内主要功能是收集构建目标，进行多目标构建。每个目标可以是远端构建或本地构建。</p><p>然后它调用 <code>Build</code> 开始对具体目标开始构建。</p><p>具体到本地构建 <code>public static void Build(List&lt;TargetDescriptor&gt; TargetDescriptors, BuildConfiguration BuildConfiguration, ISourceFileWorkingSet WorkingSet, BuildOptions Options, FileReference WriteOutdatedActionsFile, bool bSkipPreBuildTargets = false)</code>，每个不能被跳过构建的目标，都生成 makefile</p><p>再下一层 <code>static void Build(TargetMakefile[] Makefiles, List&lt;TargetDescriptor&gt; TargetDescriptors, BuildConfiguration BuildConfiguration, ISourceFileWorkingSet WorkingSet, BuildOptions Options, FileReference WriteOutdatedActionsFile)</code> 对确认要构建的，具有 makefile 的目标进行处理。</p><p>这里面，除了一些构建特性的支持，比如热重载，暂时跳过不看，剩下的主题是引入了一个 <code>Action</code> 的概念。每一项构建一个 <code>Action</code>，<code>Action</code> 之间有依赖关系，是一个图。<code>ActionGraph.ExecuteActions</code> 对这个图结构发起构建。</p><p>这个图结构发起构建的逻辑是，根据构建配置创建不同类型的 <code>Executor</code>，然后调用 <code>Executor.ExecuteActions</code> 对 <code>Action</code> 列表发起构建</p><p>在我的调试中，它创建的是 <code>ParallelExecutor</code> 类</p><p>该 <code>Executor</code> 类里面对输入的 <code>Action</code> 列表遍历，转为 <code>BuildAction</code> 列表</p><p>单纯从他创建的过程来看，<code>BuildAction</code> 相较于 <code>Action</code> 主要是多了个序号</p><p>然后根据 <code>BuildAction</code> 的 <code>.Inner.PrerequisiteItems</code> 创建依赖关系</p><p>最终从 <code>BuildAction</code> 列表遍历，创建 <code>BuildAction</code> 队列</p><p>对 <code>BuildAction</code> 队列处理构建。这时可以根据依赖关系对 <code>BuildAction</code> 排序</p><p>排序之后就可以对每一个 <code>BuildAction</code> 创建构建线程</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BuildAction Action = QueuedActions[QueuedActions.Count - <span class="number">1</span>];</span><br><span class="line">QueuedActions.RemoveAt(QueuedActions.Count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Thread ExecutingThread = <span class="keyword">new</span> Thread(() =&gt; &#123; ExecuteAction(ProcessGroup, Action, CompletedActions, CompletedEvent); &#125;);</span><br><span class="line">ExecutingThread.Name = String.Format(<span class="string">&quot;Build:&#123;0&#125;&quot;</span>, Action.Inner.StatusDescription);</span><br><span class="line">ExecutingThread.Start();</span><br><span class="line"></span><br><span class="line">ExecutingActions.Add(Action, ExecutingThread);</span><br></pre></td></tr></table></figure><p>之后就是怎么收集这些构建线程的事情了。</p><p>这些线程工作完了，UBT 就结束了。于是步进调试到 <code>ParallelExecutor.ExecuteAction</code>。</p><p>其中的核心是</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ManagedProcess Process = <span class="keyword">new</span> ManagedProcess(ProcessGroup, Action.Inner.CommandPath.FullName, Action.Inner.CommandArguments, Action.Inner.WorkingDirectory.FullName, <span class="literal">null</span>, <span class="literal">null</span>, ProcessPriorityClass.BelowNormal)</span><br></pre></td></tr></table></figure><p>可见，他也是最终调用一个可执行文件，然后传入各种文本作为构建参数</p><p>我调试时，<code>Action.Inner.CommandPath.FullName</code> 是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path to engine&gt;\Engine\Build\Windows\cl-filter\cl-filter.exe</span><br></pre></td></tr></table></figure><p>这个 cl-filter 甚至不在 Engine 的 VS 项目和 Project 的 VS 项目目录里，酷</p><p>知道他是 cl 的包装，用来实现一些目的就够了</p><p><code>Action.Inner.CommandArguments</code> 是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-dependencies=&quot;E:\Unreal Projects\&lt;project name&gt;\Intermediate\Build\Win64\UE4Editor\Development\&lt;project name&gt;\MyClass.cpp.txt&quot; -compiler=&quot;E:\software\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\bin\HostX64\x64\cl.exe&quot; -- &quot;E:\software\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\bin\HostX64\x64\cl.exe&quot;  @&quot;E:\Unreal Projects\&lt;project name&gt;\Intermediate\Build\Win64\UE4Editor\Development\&lt;project name&gt;\MyClass.cpp.obj.response&quot; /showIncludes</span><br></pre></td></tr></table></figure><p>打开看这个 response 文件，可以看到他应该是为了传入编译选项、include 路径、输入输出目录</p><p>前面的部分的节选</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/bigobj</span><br><span class="line">/fp:fast</span><br><span class="line">/Zp8</span><br><span class="line">/we4456</span><br><span class="line">/we4458</span><br><span class="line">/we4459</span><br><span class="line">/wd4463</span><br><span class="line">/we4668</span><br><span class="line">/wd4244</span><br><span class="line">/wd4838</span><br><span class="line">/I .</span><br><span class="line">/I &quot;E:\Unreal Projects\&lt;project name&gt;\Source&quot;</span><br><span class="line">/I Runtime</span><br><span class="line">/I Runtime\TraceLog\Public</span><br><span class="line">/I Runtime\Core\Public</span><br><span class="line">/I ..\Intermediate\Build\Win64\UE4Editor\Inc\CoreUObject</span><br><span class="line">/I Runtime\CoreUObject\Public</span><br><span class="line">/I ..\Intermediate\Build\Win64\UE4Editor\Inc\Engine</span><br><span class="line">/I Runtime\Engine\Classes</span><br><span class="line">/I Runtime\Engine\Public</span><br><span class="line">/I ..\Intermediate\Build\Win64\UE4Editor\Inc\NetCore</span><br><span class="line">/I Runtime\Net</span><br></pre></td></tr></table></figure><p>后面的部分的节选</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/I &quot;C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt&quot;</span><br><span class="line">/I &quot;C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\shared&quot;</span><br><span class="line">/I &quot;C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\um&quot;</span><br><span class="line">/I &quot;C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\winrt&quot;</span><br><span class="line">/FI&quot;&lt;path to engine&gt;\Engine\Intermediate\Build\Win64\UE4Editor\Development\Engine\SharedPCH.Engine.NonOptimized.ShadowErrors.h&quot;</span><br><span class="line">/Yu&quot;&lt;path to engine&gt;\Engine\Intermediate\Build\Win64\UE4Editor\Development\Engine\SharedPCH.Engine.NonOptimized.ShadowErrors.h&quot;</span><br><span class="line">/Fp&quot;&lt;path to engine&gt;\Engine\Intermediate\Build\Win64\UE4Editor\Development\Engine\SharedPCH.Engine.NonOptimized.ShadowErrors.h.pch&quot;</span><br><span class="line">&quot;E:\Unreal Projects\&lt;project name&gt;\Source\&lt;project name&gt;\MyClass.cpp&quot;</span><br><span class="line">/FI&quot;E:\Unreal Projects\&lt;project name&gt;\Intermediate\Build\Win64\UE4Editor\DebugGame\&lt;project name&gt;\Definitions.&lt;project name&gt;.h&quot;</span><br><span class="line">/Fo&quot;E:\Unreal Projects\&lt;project name&gt;\Intermediate\Build\Win64\UE4Editor\DebugGame\&lt;project name&gt;\MyClass.cpp.obj&quot;</span><br><span class="line">/TP</span><br><span class="line">/GR-</span><br><span class="line">/W4</span><br></pre></td></tr></table></figure><p>到此就差不多了。剩下的，比如 cl 干了什么、cl-filter 干了什么、response 文件是怎么生成的、读 response 之后怎么构建的，应该就太细节了，我没有去调试</p><p>虽然我没有调试，但是看了一些博客。cl-filter 这个包装，主要是为了解决，增量构建时，如何找到某次代码修改涉及到的所有的依赖项的问题。</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Unreal Engine 4 </tag>
            
            <tag> Build System </tag>
            
            <tag> UnrealBuildTool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4.27.2 PAK 打包流程的调试分析</title>
      <link href="/2025/05/10/2025-05-10-ue4_package_pipeline/"/>
      <url>/2025/05/10/2025-05-10-ue4_package_pipeline/</url>
      
        <content type="html"><![CDATA[<h2 id="UAT-调用">UAT 调用</h2><p>从 UI 点击，触发回调，最终调用到 <code>FLauncherUATTask::PerformTask</code>，它内部就是唤起了一个 UAT Command</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FString UATCommandLine;</span><br><span class="line">FString ProjectPath = *ChainState.Profile-&gt;<span class="built_in">GetProjectPath</span>();</span><br><span class="line">ProjectPath = FPaths::<span class="built_in">ConvertRelativePathToFull</span>(ProjectPath);</span><br><span class="line">UATCommandLine = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;-ScriptsForProject=\&quot;%s\&quot; BuildCookRun -project=\&quot;%s\&quot; -noP4 -clientconfig=%s -serverconfig=%s&quot;</span>),</span><br><span class="line">    *ProjectPath,</span><br><span class="line">    *ProjectPath,</span><br><span class="line">    <span class="built_in">LexToString</span>(ChainState.Profile-&gt;<span class="built_in">GetBuildConfiguration</span>()),</span><br><span class="line">    <span class="built_in">LexToString</span>(ChainState.Profile-&gt;<span class="built_in">GetBuildConfiguration</span>()));</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// launch UAT and monitor its progress</span></span><br><span class="line">ProcessHandle = FPlatformProcess::<span class="built_in">CreateProc</span>(*(ExecutablePath / Executable), *UATCommandLine, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="number">0</span>, *ExecutablePath, WritePipe);</span><br></pre></td></tr></table></figure><p>以安卓为例</p><p>打包时，调用的 UAT 进程的参数是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L&quot;/c &quot;&quot;&lt;my position&gt;/UnrealEngine/Engine/Build/BatchFiles/RunUAT.bat&quot; -ScriptsForProject=&quot;&lt;my position&gt;/&lt;my project name&gt;/&lt;my project name&gt;.uproject&quot; BuildCookRun -nocompileeditor -nop4 -project=&quot;&lt;my position&gt;/&lt;my project name&gt;/&lt;my project name&gt;.uproject&quot; -cook -stage -archive -archivedirectory=&quot;&lt;my position&gt;/&lt;my project name&gt;AndroidPackage&quot; -package -ue4exe=&quot;&lt;my position&gt;\UnrealEngine\Engine\Binaries\Win64\UE4Editor-Win64-DebugGame-Cmd.exe&quot;  -compressed -ddc=DerivedDataBackendGraph -pak -prereqs -nodebuginfo -targetplatform=Android -cookflavor=ETC2 -build -target=&lt;my project name&gt; -clientconfig=Development -utf8output&quot;&quot;</span><br></pre></td></tr></table></figure><p>不太理解为什么写成 <code>-utf8output&quot;&quot;</code>，那个后面的 <code>&quot;&quot;</code> 是啥意思</p><p>分析一下我要是想自己调用的话，该怎么做</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&lt;my position&gt;/UnrealEngine/Engine/Build/BatchFiles/RunUAT.bat&quot; -ScriptsForProject=&quot;&lt;my position&gt;/&lt;my project name&gt;/&lt;my project name&gt;.uproject&quot; BuildCookRun -nocompileeditor -nop4 -project=&quot;&lt;my position&gt;/&lt;my project name&gt;/&lt;my project name&gt;.uproject&quot; -cook -stage -archive -archivedirectory=&quot;&lt;my position&gt;/&lt;my project name&gt;AndroidPackage&quot; -package -ue4exe=&quot;&lt;my position&gt;\UnrealEngine\Engine\Binaries\Win64\UE4Editor-Win64-DebugGame-Cmd.exe&quot;  -compressed -ddc=DerivedDataBackendGraph -pak -prereqs -nodebuginfo -targetplatform=Android -cookflavor=ETC2 -build -target=&lt;my project name&gt; -clientconfig=Development -utf8output</span><br></pre></td></tr></table></figure><p>这样是 work 的</p><p>具体到 RunUAT.bat 里面看，他只是转发参数给 AutomationToolLauncher.exe</p><p>于是在 IDE 中传入调试 UE 时获得的命令行参数。它最终转发参数给 AutomationTool.exe</p><h2 id="UAT-打包生成-apk">UAT 打包生成 apk</h2><p>AutomationTool.exe 最终会分析参数，分析出来 BuildCookRun</p><p>它会根据字符串查询类型，最终创建出来 <code>public class BuildCookRun : BuildCommand</code> 这个类</p><p>他最终会执行 <code>protected void DoBuildCookRun(ProjectParams Params)</code></p><p>该函数调用构建、烘培、打包程序</p><p>自然地，打包函数是虚函数，随平台而不同</p><p>具体到安卓平台是 <code>AndroidPlatform</code> 实现了 <code>Package</code> 函数</p><p>实际调试发现，<code>Package</code> 函数并不是简单的包揽所有，它只是负责 obb 文件的创建与更新，还有 apk 文件的创建的准备工作</p><p>之后还有别的接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">DoBuildCookRun</span>(<span class="params">ProjectParams Params</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    Project.CopyBuildToStagingDirectory(Params);</span><br><span class="line">    Project.Package(Params, WorkingCL);</span><br><span class="line">    Project.Archive(Params);</span><br><span class="line">    Project.Deploy(Params);</span><br><span class="line">    PrintRunTime();</span><br><span class="line">    Project.Run(Params);</span><br><span class="line">    Project.GetFile(Params);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 Deploy 似乎是没有执行。它是把 apk 部署到当前平台，但是我这里是 windows 所以他没有部署？</p><p>重新跑一遍，是在 <code>Project.Archive(Params);</code> 执行之后，apk 和 obb 文件就都生成了</p><p>点进来看，是在 <code>public static void Archive(ProjectParams Params)</code> 的 <code>ApplyArchiveManifest(Params, SC);</code> 这里创建出文件</p><p>这仅仅是从文件浏览器的角度来看，我感觉可能之前对于文件的准备工作还是会很多</p><p>不过目前还是从这个明显的创建出文件的这个函数作为入口来看</p><p>进到 <code>ApplyArchiveManifest</code> 发现他只是拷贝文件而已。拷贝文件还可以只拷贝增量，神奇。</p><p>所以是在这之间文件已经在 \Binaries\Android 打包好了，现在只是拷贝到输出目录。</p><p>于是重新调试，发现 \Binaries\Android 里面的 apk, obb 确实是由 <code>Project.Package(Params, WorkingCL);</code> 创建</p><p>于是还是回到 <code>AndroidPlatform.Package</code>，看到</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> StageDirectoryPath = Path.Combine(SC.StageDirectory.FullName, SC.ShortProjectName);</span><br><span class="line">List&lt;FileReference&gt; FilesForObb = ObbFileFilter.ApplyToDirectory(<span class="keyword">new</span> DirectoryReference(StageDirectoryPath), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>于是发现这里似乎是已经有文件可以处理了，这个文件看上去还是 pak 包</p><p>于是看到 <code>FilesForObb</code> 的成员，看到 <code>&lt;my ue position&gt;\&lt;my project name&gt;\Saved\StagedBuilds\Android_ETC2\&lt;my project name&gt;\Content\Paks\&lt;my project name&gt;-Android_ETC2.pak</code></p><p>于是发现，在 UAT 打包之前，我的 Saved\StagedBuilds\Android_ETC2 文件夹里面已经有 pak 文件了？</p><p>那这个暂且搁置，回来看看 UAT 的打包是否都是复制文件</p><p>一路调试到 <code>Deploy.PrepForUATPackageOrDeploy</code>，在这里执行之后生成了 apk</p><p>重定向到 <code>UEDeployAndroid.PrepForUATPackageOrDeploy</code>，这里面的大头就是 <code>MakeApk</code></p><p>最终调试到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RunCommandLineProgramWithExceptionAndFiltering</span>(UE4BuildGradlePath, ShellExecutable, ShellParametersBegin + <span class="string">&quot;\&quot;&quot;</span> + GradleScriptPath + <span class="string">&quot;\&quot; &quot;</span> + GradleOptions + ShellParametersEnd, <span class="string">&quot;Making .apk with Gradle...&quot;</span>);</span><br></pre></td></tr></table></figure><p>是他调用了 Gradle 去生成 apk</p><p>之后就是调用 <code>CopyFile(LocalObbName, ObbName);</code> 去拷贝 obb</p><h2 id="UnrealPak-调用流程">UnrealPak 调用流程</h2><p>再回来单步调试，<code>BuildCookRun.DoBuildCookRun</code> 中的 <code>Project.CopyBuildToStagingDirectory(Params);</code> 负责生成 Saved\StagedBuilds\Android_ETC2 中所有内容</p><p>其中，<code>Project.ApplyStagingManifest</code> 生成了内容</p><p>其中是各种 Manifest 的类型，假设先不管每个条件是什么，根据调试，进入 <code>Project.CreatePakUsingStagingManifest</code></p><p>其中根据 manifest 有一些 rules 的处理，处理完之后调用 <code>Project.CreatePaks</code></p><p>前面部分是压缩设置，优先级，然后就是遍历 <code>PakParamsList</code> 处理每个要打包的 pak</p><p><code>PakParamsList</code> 中的一个 <code>CreatePakParams</code> 成员对应一个 pak</p><p><code>CreatePakParams</code> 的 <code>UnrealPakResponseFile</code> 成员列出了需要打包的文件列表</p><p>遍历 <code>PakParamsList</code> 时，开头是计算文件路径，然后是判断是否可以复用已经生成的 pak，判断是否生成增量补丁</p><p>如果不能复用，那么开始生成 pak</p><p>为了生成 pak，又要调用别的程序，所以要准备一下传递的参数</p><p>最终调用为记录 command</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Commands.<span class="built_in">Add</span>(<span class="built_in">GetUnrealPakArguments</span>(</span><br><span class="line">    Params.RawProjectPath,</span><br><span class="line">    UnrealPakResponseFile,</span><br><span class="line">    OutputLocation,</span><br><span class="line">    PrimaryOrderFiles,</span><br><span class="line">    SC.StageTargetPlatform.<span class="built_in">GetPlatformPakCommandLine</span>(Params, SC) + AdditionalArgs + BulkOption + CompressionFormats + <span class="string">&quot; &quot;</span> + Params.AdditionalPakOptions,</span><br><span class="line">    PakParams.bCompressed,</span><br><span class="line">    Params.SkipEncryption ? null : CryptoSettings,</span><br><span class="line">    Params.SkipEncryption ? null : CryptoKeysCacheFilename,</span><br><span class="line">    PatchSourceContentPath,</span><br><span class="line">    Params.SkipEncryption ? <span class="string">&quot;&quot;</span> : PakParams.EncryptionKeyGuid,</span><br><span class="line">    SecondaryOrderFiles));</span><br></pre></td></tr></table></figure><p>进入 <code>Project.GetUnrealPakArguments</code> 可以看到 <code>Project.WritePakResponseFile</code> 也是写 txt 文件，把要打包什么写入到 txt 文件中，应该是要传递给 UnrealPak</p><p>每个 pak 都记录一个 command，收集起来成为一个列表，然后并行调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Actually execute UnrealPak</span></span><br><span class="line"><span class="keyword">if</span> (Commands.Count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">RunUnrealPakInParallel</span>( Commands, LogNames, AdditionalCompressionOptionsOnCommandLine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用 UnrealPak 的参数就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my ue position&gt;\&lt;my project name&gt;\&lt;my project name&gt;.uproject &lt;my ue position&gt;\&lt;my project name&gt;\Saved\StagedBuilds\Android_ETC2\&lt;my project name&gt;\Content\Paks\&lt;my project name&gt;-Android_ETC2.pak -create=&lt;my ue location&gt;\UnrealEngine\Engine\Programs\AutomationTool\Saved\Logs\PakList_&lt;my project name&gt;-Android_ETC2.txt -cryptokeys=&lt;my ue position&gt;\&lt;my project name&gt;\Saved\Cooked\Android_ETC2\&lt;my project name&gt;\Metadata\Crypto.json -secondaryOrder=&lt;my ue position&gt;\&lt;my project name&gt;\Build\Android_ETC2\FileOpenOrder\CookerOpenOrder.log -platform=Android -compressionformats=Oodle -compressmethod=Kraken -compresslevel=3  -multiprocess -abslog=&lt;my ue location&gt;\UnrealEngine\Engine\Programs\AutomationTool\Saved\Logs\UnrealPak-&lt;my project name&gt;-Android_ETC2-2025.05.09-19.04.31.txt -compressionblocksize=256KB</span><br></pre></td></tr></table></figure><p>之后就是 UnrealPak 内部的逻辑了。直接把这段命令行传给 UnrealPak 项目就可以调试了</p><h2 id="UnrealPak-内部流程">UnrealPak 内部流程</h2><p>UnrealPak 是 cpp 项目，是对引擎内 <code>ExecuteUnrealPak</code> 函数的包装</p><p>前面的部分是一些功能，比如生成补丁。除了这些功能，打包的逻辑最终是</p><p>先收集打包文件列表 <code>CollectFilesToAdd(FilesToAdd, Entries, OrderMap, CmdLineParameters);</code></p><p>根据文件列表创建 PAK <code>bool bResult = CreatePakFile(*PakFilename, FilesToAdd, CmdLineParameters, KeyChain);</code></p><p><code>CreatePakFile</code> 里面涉及到挂载点、压缩机制、加密机制、对齐和填充、异步和多线程、索引结构，这个打包的细节还是很多的</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Unreal Engine 4 </tag>
            
            <tag> Package </tag>
            
            <tag> PAK </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4.27.2 着色器的延迟编译的调试分析</title>
      <link href="/2025/05/10/2025-05-10-ue4_deferred_shader_compilation/"/>
      <url>/2025/05/10/2025-05-10-ue4_deferred_shader_compilation/</url>
      
        <content type="html"><![CDATA[<p>发起编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Compiles the shaders for a material and caches them in this shader map.</span></span><br><span class="line"><span class="comment">* @param Material - The material to compile shaders for.</span></span><br><span class="line"><span class="comment">* @param InShaderMapId - the set of static parameters to compile for</span></span><br><span class="line"><span class="comment">* @param Platform - The platform to compile to</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FMaterialShaderMap::Compile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">FMaterial* Material,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> FMaterialShaderMapId&amp; InShaderMapId,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> TRefCountPtr&lt;FSharedShaderCompilerEnvironment&gt;&amp; MaterialEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> FMaterialCompilationOutput&amp; InMaterialCompilationOutput,</span></span></span><br><span class="line"><span class="params"><span class="function">EShaderPlatform InPlatform,</span></span></span><br><span class="line"><span class="params"><span class="function">EMaterialShaderPrecompileMode PrecompileMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PrecompileMode != EMaterialShaderPrecompileMode::None)</span><br><span class="line">&#123;</span><br><span class="line">EShaderCompileJobPriority CompilePriority = EShaderCompileJobPriority::Low;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="built_in">SubmitCompileJobs</span>(CompilingId, Material, MaterialEnvironment, CompilePriority);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile the shaders for this shader map now if the material is not deferring and deferred compiles are not enabled globally</span></span><br><span class="line"><span class="keyword">if</span> (PrecompileMode == EMaterialShaderPrecompileMode::Synchronous)</span><br><span class="line">&#123;</span><br><span class="line">TArray&lt;int32&gt; CurrentShaderMapId;</span><br><span class="line">CurrentShaderMapId.<span class="built_in">Add</span>(CompilingId);</span><br><span class="line">GShaderCompilingManager-&gt;<span class="built_in">FinishCompilation</span>(</span><br><span class="line"><span class="built_in">GetFriendlyName</span>(),</span><br><span class="line">CurrentShaderMapId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的判断逻辑。一开始发起一个异步 job。如果当前模式为同步模式，那么发起之后立即阻塞，直到编译结束。</p><p><code>FShaderCompilingManager::FinishCompilation</code> 是实现阻塞编译的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FShaderCompilingManager::FinishCompilation</span><span class="params">(<span class="type">const</span> TCHAR* MaterialName, <span class="type">const</span> TArray&lt;int32&gt;&amp; ShaderMapIdsToFinishCompiling)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">TMap&lt;int32, FShaderMapFinalizeResults&gt; CompiledShaderMaps;</span><br><span class="line">CompiledShaderMaps.<span class="built_in">Append</span>( PendingFinalizeShaderMaps );</span><br><span class="line">PendingFinalizeShaderMaps.<span class="built_in">Empty</span>();</span><br><span class="line"><span class="built_in">BlockOnShaderMapCompletion</span>(ShaderMapIdsToFinishCompiling, CompiledShaderMaps);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> bRetry = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123;</span><br><span class="line">bRetry = <span class="built_in">HandlePotentialRetryOnError</span>(CompiledShaderMaps);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span> (bRetry);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ProcessCompiledShaderMaps</span>(CompiledShaderMaps, FLT_MAX);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FShaderCompilingManager::BlockOnShaderMapCompletion</code> 等待编译完成，然后把编译完成的结果，插入到一个列表。这个列表的初始状态是已经完成但还未处理的 ShaderMap 编译结果 <code>PendingFinalizeShaderMaps</code>。</p><p>当前编译完成的，和之前已经编译完成的，一起做最终的处理 Finalize</p><p>可见，这里暗示了，编译之后的 shader 还需要处理</p><p>完成编译的时候，着色器是怎么替换的？应该这里的最终处理就是实现这个事情</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FShaderCompilingManager::ProcessCompiledShaderMaps</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">TMap&lt;int32, FShaderMapFinalizeResults&gt;&amp; CompiledShaderMaps, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">float</span> TimeBudget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_EDITOR</span></span><br><span class="line">TMap&lt;TRefCountPtr&lt;FMaterial&gt;, TRefCountPtr&lt;FMaterialShaderMap&gt;&gt; MaterialsToUpdate;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 判断、获取那些编译成功的 shader 对应的材质</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MaterialsToUpdate.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">FMaterial::<span class="built_in">SetShaderMapsOnMaterialResources</span>(MaterialsToUpdate);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; It : MaterialsToUpdate)</span><br><span class="line">&#123;</span><br><span class="line">It.Key-&gt;<span class="built_in">NotifyCompilationFinished</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FApp::<span class="built_in">CanEverRender</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">PropagateMaterialChangesToPrimitives</span>(MaterialsToUpdate);</span><br><span class="line"></span><br><span class="line">FEditorSupportDelegates::RedrawAllViewports.<span class="built_in">Broadcast</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WITH_EDITOR</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，它是对那些编译成功的 shader 进行处理，找出这些 shader 对应的 material，把这些 material 的更新应用到图元</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FShaderCompilingManager::PropagateMaterialChangesToPrimitives</span><span class="params">(<span class="type">const</span> TMap&lt;TRefCountPtr&lt;FMaterial&gt;, TRefCountPtr&lt;FMaterialShaderMap&gt;&gt;&amp; MaterialsToUpdate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TArray&lt;UMaterialInterface*&gt; UsedMaterials;</span><br><span class="line">TIndirectArray&lt;FComponentRecreateRenderStateContext&gt; ComponentContexts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (TObjectIterator&lt;UPrimitiveComponent&gt; PrimitiveIt; PrimitiveIt; ++PrimitiveIt)</span><br><span class="line">&#123;</span><br><span class="line">UPrimitiveComponent* PrimitiveComponent = *PrimitiveIt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PrimitiveComponent-&gt;<span class="built_in">IsRenderStateCreated</span>())</span><br><span class="line">&#123;</span><br><span class="line">UsedMaterials.<span class="built_in">Reset</span>();</span><br><span class="line"><span class="type">bool</span> bPrimitiveIsDependentOnMaterial = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: relying on GetUsedMaterials to be accurate, or else we won&#x27;t propagate to the right primitives and the renderer will crash later</span></span><br><span class="line"><span class="comment">// FPrimitiveSceneProxy::VerifyUsedMaterial is used to make sure that all materials used for rendering are reported in GetUsedMaterials</span></span><br><span class="line">PrimitiveComponent-&gt;<span class="built_in">GetUsedMaterials</span>(UsedMaterials);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (UsedMaterials.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">... <span class="comment">// 判断当前 PrimitiveComponent 是否依赖于 MaterialsToUpdate 中的 Material</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bPrimitiveIsDependentOnMaterial)</span><br><span class="line">&#123;</span><br><span class="line">ComponentContexts.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">FComponentRecreateRenderStateContext</span>(PrimitiveComponent));</span><br><span class="line"></span><br><span class="line">                    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ComponentContexts.<span class="built_in">Empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是对所有需要更新材质的 PrimitiveComponent 建一个 <code>FComponentRecreateRenderStateContext</code> 放到列表</p><p>单独看这个函数的话，一个简单的猜测是构造 <code>FComponentRecreateRenderStateContext</code> 的时候不做材质更新，结束的时候清空列表，统一析构，析构的时候调用材质更新逻辑</p><p>实际进去这个类里面看会发现，它是构造和析构的时候都调用 <code>UpdateAllPrimitiveSceneInfosForSingleComponent</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Destroys render state for a component and then recreates it when this object is destroyed */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FComponentRecreateRenderStateContext</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/** Pointer to component we are recreating render state for */</span></span><br><span class="line">UActorComponent* Component;</span><br><span class="line"></span><br><span class="line">TSet&lt;FSceneInterface*&gt;* ScenesToUpdateAllPrimitiveSceneInfos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">FComponentRecreateRenderStateContext</span>(UActorComponent* InComponent, TSet&lt;FSceneInterface*&gt;* InScenesToUpdateAllPrimitiveSceneInfos = <span class="literal">nullptr</span>)</span><br><span class="line">: <span class="built_in">ScenesToUpdateAllPrimitiveSceneInfos</span>(InScenesToUpdateAllPrimitiveSceneInfos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">check</span>(InComponent);</span><br><span class="line"><span class="built_in">checkf</span>(!InComponent-&gt;<span class="built_in">IsUnreachable</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;%s&quot;</span>), *InComponent-&gt;<span class="built_in">GetFullName</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (InComponent-&gt;<span class="built_in">IsRegistered</span>() &amp;&amp; InComponent-&gt;<span class="built_in">IsRenderStateCreated</span>())</span><br><span class="line">&#123;</span><br><span class="line">InComponent-&gt;<span class="built_in">DestroyRenderState_Concurrent</span>();</span><br><span class="line">Component = InComponent;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UpdateAllPrimitiveSceneInfosForSingleComponent</span>(InComponent, ScenesToUpdateAllPrimitiveSceneInfos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Component = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">FComponentRecreateRenderStateContext</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Component &amp;&amp; !Component-&gt;<span class="built_in">IsRenderStateCreated</span>() &amp;&amp; Component-&gt;<span class="built_in">IsRegistered</span>())</span><br><span class="line">&#123;</span><br><span class="line">Component-&gt;<span class="built_in">CreateRenderState_Concurrent</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UpdateAllPrimitiveSceneInfosForSingleComponent</span>(Component, ScenesToUpdateAllPrimitiveSceneInfos);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>构造时调用</p><p>目的是通知渲染线程“我即将重建这个组件的渲染状态”，让渲染线程做好准备（比如暂停使用旧的渲染数据，避免渲染时访问到不一致的数据）。</p><p>这相当于告诉渲染线程“这个组件的渲染数据马上要变了，先做一些同步或锁定操作”。</p><p>析构时调用</p><p>目的是完成渲染状态的重建，将组件的最新材质和渲染数据提交给渲染线程。</p><p>这相当于告诉渲染线程“渲染状态已经重建完成，可以开始使用新的数据了”。</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Grphics </tag>
            
            <tag> Unreal Engine 4 </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解渲染方程</title>
      <link href="/2025/03/17/2025-03-17-understand_the_render_equation/"/>
      <url>/2025/03/17/2025-03-17-understand_the_render_equation/</url>
      
        <content type="html"><![CDATA[<p>理解渲染方程最重要的一点是，由微分定义外推到方向向量和点。</p><h2 id="反射率方程">反射率方程</h2><p>反射率方程</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=L_o%28p%2C%5Comega_o%29%20%3D%20%5Cint%5Climits_%7B%5COmega%7D%20f_r(p%2C%5Comega_i%2C%5Comega_o)%20L_i(p%2C%5Comega_i)%20n%20%5Ccdot%20%5Comega_i%20%20d%5Comega_i%0A" /></p><p>L 表示辐射率</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=L%3D%5Cfrac%7Bd%5E2%5CPhi%7D%7B%20dA%20d%5Comega%20%5Ccos%5Ctheta%7D%0A" /></p><p><img src="https://learnopengl-cn.github.io/img/07/01/radiance.png" alt=""></p><p>learnOpenGL 已经讲得很清晰了</p><p><a href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/">https://learnopengl-cn.github.io/07 PBR/01 Theory/</a></p><blockquote><p>如果我们把立体角 ω 和面积 A 看作是无穷小的，那么我们就能用辐射率来表示单束光线穿过空间中的一个点的通量。这就使我们可以计算得出作用于单个（片段）点上的单束光线的辐射率，我们实际上把立体角 ω 转变为方向向量 ω 然后把面 A 转换为点 p。这样我们就能直接在我们的着色器中使用辐射率来计算单束光线对每个片段的作用了。</p></blockquote><p>最重要的就是这里，<strong>外推到无穷小，立体角 ω 对应光线（方向向量），面积 A 对应着色点，辐射率 L 对应光强。</strong></p><p>那么其实从定义到实践就打通了。比如，公式仅仅是对入射光强乘以表面的系数再积分，就是反射的光强，自然而然地就能有这个理解。</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Grphics </tag>
            
            <tag> Render Equation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Two kinds of poisson equation</title>
      <link href="/2024/09/18/2024-09-18-two_kinds_of_poisson_eq/"/>
      <url>/2024/09/18/2024-09-18-two_kinds_of_poisson_eq/</url>
      
        <content type="html"><![CDATA[<h2 id="Two-kinds-of-poisson-equation">Two kinds of poisson equation</h2><h3 id="Taking-the-Divergence-Directly-from-the-Navier-Stokes-Equation">Taking the Divergence Directly from the Navier-Stokes Equation</h3><p>Incompressibility condition:</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bz%7D%7D%20%3D%200%0A" /></p><p>Momentum equations without source terms:</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cbegin%7Balign*%7D%0A%20%20%20%20%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bt%7D%7D%20%2B%20u%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%7D%20%2B%20v%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%20w%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bz%7D%7D%20%26%3D%20-%5Cdfrac%7B1%7D%7B%5Crho%7D%5Cdfrac%7B%5Cpartial%7Bp%7D%7D%7B%5Cpartial%7Bx%7D%7D%20%2B%20%5Cnu%20%5Cleft%28%5Cdfrac%7B%5Cpartial%5E2%7Bu%7D%7D%7B%5Cpartial%7Bx%5E2%7D%7D%2B%5Cdfrac%7B%5Cpartial%5E2%7Bu%7D%7D%7B%5Cpartial%7By%5E2%7D%7D%2B%5Cdfrac%7B%5Cpartial%5E2%7Bu%7D%7D%7B%5Cpartial%7Bz%5E2%7D%7D%5Cright%29%2C%20%5C%5C%0A%20%20%20%20%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7Bt%7D%7D%20%2B%20u%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7Bx%7D%7D%20%2B%20v%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%20w%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7Bz%7D%7D%20%26%3D%20-%5Cdfrac%7B1%7D%7B%5Crho%7D%5Cdfrac%7B%5Cpartial%7Bp%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%20%5Cnu%20%5Cleft(%5Cdfrac%7B%5Cpartial%5E2%7Bv%7D%7D%7B%5Cpartial%7Bx%5E2%7D%7D%2B%5Cdfrac%7B%5Cpartial%5E2%7Bv%7D%7D%7B%5Cpartial%7By%5E2%7D%7D%2B%5Cdfrac%7B%5Cpartial%5E2%7Bv%7D%7D%7B%5Cpartial%7Bz%5E2%7D%7D%5Cright)%2C%20%5C%5C%0A%20%20%20%20%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bt%7D%7D%20%2B%20u%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bx%7D%7D%20%2B%20v%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%20w%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bz%7D%7D%20%26%3D%20-%5Cdfrac%7B1%7D%7B%5Crho%7D%5Cdfrac%7B%5Cpartial%7Bp%7D%7D%7B%5Cpartial%7Bz%7D%7D%20%2B%20%5Cnu%20%5Cleft(%5Cdfrac%7B%5Cpartial%5E2%7Bw%7D%7D%7B%5Cpartial%7Bx%5E2%7D%7D%2B%5Cdfrac%7B%5Cpartial%5E2%7Bw%7D%7D%7B%5Cpartial%7By%5E2%7D%7D%2B%5Cdfrac%7B%5Cpartial%5E2%7Bw%7D%7D%7B%5Cpartial%7Bz%5E2%7D%7D%5Cright)%0A%5Cend%7Balign*%7D%0A" /></p><p>Taking the divergence of the momentum equations:</p><p>Differentiate each component of the momentum equation with respect to (x), (y), and (z):</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cbegin%7Balign*%7D%0A%20%20%20%20%5Cdfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bt%7D%7D%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%7D%20%2B%20%5Cleft%28%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%7D%5Cright%29%5E2%20%2B%20u%5Cdfrac%7B%5Cpartial%5E2%7Bu%7D%7D%7B%5Cpartial%7Bx%5E2%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7Bx%7D%7D%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%20v%5Cdfrac%7B%5Cpartial%5E2%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%5Cpartial%7By%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bx%7D%7D%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bz%7D%7D%20%2B%20w%5Cdfrac%7B%5Cpartial%5E2%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%5Cpartial%7Bz%7D%7D%20%26%3D%20-%5Cdfrac%7B1%7D%7B%5Crho%7D%5Cdfrac%7B%5Cpartial%5E2%7Bp%7D%7D%7B%5Cpartial%7Bx%5E2%7D%7D%20%2B%20%5Cnu%20%5Cdfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bx%7D%7D%5Cleft(%5Cdfrac%7B%5Cpartial%5E2%7Bu%7D%7D%7B%5Cpartial%7Bx%5E2%7D%7D%2B%5Cdfrac%7B%5Cpartial%5E2%7Bu%7D%7D%7B%5Cpartial%7By%5E2%7D%7D%2B%5Cdfrac%7B%5Cpartial%5E2%7Bu%7D%7D%7B%5Cpartial%7Bz%5E2%7D%7D%5Cright)%2C%20%5C%5C%0A%20%20%20%20%5Cdfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bt%7D%7D%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7By%7D%7D%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7Bx%7D%7D%20%2B%20u%5Cdfrac%7B%5Cpartial%5E2%7Bv%7D%7D%7B%5Cpartial%7Bx%7D%5Cpartial%7By%7D%7D%20%2B%20%5Cleft(%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7By%7D%7D%5Cright)%5E2%20%2B%20v%5Cdfrac%7B%5Cpartial%5E2%7Bv%7D%7D%7B%5Cpartial%7By%5E2%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7By%7D%7D%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7Bz%7D%7D%20%2B%20w%5Cdfrac%7B%5Cpartial%5E2%7Bv%7D%7D%7B%5Cpartial%7By%7D%5Cpartial%7Bz%7D%7D%20%26%3D%20-%5Cdfrac%7B1%7D%7B%5Crho%7D%5Cdfrac%7B%5Cpartial%5E2%7Bp%7D%7D%7B%5Cpartial%7By%5E2%7D%7D%20%2B%20%5Cnu%20%5Cdfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7By%7D%7D%5Cleft(%5Cdfrac%7B%5Cpartial%5E2%7Bv%7D%7D%7B%5Cpartial%7Bx%5E2%7D%7D%2B%5Cdfrac%7B%5Cpartial%5E2%7Bv%7D%7D%7B%5Cpartial%7By%5E2%7D%7D%2B%5Cdfrac%7B%5Cpartial%5E2%7Bv%7D%7D%7B%5Cpartial%7Bz%5E2%7D%7D%5Cright)%2C%20%5C%5C%0A%20%20%20%20%5Cdfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bt%7D%7D%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bz%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bx%7D%7D%20%2B%20u%5Cdfrac%7B%5Cpartial%5E2%7Bw%7D%7D%7B%5Cpartial%7Bx%7D%5Cpartial%7Bz%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%20v%5Cdfrac%7B%5Cpartial%5E2%7Bw%7D%7D%7B%5Cpartial%7By%7D%5Cpartial%7Bz%7D%7D%20%2B%20%5Cleft(%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cright)%5E2%20%2B%20%5Cdfrac%7B%5Cpartial%5E2%7Bw%7D%7D%7B%5Cpartial%7Bz%5E2%7D%7D%20%26%3D%20-%5Cdfrac%7B1%7D%7B%5Crho%7D%5Cdfrac%7B%5Cpartial%5E2%7Bp%7D%7D%7B%5Cpartial%7Bz%5E2%7D%7D%20%2B%20%5Cnu%20%5Cdfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cleft(%5Cdfrac%7B%5Cpartial%5E2%7Bw%7D%7D%7B%5Cpartial%7Bx%5E2%7D%7D%2B%5Cdfrac%7B%5Cpartial%5E2%7Bw%7D%7D%7B%5Cpartial%7By%5E2%7D%7D%2B%5Cdfrac%7B%5Cpartial%5E2%7Bw%7D%7D%7B%5Cpartial%7Bz%5E2%7D%7D%5Cright)%0A%5Cend%7Balign*%7D%0A" /></p><p>Summing the three components gives the divergence. Using the incompressibility condition, we can factor out the divergence condition as a common factor:</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cbegin%7Balign*%7D%0A%5Cdfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bt%7D%7D%5Cleft%28%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cright%29%20%2B%20%5Cleft%5B%5Cleft(%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%7D%5Cright)%5E2%20%2B%20%5Cleft(%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7By%7D%7D%5Cright)%5E2%20%2B%20%5Cleft(%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cright)%5E2%20%2B%202%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7Bx%7D%7D%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%202%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7Bx%7D%7D%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bz%7D%7D%20%2B%202%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7By%7D%7D%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cright%5D%20%2B%20%5C%5C%0Au%5Cdfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bx%7D%7D%5Cleft(%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cright)%20%2B%20v%5Cdfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7By%7D%7D%5Cleft(%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cright)%20%2B%20w%5Cdfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cleft(%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cright)%20%3D%20%5C%5C%0A-%5Cdfrac%7B1%7D%7B%5Crho%7D%5Cleft(%5Cdfrac%7B%5Cpartial%5E2%7Bp%7D%7D%7B%5Cpartial%7Bx%5E2%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%5E2%7Bp%7D%7D%7B%5Cpartial%7By%5E2%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%5E2%7Bp%7D%7D%7B%5Cpartial%7Bz%5E2%7D%7D%5Cright)%20%2B%20%5Cnu%20%5Cleft%5B%5Cdfrac%7B%5Cpartial%5E2%7B%7D%7D%7B%5Cpartial%7Bx%5E2%7D%7D%5Cleft(%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cright)%20%2B%20%5Cdfrac%7B%5Cpartial%5E2%7B%7D%7D%7B%5Cpartial%7By%5E2%7D%7D%5Cleft(%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cright)%20%2B%20%5Cdfrac%7B%5Cpartial%5E2%7B%7D%7D%7B%5Cpartial%7Bz%5E2%7D%7D%5Cleft(%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cright)%5Cright%5D%0A%5Cend%7Balign*%7D%0A" /></p><p>Substituting the incompressibility condition, we get:</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=-%5Cdfrac%7B1%7D%7B%5Crho%7D%5Cleft%28%5Cdfrac%7B%5Cpartial%5E2%7Bp%7D%7D%7B%5Cpartial%7Bx%5E2%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%5E2%7Bp%7D%7D%7B%5Cpartial%7By%5E2%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%5E2%7Bp%7D%7D%7B%5Cpartial%7Bz%5E2%7D%7D%5Cright%29%20%3D%20%5Cleft(%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%7D%5Cright)%5E2%20%2B%20%5Cleft(%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7By%7D%7D%5Cright)%5E2%20%2B%20%5Cleft(%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cright)%5E2%20%2B%202%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7Bx%7D%7D%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7By%7D%7D%20%2B%202%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7Bx%7D%7D%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bz%7D%7D%20%2B%202%5Cdfrac%7B%5Cpartial%7Bw%7D%7D%7B%5Cpartial%7By%7D%7D%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7Bz%7D%7D%0A" /></p><p>Similarly in 2d case:</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=-%5Cdfrac%7B1%7D%7B%5Crho%7D%5Cleft%28%5Cdfrac%7B%5Cpartial%5E2%7Bp%7D%7D%7B%5Cpartial%7Bx%5E2%7D%7D%20%2B%20%5Cdfrac%7B%5Cpartial%5E2%7Bp%7D%7D%7B%5Cpartial%7By%5E2%7D%7D%5Cright%29%20%3D%20%5Cleft(%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%7D%5Cright)%5E2%20%2B%20%5Cleft(%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7By%7D%7D%5Cright)%5E2%20%2B%202%5Cdfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7Bx%7D%7D%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7By%7D%7D%0A" /></p><p>That is pressure poisson equation.</p><p>Taking two dimensions as an example, the pressure Poisson equation is discretized</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cbegin%7Bsplit%7D%0A%26%20%5Cfrac%7Bp_%7Bi%2B1%2Cj%7D%5E%7Bn%7D-2p_%7Bi%2Cj%7D%5E%7Bn%2B1%7D%2Bp_%7Bi-1%2Cj%7D%5E%7Bn%7D%7D%7B%5CDelta%20x%5E2%7D%20%2B%20%5Cfrac%7Bp_%7Bi%2Cj%2B1%7D%5E%7Bn%7D-2p_%7Bi%2Cj%7D%5E%7Bn%2B1%7D%2Bp_%7Bi%2Cj-1%7D%5E%7Bn%7D%7D%7B%5CDelta%20y%5E2%7D%20%3D%20%5C%5C%0A%26%20%5Cqquad%20%5Crho%5Cleft%5B%5Cfrac%7B1%7D%7B%5CDelta%20t%7D%5Cleft%28%5Cfrac%7Bu_%7Bi%2B1%2Cj%7D-u_%7Bi-1%2Cj%7D%7D%7B2%5CDelta%20x%7D%2B%5Cfrac%7Bv_%7Bi%2Cj%2B1%7D-v_%7Bi%2Cj-1%7D%7D%7B2%5CDelta%20y%7D%5Cright%29%20-%20%5Cfrac%7Bu_%7Bi%2B1%2Cj%7D-u_%7Bi-1%2Cj%7D%7D%7B2%5CDelta%20x%7D%5Cfrac%7Bu_%7Bi%2B1%2Cj%7D-u_%7Bi-1%2Cj%7D%7D%7B2%5CDelta%20x%7D%20-%202%5Cfrac%7Bu_%7Bi%2Cj%2B1%7D-u_%7Bi%2Cj-1%7D%7D%7B2%5CDelta%20y%7D%5Cfrac%7Bv_%7Bi%2B1%2Cj%7D-v_%7Bi-1%2Cj%7D%7D%7B2%5CDelta%20x%7D%20-%20%5Cfrac%7Bv_%7Bi%2Cj%2B1%7D-v_%7Bi%2Cj-1%7D%7D%7B2%5CDelta%20y%7D%5Cfrac%7Bv_%7Bi%2Cj%2B1%7D-v_%7Bi%2Cj-1%7D%7D%7B2%5CDelta%20y%7D%5Cright%5D%0A%5Cend%7Bsplit%7D%0A" /></p><p>Arranged:</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cbegin%7Bsplit%7D%0Ap_%7Bi%2Cj%7D%5E%7Bn%7D%20%3D%20%26%20%5Cfrac%7B%5Cleft%28p_%7Bi%2B1%2Cj%7D%5E%7Bn%7D%2Bp_%7Bi-1%2Cj%7D%5E%7Bn%7D%5Cright%29%20%5CDelta%20y%5E2%20%2B%20%5Cleft(p_%7Bi%2Cj%2B1%7D%5E%7Bn%7D%2Bp_%7Bi%2Cj-1%7D%5E%7Bn%7D%5Cright)%20%5CDelta%20x%5E2%7D%7B2(%5CDelta%20x%5E2%2B%5CDelta%20y%5E2)%7D%20%5C%5C%0A%26%20-%5Cfrac%7B%5Crho%5CDelta%20x%5E2%5CDelta%20y%5E2%7D%7B2%5Cleft(%5CDelta%20x%5E2%2B%5CDelta%20y%5E2%5Cright)%7D%20%5C%5C%0A%26%20%5Ctimes%20%5Cleft%5B%5Cfrac%7B1%7D%7B%5CDelta%20t%7D%20%5Cleft(%5Cfrac%7Bu_%7Bi%2B1%2Cj%7D-u_%7Bi-1%2Cj%7D%7D%7B2%5CDelta%20x%7D%20%2B%20%5Cfrac%7Bv_%7Bi%2Cj%2B1%7D-v_%7Bi%2Cj-1%7D%7D%7B2%5CDelta%20y%7D%5Cright)%20-%20%5Cfrac%7Bu_%7Bi%2B1%2Cj%7D-u_%7Bi-1%2Cj%7D%7D%7B2%5CDelta%20x%7D%5Cfrac%7Bu_%7Bi%2B1%2Cj%7D-u_%7Bi-1%2Cj%7D%7D%7B2%5CDelta%20x%7D%20-%202%5Cfrac%7Bu_%7Bi%2Cj%2B1%7D-u_%7Bi%2Cj-1%7D%7D%7B2%5CDelta%20y%7D%5Cfrac%7Bv_%7Bi%2B1%2Cj%7D-v_%7Bi-1%2Cj%7D%7D%7B2%5CDelta%20x%7D%20-%20%5Cfrac%7Bv_%7Bi%2Cj%2B1%7D-v_%7Bi%2Cj-1%7D%7D%7B2%5CDelta%20y%7D%5Cfrac%7Bv_%7Bi%2Cj%2B1%7D-v_%7Bi%2Cj-1%7D%7D%7B2%5CDelta%20y%7D%5Cright%5D%0A%5Cend%7Bsplit%7D%0A" /></p><p>Because it generally chooses explicit discrete pressure, it directly uses this discrete format to iterate the pressure without solving a set of linear algebra equations.</p><h3 id="Find-the-divergence-of-Helmholtz-decomposition">Find the divergence of Helmholtz decomposition</h3><p>Helmholtz decomposition: In fluid mechanics, a twice differentiable three-dimensional flow field (velocity field) can be decomposed into the sum of an irrotational velocity field and a divergence-free velocity field</p><p>Since the curl of the gradient is 0, it can be written as</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cmathbf%7Bw%7D%20%3D%20%5Cmathbf%7Bu%7D%20%2B%20%5Cnabla%20p%0A" /></p><p>Where <img src="https://math.now.sh?inline=%5Cmathbf%7Bw%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is the original flow field, <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is the desired divergence-free velocity field</p><p>Calculate the divergence of the left and right sides of the above equation, and we get</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cnabla%20%5Ccdot%20%5Cmathbf%7Bw%7D%20%3D%20%5Cnabla%20%5Ccdot%20%28%5Cmathbf%7Bu%7D%20%2B%20%5Cnabla%20p%29%20%3D%20%5Cnabla%20%5Ccdot%20%5Cnabla%20p%20%3D%20%5Cnabla%5E2%20p%0A" /></p><p>This is also the pressure Poisson equation</p><p>Taking two dimensions as an example, the pressure Poisson equation is discretized</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cfrac%7Bu_%7Bi%2B1%2Cj%7D-u_%7Bi-1%2Cj%7D%7D%7B2%5CDelta%20x%7D%20%2B%20%5Cfrac%7Bv_%7Bi%2Cj%2B1%7D-v_%7Bi%2Cj-1%7D%7D%7B2%5CDelta%20y%7D%20%3D%20%5Cfrac%7Bp_%7Bi%2B1%2Cj%7D%5E%7Bn%7D-2p_%7Bi%2Cj%7D%5E%7Bn%7D%2Bp_%7Bi-1%2Cj%7D%5E%7Bn%7D%7D%7B%5CDelta%20x%5E2%7D%20%2B%20%5Cfrac%7Bp_%7Bi%2Cj%2B1%7D%5E%7Bn%7D-2p_%7Bi%2Cj%7D%5E%7Bn%7D%2Bp_%7Bi%2Cj-1%7D%5E%7Bn%7D%7D%7B%5CDelta%20y%5E2%7D%0A" /></p><p>Generally, implicit discretization of pressure is chosen, so it is necessary to solve a set of linear algebra equations, such as using Jacobi iteration. After solving <img src="https://math.now.sh?inline=p" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, the pressure gradient is applied to the original flow field to obtain the divergence-free velocity field</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cmathbf%7Bu%7D%20%3D%20%5Cmathbf%7Bw%7D%20-%20%5Cnabla%20p%0A" /></p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> CFD </tag>
            
            <tag> PDE </tag>
            
            <tag> Poisson Equation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ libclang 解决变量类型解析失败为 int 的问题</title>
      <link href="/2024/09/04/2024-09-04-libclang_solve_type_name_parsing_error/"/>
      <url>/2024/09/04/2024-09-04-libclang_solve_type_name_parsing_error/</url>
      
        <content type="html"><![CDATA[<p>对于简单的类型声明，libclang 是可以成功解析的。但是对于一些复杂的类型声明，libclang 可能会解析失败。</p><p>比如下面的代码中，<code>m_image_paths</code> 在 <code>TestRefl</code> 中可以被解析出类型为 <code>std::vector&lt;std::string&gt;</code>，但是在 <code>ModelComponent</code> 中就被解析为 <code>int</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;core/reflect/macros.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> [[<span class="built_in">reflectable_class</span>()]] TestRefl</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    [[<span class="built_in">reflectable_field</span>()]]</span><br><span class="line">    std::string test_str;</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">reflectable_field</span>()]]</span><br><span class="line">    std::vector&lt;std::string&gt; m_image_paths;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;core/base/bitmask.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function/object/game_object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function/render/structs/model.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> [[<span class="built_in">reflectable_class</span>()]] ModelComponent : <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UUIDv4::UUID         uuid;</span><br><span class="line">    std::weak_ptr&lt;Model&gt; model_ptr;</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">reflectable_field</span>()]]</span><br><span class="line">    std::string test_str;</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">reflectable_field</span>()]]</span><br><span class="line">    std::vector&lt;std::string&gt; m_image_paths;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ModelComponent</span>(std::vector&lt;<span class="type">float</span>&gt;&amp;&amp;        vertices,</span><br><span class="line">                    std::vector&lt;<span class="type">uint32_t</span>&gt;&amp;&amp;     indices,</span><br><span class="line">                    BitMask&lt;VertexAttributeBit&gt; attributes);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ModelComponent</span>(<span class="type">const</span> std::string&amp; file_path, BitMask&lt;VertexAttributeBit&gt; attributes);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要原因并不是被解析的类型本身有多么复杂，而是复杂的类型会 include 很多头文件，这些头文件的根目录可能并没有传到 <code>clang_parseTranslationUnit</code> 里面，即使是传入了，也可能因为缺少一些宏定义之类的问题导致报错</p><p>我的方法是，用于生成代码的 exe target 直接 include 所有主程序 target include 的第三方库，然后在 cmake 中获取这些依赖，存成字符串，例如下面代码中的 <code>$&#123;INCLUDE_PATH_COLLECTION&#125;</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(get_target_include_directories <span class="keyword">TARGET</span> VAR_NAME)  </span><br><span class="line">    <span class="keyword">set</span>(INCLUDE_DIRS <span class="string">&quot;&quot;</span>)  </span><br><span class="line">    <span class="keyword">get_target_property</span>(TMP_DIRS <span class="variable">$&#123;TARGET&#125;</span> <span class="keyword">INCLUDE_DIRECTORIES</span>)    </span><br><span class="line">    <span class="keyword">foreach</span>(DIR <span class="variable">$&#123;TMP_DIRS&#125;</span>)  </span><br><span class="line">        <span class="comment"># If DIR is a generator expression, there will be no expansion here</span></span><br><span class="line">        <span class="comment"># Here we assume they are direct paths </span></span><br><span class="line">        <span class="keyword">list</span>(APPEND INCLUDE_DIRS <span class="string">&quot;-I$&#123;DIR&#125;&quot;</span>)  </span><br><span class="line">    <span class="keyword">endforeach</span>()   </span><br><span class="line">    <span class="keyword">set</span>(<span class="variable">$&#123;VAR_NAME&#125;</span> <span class="string">&quot;$&#123;INCLUDE_DIRS&#125;&quot;</span> PARENT_SCOPE)  </span><br><span class="line"><span class="keyword">endfunction</span>()  </span><br><span class="line"></span><br><span class="line">get_target_include_directories(<span class="variable">$&#123;CODE_GENERATOR_NAME&#125;</span> INCLUDE_PATH_COLLECTION)  </span><br></pre></td></tr></table></figure><p>然后再把这个获取到的字符串传入用于生成代码的 exe</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    OUTPUT <span class="variable">$&#123;SRC_ROOT_DIR&#125;</span>/runtime/generated/register_all.cpp</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CODE_GENERATOR_NAME&#125;</span> <span class="variable">$&#123;INCLUDE_PATH_COLLECTION&#125;</span> <span class="string">&quot;-S$&#123;SRC_ROOT_DIR&#125;/runtime&quot;</span> <span class="string">&quot;-O$&#123;SRC_ROOT_DIR&#125;/runtime/generated&quot;</span></span><br><span class="line">    DEPENDS <span class="variable">$&#123;HEADER_FILES_DEPEND&#125;</span></span><br><span class="line">    COMMENT <span class="string">&quot;Generating register_all.cpp&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>exe 接受了命令行参数，存成 vector，这个比较简单可以跳过</p><p>最终解析的时候要传入这些参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Parser::ParseFile</span><span class="params">(<span class="type">const</span> fs::path&amp; path, <span class="type">const</span> std::vector&lt;std::string&gt;&amp; include_paths)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// traverse AST to find class</span></span><br><span class="line"></span><br><span class="line">    CXIndex index = <span class="built_in">clang_createIndex</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">all_args</span><span class="params">(<span class="number">3</span> + include_paths.size())</span></span>;</span><br><span class="line">    all_args[<span class="number">0</span>] = <span class="string">&quot;-xc++&quot;</span>;</span><br><span class="line">    all_args[<span class="number">1</span>] = <span class="string">&quot;-std=c++20&quot;</span>;</span><br><span class="line">    all_args[<span class="number">2</span>] = <span class="string">&quot;-DGLM_ENABLE_EXPERIMENTAL&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; include_paths.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        all_args[i + <span class="number">3</span>] = include_paths[i].<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    CXTranslationUnit unit = <span class="built_in">clang_parseTranslationUnit</span>(</span><br><span class="line">        index, path.<span class="built_in">string</span>().<span class="built_in">c_str</span>(), all_args.<span class="built_in">data</span>(), all_args.<span class="built_in">size</span>(), <span class="literal">nullptr</span>, <span class="number">0</span>, CXTranslationUnit_None);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中要注意传入的参数的数量要正确，我就犯过这样的错误</p><p>不过用 <code>vector</code> 来存参数就更省心，直接取 <code>.size()</code></p><p>当然，这可能并不足以消除错误</p><p>为了查看 libclang 解析单元时发生了什么错误，在 cpp 中就可以捕捉到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LibclangUtils::print_diagnostics</span><span class="params">(CXTranslationUnit TU)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> numDiagnostics = <span class="built_in">clang_getNumDiagnostics</span>(TU);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; numDiagnostics; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        CXDiagnostic diag    = <span class="built_in">clang_getDiagnostic</span>(TU, i);</span><br><span class="line">        CXString     diagStr = <span class="built_in">clang_formatDiagnostic</span>(diag, <span class="built_in">clang_defaultDiagnosticDisplayOptions</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Diagnostic %u: %s\n&quot;</span>, i, <span class="built_in">clang_getCString</span>(diagStr));</span><br><span class="line">        <span class="built_in">clang_disposeString</span>(diagStr);</span><br><span class="line">        <span class="built_in">clang_disposeDiagnostic</span>(diag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解析单元之后输出即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CXTranslationUnit unit = <span class="built_in">clang_parseTranslationUnit</span>(</span><br><span class="line">    index, path.<span class="built_in">string</span>().<span class="built_in">c_str</span>(), all_args.<span class="built_in">data</span>(), all_args.<span class="built_in">size</span>(), <span class="literal">nullptr</span>, <span class="number">0</span>, CXTranslationUnit_None);</span><br><span class="line"><span class="keyword">if</span> (unit == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Unable to parse translation unit. Quitting.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LibclangUtils::<span class="built_in">print_diagnostics</span>(unit);</span><br></pre></td></tr></table></figure><p>比如根据这个 diagnostics，报错是找不到 assimp 的 <code>config.h</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: &#x27;assimp/config.h&#x27; file not found</span><br></pre></td></tr></table></figure><p>原因是这个文件是 assimp 构建时生成的。所以我简单地 include assimp 的 include 文件夹时没有用的</p><p>要做的是 include 编译目标中的 assimp 源码的编译结果</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;CODE_GENERATOR_NAME&#125;</span> PUBLIC <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/src/<span class="number">3</span>rdparty/assimp/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p>于是解决了我这份头文件的问题</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Reflection </tag>
            
            <tag> Libclang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 基于静态反射实现序列化 UI 与 IO 以及 Lua 绑定</title>
      <link href="/2024/09/04/2024-09-04-cpp_static_reflection_usage/"/>
      <url>/2024/09/04/2024-09-04-cpp_static_reflection_usage/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了我对 C++ 中静态反射的实现，并展示了我是怎么将静态反射应用在 UI、IO 以及 Lua 绑定的。</p><h2 id="静态反射实现思路">静态反射实现思路</h2><p>我个人的静态反射实现思路是</p><p>使用 <code>LLVM</code> 中的 <code>libclang</code> 解析头文件，识别 cpp 头文件的类型、变量、函数声明中的 <code>attribute</code> 属性</p><p><code>libclang</code> 对传入的每一个头文件的 AST 都执行如下操作：首先记录那些属性为 <code>clang::annotate</code> 的类，然后以这些类为根 cursor 开始遍历。含有 <code>clang::annotate</code> 的字段和方法被记录下来</p><p>已知被反射的类的名称，字段和方法的名称，就可以生成反射代码文件</p><p>主目标中已经写好了 <code>TypeDescriptor</code> 类，<code>TypeDescriptor</code> 类会提供注册反射信息的功能，其中存储字段信息 <code>FieldAccessor</code> 和方法信息 <code>MethodAccessor</code>。生成的反射代码注册反射信息，也就是提取出类的成员变量指针，成员函数指针，存到 lambda 中。这个 lambda 接受 <code>void*</code>，<code>static_cast</code> 成被反射的类型。这样就完成了反射信息在 cpp 中的存储。</p><p>外部使用反射接口时，传入 <code>std::string</code> 类型名称，可以从全局单例的 map 中获得对应的 <code>TypeDescriptor</code>。而已知 <code>TypeDescriptor</code>，就可以获得他其中存储的字段信息 <code>FieldAccessor</code> 和方法信息 <code>MethodAccessor</code> 列表</p><p>向 <code>FieldAccessor</code> <code>MethodAccessor</code> 传入 <code>void*</code> 类型的实例指针，调用存储的 lambda 就能获得这个实例对应的成员和方法的指针</p><p>因为只有 <code>static_cast</code>，所以类型不匹配时会报错中断，程序容错性会很差</p><h2 id="使用-libclang-解析-AST，获取所需信息">使用 libclang 解析 AST，获取所需信息</h2><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Reflection </tag>
            
            <tag> Template programming </tag>
            
            <tag> Serialization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU 视锥体剔除</title>
      <link href="/2024/09/03/2024-09-03-cpu_frustum_culling/"/>
      <url>/2024/09/03/2024-09-03-cpu_frustum_culling/</url>
      
        <content type="html"><![CDATA[<p>抄 <a href="https://github.com/Angelo1211/SoftwareRenderer">https://github.com/Angelo1211/SoftwareRenderer</a> 的视锥体剔除时遇到的一些问题</p><h2 id="代码实现">代码实现</h2><p>这是我转成 glm 的版本</p><p>plane.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Plane</span></span><br><span class="line">&#123;</span><br><span class="line">    glm::vec3 normal;</span><br><span class="line">    <span class="type">float</span>     D;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">distance</span><span class="params">(<span class="type">const</span> glm::vec3&amp; points)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span>  <span class="title">setNormalAndPoint</span><span class="params">(<span class="type">const</span> glm::vec3&amp; normal, <span class="type">const</span> glm::vec3&amp; point)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>plane.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">Plane::distance</span><span class="params">(<span class="type">const</span> glm::vec3&amp; points)</span> </span>&#123; <span class="keyword">return</span> glm::<span class="built_in">dot</span>(normal, points) + D; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Plane::setNormalAndPoint</span><span class="params">(<span class="type">const</span> glm::vec3&amp; n, <span class="type">const</span> glm::vec3&amp; p0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    normal = n;</span><br><span class="line">    D      = -glm::<span class="built_in">dot</span>(n, p0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frustum.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Frustum</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    &#123;</span><br><span class="line">        TOP = <span class="number">0</span>,</span><br><span class="line">        BOTTOM,</span><br><span class="line">        LEFT,</span><br><span class="line">        RIGHT,</span><br><span class="line">        NEARP,</span><br><span class="line">        FARP</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function">    <span class="title">updatePlanes</span><span class="params">(<span class="type">const</span> glm::vec3 cameraPos, <span class="type">const</span> glm::quat rotation, <span class="type">float</span> fovy, <span class="type">float</span> AR, <span class="type">float</span> near, <span class="type">float</span> far)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkIfInside</span><span class="params">(BoundingBox* bounds)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Plane pl[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>frustum.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calculates frustum planes in world space</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Frustum::updatePlanes</span><span class="params">(<span class="type">const</span> glm::vec3 cameraPos,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> glm::quat rotation,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">float</span>           fovy,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">float</span>           AR,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">float</span>           near,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">float</span>           far)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> tanHalfFOVy = <span class="built_in">tan</span>(fovy / <span class="number">2.0f</span>);</span><br><span class="line">    <span class="type">float</span> near_height = near * tanHalfFOVy; <span class="comment">// Half of the frustum near plane height</span></span><br><span class="line">    <span class="type">float</span> near_width  = near_height * AR;</span><br><span class="line"></span><br><span class="line">    glm::vec3 right   = rotation * glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    glm::vec3 forward = rotation * glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    glm::vec3 up      = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gets worlds space position of the center points of the near and far planes</span></span><br><span class="line">    <span class="comment">// The forward vector Z points towards the viewer so you need to negate it and scale it</span></span><br><span class="line">    <span class="comment">// by the distance (near or far) to the plane to get the center positions</span></span><br><span class="line">    glm::vec3 nearCenter = cameraPos + forward * near;</span><br><span class="line">    glm::vec3 farCenter  = cameraPos + forward * far;</span><br><span class="line"></span><br><span class="line">    glm::vec3 point;</span><br><span class="line">    glm::vec3 normal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We build the planes using a normal and a point (in this case the center)</span></span><br><span class="line">    <span class="comment">// Z is negative here because we want the normal vectors we choose to point towards</span></span><br><span class="line">    <span class="comment">// the inside of the view frustum that way we can cehck in or out with a simple</span></span><br><span class="line">    <span class="comment">// Dot product</span></span><br><span class="line">    pl[NEARP].<span class="built_in">setNormalAndPoint</span>(forward, nearCenter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Far plane</span></span><br><span class="line">    pl[FARP].<span class="built_in">setNormalAndPoint</span>(-forward, farCenter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Again, want to get the plane from a normal and point</span></span><br><span class="line">    <span class="comment">// You scale the up vector by the near plane height and added to the nearcenter to</span></span><br><span class="line">    <span class="comment">// optain a point on the edge of both near and top plane.</span></span><br><span class="line">    <span class="comment">// Subtracting the cameraposition from this point generates a vector that goes along the</span></span><br><span class="line">    <span class="comment">// surface of the plane, if you take the cross product with the direction vector equal</span></span><br><span class="line">    <span class="comment">// to the shared edge of the planes you get the normal</span></span><br><span class="line">    point  = nearCenter + up * near_height;</span><br><span class="line">    normal = glm::<span class="built_in">normalize</span>(point - cameraPos);</span><br><span class="line">    normal = glm::<span class="built_in">cross</span>(right, normal);</span><br><span class="line">    pl[TOP].<span class="built_in">setNormalAndPoint</span>(normal, point);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bottom plane</span></span><br><span class="line">    point  = nearCenter - up * near_height;</span><br><span class="line">    normal = glm::<span class="built_in">normalize</span>(point - cameraPos);</span><br><span class="line">    normal = glm::<span class="built_in">cross</span>(normal, right);</span><br><span class="line">    pl[BOTTOM].<span class="built_in">setNormalAndPoint</span>(normal, point);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Left plane</span></span><br><span class="line">    point  = nearCenter - right * near_width;</span><br><span class="line">    normal = glm::<span class="built_in">normalize</span>(point - cameraPos);</span><br><span class="line">    normal = glm::<span class="built_in">cross</span>(up, normal);</span><br><span class="line">    pl[LEFT].<span class="built_in">setNormalAndPoint</span>(normal, point);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Right plane</span></span><br><span class="line">    point  = nearCenter + right * near_width;</span><br><span class="line">    normal = glm::<span class="built_in">normalize</span>(point - cameraPos);</span><br><span class="line">    normal = glm::<span class="built_in">cross</span>(normal, up);</span><br><span class="line">    pl[RIGHT].<span class="built_in">setNormalAndPoint</span>(normal, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// False is fully outside, true if inside or intersects</span></span><br><span class="line"><span class="comment">// based on iquilez method</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Frustum::checkIfInside</span><span class="params">(BoundingBox* box)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Check box outside or inside of frustum</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> out = <span class="number">0</span>;</span><br><span class="line">        out += ((pl[i].<span class="built_in">distance</span>(glm::<span class="built_in">vec3</span>(box-&gt;min.x, box-&gt;min.y, box-&gt;min.z)) &lt; <span class="number">0.0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        out += ((pl[i].<span class="built_in">distance</span>(glm::<span class="built_in">vec3</span>(box-&gt;max.x, box-&gt;min.y, box-&gt;min.z)) &lt; <span class="number">0.0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        out += ((pl[i].<span class="built_in">distance</span>(glm::<span class="built_in">vec3</span>(box-&gt;min.x, box-&gt;max.y, box-&gt;min.z)) &lt; <span class="number">0.0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        out += ((pl[i].<span class="built_in">distance</span>(glm::<span class="built_in">vec3</span>(box-&gt;max.x, box-&gt;max.y, box-&gt;min.z)) &lt; <span class="number">0.0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        out += ((pl[i].<span class="built_in">distance</span>(glm::<span class="built_in">vec3</span>(box-&gt;min.x, box-&gt;min.y, box-&gt;max.z)) &lt; <span class="number">0.0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        out += ((pl[i].<span class="built_in">distance</span>(glm::<span class="built_in">vec3</span>(box-&gt;max.x, box-&gt;min.y, box-&gt;max.z)) &lt; <span class="number">0.0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        out += ((pl[i].<span class="built_in">distance</span>(glm::<span class="built_in">vec3</span>(box-&gt;min.x, box-&gt;max.y, box-&gt;max.z)) &lt; <span class="number">0.0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        out += ((pl[i].<span class="built_in">distance</span>(glm::<span class="built_in">vec3</span>(box-&gt;max.x, box-&gt;max.y, box-&gt;max.z)) &lt; <span class="number">0.0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out == <span class="number">8</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他这个非常好理解</p><p>如果某个包围盒的八个顶点都在某个平面的外侧，那么就确定这个包围盒要被剔除</p><p>如果都不在视锥体 6 个平面的外侧，那么这个不剔除</p><p>我感觉巧妙的是你不用强求获得斜面的中点。而是根据近平面的中点直接沿着 up 或者 right 平移就能得到斜面上的点</p><p>我看到 plane 这个类的时候，我就想到一定要拿到中点，可能是我数学直觉没转过来</p><h2 id="坑">坑</h2><p>第一个坑就是传入的 <code>fovy</code> 需要注意是角度还是弧度</p><p>这个是可以不用 debug 直接看出来怎么错了，因为如果你仅仅是在正对着物体的时候才不剔除，稍微偏一点头，物体都没有走出视口时就被剔除了</p><p>并且剔除的时机很稳定，不会一闪一闪，也就是说不会是公式错了，单纯是你的视锥体比你的视口小</p><p>那么就是某些地方算小了</p><p>第二个坑是获得 up right front 的方式</p><p>之前的分析里面也可以看到了，传入 <code>glm::lookAt</code> 的 front 方向会和 view 中拆出来的 front 方向相反的</p><p>所以如果认为 front 是 +z 的方向……还是自己手动算吧</p><p>第三个坑是算斜面的 normal 的时候，可能会因为手性的问题，导致 normal 算反</p><p>normal 算反在渲染时的表现就是，转动摄像机时，视口内的物体会不断交替剔除，就像在闪烁一样</p><p>正常来说，一个物体在视口内，那么他就是已经在视锥体里面了，所以他不应该闪的</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Grphics </tag>
            
            <tag> Vulkan </tag>
            
            <tag> Culling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL 和 Vulkan 的投影矩阵</title>
      <link href="/2024/09/02/2024-09-02-perspective_matrix_for_opengl_and_vulkan/"/>
      <url>/2024/09/02/2024-09-02-perspective_matrix_for_opengl_and_vulkan/</url>
      
        <content type="html"><![CDATA[<p>Vulkan 只是屏幕坐标系和别人不一样。世界空间，view 空间的手性是用户定义的，想怎么做都行，只要最终保证传入 Vulkan 的 NDC 坐标的手性是对的。也就是说，你可以在计算投影矩阵的时候，注意要转换手性。</p><p>如果没有推导过投影矩阵，就可能不会理解到世界空间，view 空间的手性和 NDC 的手性可以毫无关系——毕竟你不知道有矩阵可以转换手性。</p><h2 id="推导透视矩阵时可能遇到的困难">推导透视矩阵时可能遇到的困难</h2><h3 id="物理过程">物理过程</h3><p>首先要知道变换过程是怎么样的</p><div style="overflow-x: scroll"><div style="width: 1800px"><img src="/images/perspective_matrix_for_opengl_and_vulkan/opengl_pipeline.drawio.svg"></img></div></div><h3 id="物理量的定义">物理量的定义</h3><p>不同的文章对某一个物理量的定义可能不同，但是他们又使用了相同的符号，结果就导致最终的表达式可能差了一个负号</p><p>比如 games101 的推导中，视图空间是右手系，近平面的坐标为 n，远平面的坐标为 f。这说明 n,f 都是负数</p><p>但是在 LearnOpenGL 推荐的贴子 <a href="https://www.songho.ca/opengl/gl_projectionmatrix.html">https://www.songho.ca/opengl/gl_projectionmatrix.html</a> 中，他视图空间是右手系，但定义 n,f 为正，那么近平面的坐标为 -n，远平面的坐标为 -f</p><h3 id="深度的约定">深度的约定</h3><p>创建 <code>vk::PipelineDepthStencilStateCreateInfo</code> 时，我们一般会传入 <code>vk::CompareOp::eLessOrEqual</code> 到 <code>depthCompareOp</code>，表示传入的深度比存储的深度更小时，就通过了测试，写入新的深度。这就表明近处的物体会遮挡远处的物体，符合了 z 的正值越大表示深度越深的习惯。</p><p>用户可以定义用 z 的正值越大表示深度越深，或者是负值越大表示深度越深，也就是说，用户可以定义用 z 轴垂于屏幕朝内或者朝外来表示深度的正半轴</p><p>理论上来说，你不知道 NDC 的 z 轴朝向，你单单讨论屏幕空间的 x 和 y 之间的关系，你是没办法说 NDC 空间的手性的手性如何</p><p>于是当我们看到某些帖子在说 Vulkan 与 OpenGL 的区别在于 y 轴反了，那是默认 z 轴垂于屏幕朝内表示深度的正半轴</p><h3 id="NDC-深度范围与-z-轴反转">NDC 深度范围与 z 轴反转</h3><p>某些细节会影响结果，但是一般的教程不会强调这些细节，因为他们默认你都知道。比如假设近平面的坐标为 n，远平面的坐标为 f 都是负数，那么他要转换到 [-1, 1]，是 n 对应 -1 还是 f 对应 -1？或者是转换到 [0, 1]？都有可能。</p><h3 id="变换到-clip-空间中的坐标的齐次坐标-w-的符号">变换到 clip 空间中的坐标的齐次坐标 w 的符号</h3><p>在推导挤压平截头体的矩阵的时候，齐次坐标的位置可以用 z 或者 -z，都不影响结果，但是结果矩阵会所有元素差一个负号。最终因为要做透视除法，所以每个元素多出来的一个负号和 w 的负号相抵，所以不会导致变换到裁剪空间的结果不同。</p><p>但是这会导致公式中的符号不同，所以可能令人困惑</p><h3 id="为什么-OpenGL-中相机在-eye-空间中看向-z-轴">为什么 OpenGL 中相机在 eye 空间中看向 -z 轴</h3><p>OpenGL 推导透视矩阵时，相机在 eye 空间中是看向 -z 轴，所以视锥体的近平面坐标和远平面坐标都是负数，这是推导透视矩阵公式的基础。那么为什么是看向 -z 轴而不是 +z 轴呢？</p><p>glm 默认的 <code>lookAt</code> 调用的是 <code>glm::lookAtRH</code></p><p>OpenGL 中的构建 view 矩阵的堆栈（来自 <a href="https://learnopengl.com/">https://learnopengl.com/</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view = camera.<span class="built_in">GetViewMatrix</span>();</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::mat4 <span class="title">GetViewMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> glm::<span class="built_in">lookAt</span>(Position, Position + Front, Up);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateCameraVectors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// calculate the new Front vector</span></span><br><span class="line">    glm::vec3 front;</span><br><span class="line">    front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">    front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">    front.z = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(Yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(Pitch));</span><br><span class="line">    Front = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">    <span class="comment">// also re-calculate the Right and Up vector</span></span><br><span class="line">    Right = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Front, WorldUp));  <span class="comment">// normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement.</span></span><br><span class="line">    Up    = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(Right, Front));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我们知道了，传入 <code>lookAtRH</code> 的期望是摄像机看向 <code>Front</code> 的指向</p><p>但是为什么反而在 eye 空间中却看向 -z 轴呢？按道理来说，乘以 view 矩阵之后，整个世界都被转到相机面向物体的坐标系中了呀？现在你推导透视矩阵时反而认为相机背向物体？</p><p>所以这个事情还是要看 <code>lookAtRH</code> 是怎么做的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, qualifier Q&gt;</span></span><br><span class="line"><span class="function">GLM_FUNC_QUALIFIER mat&lt;4, 4, T, Q&gt; <span class="title">lookAtRH</span><span class="params">(vec&lt;<span class="number">3</span>, T, Q&gt; <span class="type">const</span>&amp; eye, vec&lt;<span class="number">3</span>, T, Q&gt; <span class="type">const</span>&amp; center, vec&lt;<span class="number">3</span>, T, Q&gt; <span class="type">const</span>&amp; up)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">vec&lt;3, T, Q&gt; <span class="type">const</span> <span class="title">f</span><span class="params">(normalize(center - eye))</span></span>;</span><br><span class="line">  <span class="function">vec&lt;3, T, Q&gt; <span class="type">const</span> <span class="title">s</span><span class="params">(normalize(cross(f, up)))</span></span>;</span><br><span class="line">  <span class="function">vec&lt;3, T, Q&gt; <span class="type">const</span> <span class="title">u</span><span class="params">(cross(s, f))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">mat&lt;4, 4, T, Q&gt; <span class="title">Result</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  Result[<span class="number">0</span>][<span class="number">0</span>] = s.x;</span><br><span class="line">  Result[<span class="number">1</span>][<span class="number">0</span>] = s.y;</span><br><span class="line">  Result[<span class="number">2</span>][<span class="number">0</span>] = s.z;</span><br><span class="line">  Result[<span class="number">0</span>][<span class="number">1</span>] = u.x;</span><br><span class="line">  Result[<span class="number">1</span>][<span class="number">1</span>] = u.y;</span><br><span class="line">  Result[<span class="number">2</span>][<span class="number">1</span>] = u.z;</span><br><span class="line">  Result[<span class="number">0</span>][<span class="number">2</span>] =-f.x;</span><br><span class="line">  Result[<span class="number">1</span>][<span class="number">2</span>] =-f.y;</span><br><span class="line">  Result[<span class="number">2</span>][<span class="number">2</span>] =-f.z;</span><br><span class="line">  Result[<span class="number">3</span>][<span class="number">0</span>] =-<span class="built_in">dot</span>(s, eye);</span><br><span class="line">  Result[<span class="number">3</span>][<span class="number">1</span>] =-<span class="built_in">dot</span>(u, eye);</span><br><span class="line">  Result[<span class="number">3</span>][<span class="number">2</span>] = <span class="built_in">dot</span>(f, eye);</span><br><span class="line">  <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，其实返回的 view 空间的 z 轴是 -front</p><p>但是明明 front 是指向物体的，所以 view 变换之后，摄像机就背向了物体，摄像机的 -z 指向物体</p><p>所以这就说明了 lookAt 矩阵表示的 z 轴他不一定是传入的 front</p><h3 id="lookAt-怎么与透视矩阵对应">lookAt 怎么与透视矩阵对应</h3><p>我不止一次看到别人推荐这个网站 <a href="https://www.songho.ca/opengl/gl_projectionmatrix.html">https://www.songho.ca/opengl/gl_projectionmatrix.html</a>，然后引用这句话</p><blockquote><p>Note that the eye coordinates are defined in the right-handed coordinate system, but NDC uses the left-handed coordinate system. That is, the camera at the origin is looking along -Z axis in eye space, but it is looking along +Z axis in NDC.</p></blockquote><p>他的意思似乎是，因为 NDC 是左手系，view 空间（eye 空间）是右手系，所以 x 和 y 轴不变的话，就可以认为两者的 z 轴是反的。那么假设视锥体都在一个固定的 NDC 正 z 的地方，那么我在 NDC 中需要看向这个视锥体，所以我在 view 空间中才需要让我的摄像机看向 -z 方向而不是 +z</p><p>当然这是一个倒因为果……并不是因为透视矩阵是这样，视图矩阵才是这样</p><p>而是因为首先你知道了，经过 lookAt 之后，摄像机看向了 -z，所以透视矩阵中注意对 z 反转，使得 NDC 中摄像机看向 +z</p><p>网上大部分教程以及评论都默认你右手系并且用的是 <code>glm::lookAt</code>，这确保了摄像机在 eye 空间中却看向 -z 轴</p><p>原则上你用什么 lookAt 都可以，但是你对应的投影矩阵的公式也要跟着变</p><p>现在大家用的都是 glm 的 lookAt，所以我觉得还是入乡随俗</p><h2 id="从-Games101-的公式开始">从 Games101 的公式开始</h2><p>先假设世界空间，视图空间是右手系</p><p>视图空间中有一个正交长方体的左平面的坐标为 l，右平面的坐标为 r，上平面的坐标为 t，下平面的坐标为 b，近平面的坐标为 n，远平面的坐标为 f</p><p>现在希望转成一个 NDC 标准坐标</p><p>那么 games101 是</p><p><img src="https://math.now.sh?inline=M_%7Bortho%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cfrac%7B2%7D%7Br-l%7D%20%26%200%20%26%200%20%26%200%5C%5C%0A0%20%26%20%5Cfrac%7B2%7D%7Bt-b%7D%20%26%200%20%26%200%5C%5C%0A0%20%26%200%20%26%20%5Cfrac%7B2%7D%7Bn-f%7D%20%26%200%5C%5C%0A0%20%26%200%20%26%200%20%26%201%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bcccc%7D%0A1%20%26%200%20%26%200%20%26%20-%5Cfrac%7Br%2Bl%7D%7B2%7D%5C%5C%0A0%20%26%201%20%26%200%20%26%20-%5Cfrac%7Bt%2Bb%7D%7B2%7D%5C%5C%0A0%20%26%200%20%26%201%20%26%20-%5Cfrac%7Bn%2Bf%7D%7B2%7D%5C%5C%0A0%20%26%200%20%26%200%20%26%201%0A%5Cend%7Barray%7D%5Cright)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>注意，这个公式把 [f, n] 转成 [-1, 1] 的，那么原来是 f 比 n 小，现在也是 -1 比 1 小，所以没有改变手性</p><p>frustum 的关系式是</p><p><img src="https://math.now.sh?inline=x'%20%3D%20n%2Fz*x" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=y'%20%3D%20n%2Fz*y" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>因此设计一个 frustum 挤压成正交长方体的矩阵，使得变换出来的 <img src="https://math.now.sh?inline=x%2Cy%2Cw" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> 的部分与这个关系式对应。对应的方法就是使得齐次坐标 <img src="https://math.now.sh?inline=w" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> 的位置放关系式的分母，也就是 <img src="https://math.now.sh?inline=z" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0An%20%26%200%20%26%200%20%26%200%5C%5C%0A0%20%26%20n%20%26%200%20%26%200%5C%5C%0Aa_1%20%26%20a_2%20%26%20a_3%20%26%20a_4%5C%5C%0A0%20%26%200%20%26%201%20%26%200%0A%5Cend%7Barray%7D%5Cright%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%0Ax%5C%5C%0Ay%5C%5C%0Az%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0Anx%5C%5C%0Any%5C%5C%0A%3F%5C%5C%0Az%0A%5Cend%7Barray%7D%5Cright)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>为了求解未知数，有两个关系，一个是近平面上的点在压缩时不变，另一个是远平面的中心点在压缩时不变</p><p>单独看“近平面上的点在压缩时不变”，这使得</p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%0Ax%5C%5C%0Ay%5C%5C%0An%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0Anx%5C%5C%0Any%5C%5C%0An%5E2%5C%5C%0An%0A%5Cend%7Barray%7D%5Cright)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>对任意 x,y 成立</p><p>那么可以证出 <img src="https://math.now.sh?inline=a_1%2Ca_2" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> 都是 0，因为 <img src="https://math.now.sh?inline=n%5E2" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=x%2Cy" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> 无关</p><p>那么取近平面的中心点不变和远平面的中心点不变，得到两个式子</p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%0A0%5C%5C%0A0%5C%5C%0An%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A0%5C%5C%0A0%5C%5C%0An%5E2%5C%5C%0An%0A%5Cend%7Barray%7D%5Cright)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%0A0%5C%5C%0A0%5C%5C%0Af%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A0%5C%5C%0A0%5C%5C%0Af%5E2%5C%5C%0Af%0A%5Cend%7Barray%7D%5Cright)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>即</p><p><img src="https://math.now.sh?inline=a_3%20n%20%2B%20a_4%20%3D%20n%5E2" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br><img src="https://math.now.sh?inline=a_3%20f%20%2B%20a_4%20%3D%20f%5E2" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>解得</p><p><img src="https://math.now.sh?inline=a_3%20%3D%20n%2Bf%2C%20a_4%20%3D%20-nf" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>最终结果</p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0An%20%26%200%20%26%200%20%26%200%5C%5C%0A0%20%26%20n%20%26%200%20%26%200%5C%5C%0A0%20%26%200%20%26%20f%2Bn%20%26%20-f%5C%2Cn%5C%5C%0A0%20%26%200%20%26%201%20%26%200%0A%5Cend%7Barray%7D%5Cright%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>两者相乘可以得到</p><p><img src="https://math.now.sh?inline=M_%7Bproj%7D%20%3D%20M_%7Bortho%7D%20*%20M_%7Bpersp2ortho%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cfrac%7B2%5C%2Cn%7D%7Br-l%7D%20%26%200%20%26%20%5Cfrac%7Bl%2Br%7D%7Bl-r%7D%20%26%200%5C%5C%0A0%20%26%20%5Cfrac%7B2%5C%2Cn%7D%7Bt-b%7D%20%26%20%5Cfrac%7Bb%2Bt%7D%7Bb-t%7D%20%26%200%5C%5C%0A0%20%26%200%20%26%20-%5Cfrac%7Bf%2Bn%7D%7Bf-n%7D%20%26%20%5Cfrac%7B2%5C%2Cf%5C%2Cn%7D%7Bf-n%7D%5C%5C%0A0%20%26%200%20%26%201%20%26%200%0A%5Cend%7Barray%7D%5Cright%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>进行这个投影变换之后，原来是右手坐标的视图空间变为右手坐标的裁剪空间</p><h2 id="考虑-OpenGL">考虑 OpenGL</h2><p>OpenGL 的公式中要求 n,f 都是距离，所以都是正值</p><p>那么近平面是 -n，远平面是 -f</p><p>又要求变换之后是左手系，也就是 [-n, -f] 变换到 [-1, 1]</p><p>那么正交投影矩阵</p><p><img src="https://math.now.sh?inline=M_%7Bortho%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cfrac%7B2%7D%7Br-l%7D%20%26%200%20%26%200%20%26%200%5C%5C%0A0%20%26%20%5Cfrac%7B2%7D%7Bt-b%7D%20%26%200%20%26%200%5C%5C%0A0%20%26%200%20%26%20%5Cfrac%7B2%7D%7Bn-f%7D%20%26%200%5C%5C%0A0%20%26%200%20%26%200%20%26%201%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bcccc%7D%0A1%20%26%200%20%26%200%20%26%20-%5Cfrac%7Br%2Bl%7D%7B2%7D%5C%5C%0A0%20%26%201%20%26%200%20%26%20-%5Cfrac%7Bt%2Bb%7D%7B2%7D%5C%5C%0A0%20%26%200%20%26%201%20%26%20%5Cfrac%7Bf%2Bn%7D%7B2%7D%5C%5C%0A0%20%26%200%20%26%200%20%26%201%0A%5Cend%7Barray%7D%5Cright)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>frustum 的关系式是</p><p><img src="https://math.now.sh?inline=x'%20%3D%20-n%2Fz*x" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br><img src="https://math.now.sh?inline=y'%20%3D%20-n%2Fz*y" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>因为这里的 z 是负值，所以要加负号表示距离</p><p>设计压缩矩阵</p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0A-n%20%26%200%20%26%200%20%26%200%5C%5C%0A0%20%26%20-n%20%26%200%20%26%200%5C%5C%0A0%20%26%200%20%26%20a_3%20%26%20a_4%5C%5C%0A0%20%26%200%20%26%201%20%26%200%0A%5Cend%7Barray%7D%5Cright%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%0Ax%5C%5C%0Ay%5C%5C%0Az%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A-nx%5C%5C%0A-ny%5C%5C%0A%3F%5C%5C%0Az%0A%5Cend%7Barray%7D%5Cright)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>那么取近平面的中心点不变和远平面的中心点不变，得到两个式子</p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%0A0%5C%5C%0A0%5C%5C%0A-n%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A0%5C%5C%0A0%5C%5C%0An%5E2%5C%5C%0A-n%0A%5Cend%7Barray%7D%5Cright)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%0A0%5C%5C%0A0%5C%5C%0A-f%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A0%5C%5C%0A0%5C%5C%0Af%5E2%5C%5C%0A-f%0A%5Cend%7Barray%7D%5Cright)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>即</p><p><img src="https://math.now.sh?inline=-a_3%20n%20%2B%20a_4%20%3D%20n%5E2" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br><img src="https://math.now.sh?inline=-a_3%20f%20%2B%20a_4%20%3D%20f%5E2" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>解得</p><p><img src="https://math.now.sh?inline=a_3%20%3D%20-%28n%2Bf%29%2C%20a_4%20%3D%20-nf" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>最终结果</p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0A-n%20%26%200%20%26%200%20%26%200%5C%5C%0A0%20%26%20-n%20%26%200%20%26%200%5C%5C%0A0%20%26%200%20%26%20-(f%2Bn%29%20%26%20-f%5C%2Cn%5C%5C%0A0%20%26%200%20%26%201%20%26%200%0A%5Cend%7Barray%7D%5Cright)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>两者相乘可以得到</p><p><img src="https://math.now.sh?inline=M_%7Bproj%7D%20%3D%20M_%7Bortho%7D%20*%20M_%7Bpersp2ortho%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cfrac%7B2%5C%2Cn%7D%7Bl-r%7D%20%26%200%20%26%20%5Cfrac%7Bl%2Br%7D%7Bl-r%7D%20%26%200%5C%5C%0A0%20%26%20%5Cfrac%7B2%5C%2Cn%7D%7Bb-t%7D%20%26%20%5Cfrac%7Bb%2Bt%7D%7Bb-t%7D%20%26%200%5C%5C%0A0%20%26%200%20%26%20%5Cfrac%7Bf%2Bn%7D%7Bf-n%7D%20%26%20%5Cfrac%7B2%5C%2Cf%5C%2Cn%7D%7Bf-n%7D%5C%5C%0A0%20%26%200%20%26%201%20%26%200%0A%5Cend%7Barray%7D%5Cright%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>但是还是和 OpenGL 的公式搭不上</p><p><img src="https://math.now.sh?inline=M_%7Bproj%7D%20%3D%20M_%7Bortho%7D%20*%20M_%7Bpersp2ortho%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cfrac%7B2%5C%2Cn%7D%7Br-l%7D%20%26%200%20%26%20%5Cfrac%7Bl%2Br%7D%7Br-l%7D%20%26%200%5C%5C%0A0%20%26%20%5Cfrac%7B2%5C%2Cn%7D%7Bt-b%7D%20%26%20%5Cfrac%7Bb%2Bt%7D%7Bt-b%7D%20%26%200%5C%5C%0A0%20%26%200%20%26%20-%5Cfrac%7Bf%2Bn%7D%7Bf-n%7D%20%26%20-%5Cfrac%7B2%5C%2Cf%5C%2Cn%7D%7Bf-n%7D%5C%5C%0A0%20%26%200%20%26%20-1%20%26%200%0A%5Cend%7Barray%7D%5Cright%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>观察发现我自己推出来的矩阵乘以 -1 就是 OpenGL 的公式</p><p>于是说……这两个矩阵的结果会是一样的吗</p><p>之后看了 <a href="https://www.zhyingkun.com/perspective/perspective/">https://www.zhyingkun.com/perspective/perspective/</a></p><p>才确认了别人也遇到了这个问题，并且他们会是一样的</p><p>重新推一下，frustum 的关系式是</p><p><img src="https://math.now.sh?inline=x'%20%3D%20n%2F%28-z%29*x" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br><img src="https://math.now.sh?inline=y'%20%3D%20n%2F%28-z%29*y" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>设计压缩矩阵</p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0An%20%26%200%20%26%200%20%26%200%5C%5C%0A0%20%26%20n%20%26%200%20%26%200%5C%5C%0A0%20%26%200%20%26%20a_3%20%26%20a_4%5C%5C%0A0%20%26%200%20%26%20-1%20%26%200%0A%5Cend%7Barray%7D%5Cright%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%0Ax%5C%5C%0Ay%5C%5C%0Az%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0Anx%5C%5C%0Any%5C%5C%0A%3F%5C%5C%0A-z%0A%5Cend%7Barray%7D%5Cright)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>那么取近平面的中心点不变和远平面的中心点不变，得到两个式子</p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%0A0%5C%5C%0A0%5C%5C%0A-n%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A0%5C%5C%0A0%5C%5C%0A-n%5E2%5C%5C%0An%0A%5Cend%7Barray%7D%5Cright)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%0A0%5C%5C%0A0%5C%5C%0A-f%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A0%5C%5C%0A0%5C%5C%0A-f%5E2%5C%5C%0Af%0A%5Cend%7Barray%7D%5Cright)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>即</p><p><img src="https://math.now.sh?inline=-a_3%20n%20%2B%20a_4%20%3D%20-n%5E2" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/><br><img src="https://math.now.sh?inline=-a_3%20f%20%2B%20a_4%20%3D%20-f%5E2" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>解得</p><p><img src="https://math.now.sh?inline=a_3%20%3D%20n%2Bf%2C%20a_4%20%3D%20nf" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>最终结果</p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0An%20%26%200%20%26%200%20%26%200%5C%5C%0A0%20%26%20n%20%26%200%20%26%200%5C%5C%0A0%20%26%200%20%26%20f%2Bn%20%26%20f%5C%2Cn%5C%5C%0A0%20%26%200%20%26%20-1%20%26%200%0A%5Cend%7Barray%7D%5Cright%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>That’s all. 可以看到投影矩阵和之前的差在乘以一个负号，最终算出来的就是 OpenGL 的公式了。</p><p>glm 的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">GLM_FUNC_QUALIFIER mat&lt;4, 4, T, defaultp&gt; <span class="title">perspectiveRH_NO</span><span class="params">(T fovy, T aspect, T zNear, T zFar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">abs</span>(aspect - std::numeric_limits&lt;T&gt;::<span class="built_in">epsilon</span>()) &gt; <span class="built_in">static_cast</span>&lt;T&gt;(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  T <span class="type">const</span> tanHalfFovy = <span class="built_in">tan</span>(fovy / <span class="built_in">static_cast</span>&lt;T&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">  <span class="function">mat&lt;4, 4, T, defaultp&gt; <span class="title">Result</span><span class="params">(<span class="keyword">static_cast</span>&lt;T&gt;(<span class="number">0</span>))</span></span>;</span><br><span class="line">  Result[<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">static_cast</span>&lt;T&gt;(<span class="number">1</span>) / (aspect * tanHalfFovy);</span><br><span class="line">  Result[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">static_cast</span>&lt;T&gt;(<span class="number">1</span>) / (tanHalfFovy);</span><br><span class="line">  Result[<span class="number">2</span>][<span class="number">2</span>] = - (zFar + zNear) / (zFar - zNear);</span><br><span class="line">  Result[<span class="number">2</span>][<span class="number">3</span>] = - <span class="built_in">static_cast</span>&lt;T&gt;(<span class="number">1</span>);</span><br><span class="line">  Result[<span class="number">3</span>][<span class="number">2</span>] = - (<span class="built_in">static_cast</span>&lt;T&gt;(<span class="number">2</span>) * zFar * zNear) / (zFar - zNear);</span><br><span class="line">  <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Matlab 代入我推的公式</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syms zNear zFar width height fovy aspect;  </span><br><span class="line"></span><br><span class="line"><span class="comment">% world space is right hand</span></span><br><span class="line"><span class="comment">% zNear &gt; 0, zFar &gt; 0</span></span><br><span class="line">n = zNear;  </span><br><span class="line">f = zFar;  </span><br><span class="line"></span><br><span class="line">tanHalfFovy = <span class="built_in">tan</span>(fovy/<span class="number">2</span>);  </span><br><span class="line">height = <span class="number">2</span> * n * tanHalfFovy;</span><br><span class="line">width = aspect * height;  </span><br><span class="line">  </span><br><span class="line">r = width/<span class="number">2</span>;  </span><br><span class="line">l = -width/<span class="number">2</span>;</span><br><span class="line">t = height/<span class="number">2</span>;  </span><br><span class="line">b = -height/<span class="number">2</span>;  </span><br><span class="line">  </span><br><span class="line">Mortho = [<span class="number">2</span>/(r-l) <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">2</span>/(t-b) <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">2</span>/(n-f) <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>] * [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> -(r+l)/<span class="number">2</span>; <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> -(t+b)/<span class="number">2</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> (n+f)/<span class="number">2</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">Mortho = simplify(Mortho);</span><br><span class="line">Mpersp2ortho = [n <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> n <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> (n+f) n*f; <span class="number">0</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span>];</span><br><span class="line">Mproj = Mortho * Mpersp2ortho;</span><br><span class="line">Mproj = simplify(Mproj)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到的结果一样</p><p><img src="https://math.now.sh?inline=M_%7Bproj%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cfrac%7B1%7D%7B%5Cmathrm%7Baspect%7D%5C%2C%5Ctan%20%5Cleft(%5Cfrac%7B%5Cmathrm%7Bfovy%7D%7D%7B2%7D%5Cright%29%7D%20%26%200%20%26%200%20%26%200%5C%5C%0A0%20%26%20%5Cfrac%7B1%7D%7B%5Ctan%20%5Cleft(%5Cfrac%7B%5Cmathrm%7Bfovy%7D%7D%7B2%7D%5Cright)%7D%20%26%200%20%26%200%5C%5C%0A0%20%26%200%20%26%20-%5Cfrac%7B%5Cmathrm%7BzFar%7D%2B%5Cmathrm%7BzNear%7D%7D%7B%5Cmathrm%7BzFar%7D-%5Cmathrm%7BzNear%7D%7D%20%26%20-%5Cfrac%7B2%5C%2C%5Cmathrm%7BzFar%7D%5C%2C%5Cmathrm%7BzNear%7D%7D%7B%5Cmathrm%7BzFar%7D-%5Cmathrm%7BzNear%7D%7D%5C%5C%0A0%20%26%200%20%26%20-1%20%26%200%0A%5Cend%7Barray%7D%5Cright)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>这就是所谓的齐次坐标里面放 z 还是 -z 会导致的公式的不同</p><p>这一点不会导致结果不同</p><h2 id="用于-Vulkan-的透视矩阵">用于 Vulkan 的透视矩阵</h2><p>视图矩阵是右手系，正交长方体的左平面的坐标为 l，右平面的坐标为 r，上平面的坐标为 t，下平面的坐标为 b，近平面的坐标为 -n，远平面的坐标为 -f。转换之后 NDC 坐标还是右手系。</p><p>n, f 为正</p><p>[b, t] 映射到 [1, -1], [-n, -f] 映射到 [0, 1]</p><p><img src="https://math.now.sh?inline=%0AM_%7Bortho%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cfrac%7B2%7D%7Br-l%7D%20%26%200%20%26%200%20%26%200%5C%5C%0A0%20%26%20%5Cfrac%7B2%7D%7Bb-t%7D%20%26%200%20%26%200%5C%5C%0A0%20%26%200%20%26%20%5Cfrac%7B1%7D%7Bn-f%7D%20%26%200%5C%5C%0A0%20%26%200%20%26%200%20%26%201%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bcccc%7D%0A1%20%26%200%20%26%200%20%26%20-%5Cfrac%7Br%2Bl%7D%7B2%7D%5C%5C%0A0%20%26%201%20%26%200%20%26%20-%5Cfrac%7Bt%2Bb%7D%7B2%7D%5C%5C%0A0%20%26%200%20%26%201%20%26%20n%5C%5C%0A0%20%26%200%20%26%200%20%26%201%0A%5Cend%7Barray%7D%5Cright)%0A" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>沿用之前推 OpenGL 推出来的压缩矩阵</p><p><img src="https://math.now.sh?inline=M_%7Bpersp2ortho%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0An%20%26%200%20%26%200%20%26%200%5C%5C%0A0%20%26%20n%20%26%200%20%26%200%5C%5C%0A0%20%26%200%20%26%20f%2Bn%20%26%20f%5C%2Cn%5C%5C%0A0%20%26%200%20%26%20-1%20%26%200%0A%5Cend%7Barray%7D%5Cright%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>Matlab 代入</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syms zNear zFar width height fovy aspect;  </span><br><span class="line"></span><br><span class="line"><span class="comment">% world space is right hand</span></span><br><span class="line"><span class="comment">% zNear &gt; 0, zFar &gt; 0</span></span><br><span class="line">n = zNear;  </span><br><span class="line">f = zFar;  </span><br><span class="line"></span><br><span class="line">tanHalfFovy = <span class="built_in">tan</span>(fovy/<span class="number">2</span>);  </span><br><span class="line">height = <span class="number">2</span> * n * tanHalfFovy;</span><br><span class="line">width = aspect * height;  </span><br><span class="line">  </span><br><span class="line">r = width/<span class="number">2</span>;  </span><br><span class="line">l = -width/<span class="number">2</span>;</span><br><span class="line">t = height/<span class="number">2</span>;  </span><br><span class="line">b = -height/<span class="number">2</span>;  </span><br><span class="line">  </span><br><span class="line">Mortho = [<span class="number">2</span>/(r-l) <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">2</span>/(b-t) <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>/(n-f) <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>] * [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> -(r+l)/<span class="number">2</span>; <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> -(t+b)/<span class="number">2</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> n; <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">Mortho = simplify(Mortho);</span><br><span class="line">Mpersp2ortho = [n <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> n <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> (n+f) n*f; <span class="number">0</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span>];</span><br><span class="line">Mproj = Mortho * Mpersp2ortho;</span><br><span class="line">Mproj = simplify(Mproj)</span><br></pre></td></tr></table></figure><p>Matlab 结果</p><p><img src="https://math.now.sh?inline=M_%7Bproj%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cfrac%7B1%7D%7B%5Cmathrm%7Baspect%7D%5C%2C%5Ctan%20%5Cleft(%5Cfrac%7B%5Cmathrm%7Bfovy%7D%7D%7B2%7D%5Cright%29%7D%20%26%200%20%26%200%20%26%200%5C%5C%0A0%20%26%20-%5Cfrac%7B1%7D%7B%5Ctan%20%5Cleft(%5Cfrac%7B%5Cmathrm%7Bfovy%7D%7D%7B2%7D%5Cright)%7D%20%26%200%20%26%200%5C%5C%0A0%20%26%200%20%26%20-%5Cfrac%7B%5Cmathrm%7BzFar%7D%7D%7B%5Cmathrm%7BzFar%7D-%5Cmathrm%7BzNear%7D%7D%20%26%20-%5Cfrac%7B%5Cmathrm%7BzFar%7D%5C%2C%5Cmathrm%7BzNear%7D%7D%7B%5Cmathrm%7BzFar%7D-%5Cmathrm%7BzNear%7D%7D%5C%5C%0A0%20%26%200%20%26%20-1%20%26%200%0A%5Cend%7Barray%7D%5Cright)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>得到的结果与 <code>perspectiveRH_ZO</code> 确实仅仅在 [1][1] 差一个负号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">GLM_FUNC_QUALIFIER mat&lt;4, 4, T, defaultp&gt; <span class="title">perspectiveRH_ZO</span><span class="params">(T fovy, T aspect, T zNear, T zFar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">abs</span>(aspect - std::numeric_limits&lt;T&gt;::<span class="built_in">epsilon</span>()) &gt; <span class="built_in">static_cast</span>&lt;T&gt;(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  T <span class="type">const</span> tanHalfFovy = <span class="built_in">tan</span>(fovy / <span class="built_in">static_cast</span>&lt;T&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">  <span class="function">mat&lt;4, 4, T, defaultp&gt; <span class="title">Result</span><span class="params">(<span class="keyword">static_cast</span>&lt;T&gt;(<span class="number">0</span>))</span></span>;</span><br><span class="line">  Result[<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">static_cast</span>&lt;T&gt;(<span class="number">1</span>) / (aspect * tanHalfFovy);</span><br><span class="line">  Result[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">static_cast</span>&lt;T&gt;(<span class="number">1</span>) / (tanHalfFovy);</span><br><span class="line">  Result[<span class="number">2</span>][<span class="number">2</span>] = zFar / (zNear - zFar);</span><br><span class="line">  Result[<span class="number">2</span>][<span class="number">3</span>] = - <span class="built_in">static_cast</span>&lt;T&gt;(<span class="number">1</span>);</span><br><span class="line">  Result[<span class="number">3</span>][<span class="number">2</span>] = -(zFar * zNear) / (zFar - zNear);</span><br><span class="line">  <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果仅仅就这么用了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 forward = transfrom_comp_ptr-&gt;rotation * glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">glm::mat4 view    = glm::<span class="built_in">lookAt</span>(</span><br><span class="line">    transfrom_comp_ptr-&gt;position, transfrom_comp_ptr-&gt;position + forward, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"></span><br><span class="line">ubo_data.view       = view;</span><br><span class="line">ubo_data.projection = glm::<span class="built_in">perspectiveRH_ZO</span>(camera_comp_ptr-&gt;field_of_view,</span><br><span class="line">                                            (<span class="type">float</span>)window_size[<span class="number">0</span>] / (<span class="type">float</span>)window_size[<span class="number">1</span>],</span><br><span class="line">                                            camera_comp_ptr-&gt;near_plane,</span><br><span class="line">                                            camera_comp_ptr-&gt;far_plane);</span><br><span class="line">ubo_data.projection[<span class="number">1</span>][<span class="number">1</span>] *= <span class="number">-1.f</span>;</span><br></pre></td></tr></table></figure><p>还会有 x 轴反转的问题</p><p>这个确实……有点难以思考原因。我觉得可能还是因为反转了 z 轴的问题。</p><p>于是最终还是自己抄了一个透视矩阵，其中与 <code>glm::perspectiveRH_ZO</code> 的区别就是反转了 x 轴，然后用 viewport 负高度，front 设置为 <code>vk::FrontFace::eClockwise</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> glm::mat4 <span class="title">perspective_vk</span><span class="params">(<span class="type">float</span> fovy, <span class="type">float</span> aspect, <span class="type">float</span> zNear, <span class="type">float</span> zFar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">abs</span>(aspect - std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">epsilon</span>()) &gt; <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="type">const</span> tanHalfFovy = <span class="built_in">tan</span>(fovy / <span class="number">2.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">Result</span><span class="params">(<span class="number">0.0f</span>)</span></span>;</span><br><span class="line">    Result[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">-1.0f</span> / (aspect * tanHalfFovy);</span><br><span class="line">    Result[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1.0f</span> / (tanHalfFovy);</span><br><span class="line">    Result[<span class="number">2</span>][<span class="number">2</span>] = zFar / (zNear - zFar);</span><br><span class="line">    Result[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">-1.0f</span>;</span><br><span class="line">    Result[<span class="number">3</span>][<span class="number">2</span>] = -(zFar * zNear) / (zFar - zNear);</span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样是可以 work，也可以保证用的是 glm 的 view 空间，也是基于 glm 的透视矩阵改的，我觉得还 ok</p><p>别人也会有类似的 x 轴翻转的问题</p><p><a href="https://stackoverflow.com/questions/65049297/perspective-projection-inverting-x-axis-glmperspective">https://stackoverflow.com/questions/65049297/perspective-projection-inverting-x-axis-glmperspective</a></p><p><a href="https://stackoverflow.com/questions/78557339/glmlookat-image-is-visually-flipped-both-x-and-y-axis">https://stackoverflow.com/questions/78557339/glmlookat-image-is-visually-flipped-both-x-and-y-axis</a></p><p>但是我脑子有限不知道怎么办</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Grphics </tag>
            
            <tag> Vulkan </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 多维数组的性能测试</title>
      <link href="/2024/07/21/2024-07-21-cpp_multiple_dimensional_array/"/>
      <url>/2024/07/21/2024-07-21-cpp_multiple_dimensional_array/</url>
      
        <content type="html"><![CDATA[<p>开发 CFD 求解器的时候，需要使用三维数组来表示结构网格。我希望这个三维数组的内存是连续的，所以我分配了三维空间大小的线性内存。需要使用三维坐标来访问数组时，人为计算一维索引。这自然就引出了一个问题：这样做会带来性能损失吗？如果有，损失多少？</p><p>测试代码见 <a href="https://github.com/CheapMeow/test-mdspan">https://github.com/CheapMeow/test-mdspan</a></p><h2 id="不同的实现">不同的实现</h2><p>第一个最简单的实现就是，分配一维连续数组，三维坐标转化为一维索引</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">field3_1dp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Nx, Ny, Nz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span>* value = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">field3_1dp</span>(<span class="type">unsigned</span> <span class="type">int</span> _Nx, <span class="type">unsigned</span> <span class="type">int</span> _Ny, <span class="type">unsigned</span> <span class="type">int</span> _Nz)</span><br><span class="line">        : <span class="built_in">Nx</span>(_Nx)</span><br><span class="line">        , <span class="built_in">Ny</span>(_Ny)</span><br><span class="line">        , <span class="built_in">Nz</span>(_Nz)</span><br><span class="line">    &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="type">double</span>[Nx * Ny * Nz];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; Nx * Ny * Nz; i++)</span><br><span class="line">            value[i] = <span class="number">0.</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">field3_1dp</span>() &#123; <span class="keyword">delete</span>[] value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> i, <span class="type">unsigned</span> <span class="type">int</span> j, <span class="type">unsigned</span> <span class="type">int</span> k)</span> </span>&#123; <span class="keyword">return</span> value[i * Ny * Nz + j * Nz + k]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SizeX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Nx; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SizeY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Ny; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SizeZ</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Nz; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了加速一维索引的计算，可以使用模板来将维度参数固定为字面值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> <span class="type">int</span> Nx, <span class="type">unsigned</span> <span class="type">int</span> Ny, <span class="type">unsigned</span> <span class="type">int</span> Nz&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">field3_1dp_t</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span>* value = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">field3_1dp_t</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="type">double</span>[Nx * Ny * Nz];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; Nx * Ny * Nz; i++)</span><br><span class="line">            value[i] = <span class="number">0.</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">field3_1dp_t</span>() &#123; <span class="keyword">delete</span>[] value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> i, <span class="type">unsigned</span> <span class="type">int</span> j, <span class="type">unsigned</span> <span class="type">int</span> k)</span> </span>&#123; <span class="keyword">return</span> value[i * Ny * Nz + j * Nz + k]; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作为对比，你可以在类的内部分配三维数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">field3_3dp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Nx, Ny, Nz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span>*** value = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">field3_3dp</span>(<span class="type">unsigned</span> <span class="type">int</span> _Nx, <span class="type">unsigned</span> <span class="type">int</span> _Ny, <span class="type">unsigned</span> <span class="type">int</span> _Nz)</span><br><span class="line">        : <span class="built_in">Nx</span>(_Nx)</span><br><span class="line">        , <span class="built_in">Ny</span>(_Ny)</span><br><span class="line">        , <span class="built_in">Nz</span>(_Nz)</span><br><span class="line">    &#123;</span><br><span class="line">        value = <span class="built_in">allocate_3d_array</span>(Nx, Ny, Nz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">field3_3dp</span>() &#123; <span class="built_in">deallocate_3d_array</span>(value, Nx, Ny); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> i, <span class="type">unsigned</span> <span class="type">int</span> j, <span class="type">unsigned</span> <span class="type">int</span> k)</span> </span>&#123; <span class="keyword">return</span> value[i][j][k]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SizeX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Nx; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SizeY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Ny; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SizeZ</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Nz; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是我希望数据是一维连续分布的……这样会方便我传输一个 2d 的 slice</p><p>所以如果乘法计算一维索引很费的话，那么也可以创建一个三维数组，然后把指针指向实际的一维内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">field3_map</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Nx, Ny, Nz;</span><br><span class="line">    <span class="type">double</span>*      value;</span><br><span class="line">    <span class="type">double</span>***    ptr3d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">field3_map</span>(<span class="type">unsigned</span> <span class="type">int</span> _Nx, <span class="type">unsigned</span> <span class="type">int</span> _Ny, <span class="type">unsigned</span> <span class="type">int</span> _Nz)</span><br><span class="line">        : <span class="built_in">Nx</span>(_Nx)</span><br><span class="line">        , <span class="built_in">Ny</span>(_Ny)</span><br><span class="line">        , <span class="built_in">Nz</span>(_Nz)</span><br><span class="line">        , <span class="built_in">value</span>(<span class="keyword">new</span> <span class="type">double</span>[Nx * Ny * Nz])</span><br><span class="line">    &#123;</span><br><span class="line">        ptr3d = <span class="keyword">new</span> <span class="type">double</span>**[Nx];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; Nx; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr3d[i] = <span class="keyword">new</span> <span class="type">double</span>*[Ny];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>; j &lt; Ny; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr3d[i][j] = value + (i * Ny + j) * Nz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">field3_map</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; Nx; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] ptr3d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr3d;</span><br><span class="line">        <span class="keyword">delete</span>[] value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span>** <span class="keyword">operator</span>[](<span class="type">unsigned</span> <span class="type">int</span> i) &#123; <span class="keyword">return</span> ptr3d[i]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SizeX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Nx; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SizeY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Ny; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SizeZ</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Nz; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Kokkos 有一个 <code>mdspan</code> 实现来达成类似的效果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">field3_mdspan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>                                     Nx, Ny, Nz;</span><br><span class="line">    <span class="type">double</span>*                                          value;</span><br><span class="line">    Kokkos::mdspan&lt;<span class="type">double</span>, Kokkos::dextents&lt;<span class="type">int</span>, <span class="number">3</span>&gt;&gt; m_mdspan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">field3_mdspan</span>(<span class="type">unsigned</span> <span class="type">int</span> _Nx, <span class="type">unsigned</span> <span class="type">int</span> _Ny, <span class="type">unsigned</span> <span class="type">int</span> _Nz)</span><br><span class="line">        : <span class="built_in">Nx</span>(_Nx)</span><br><span class="line">        , <span class="built_in">Ny</span>(_Ny)</span><br><span class="line">        , <span class="built_in">Nz</span>(_Nz)</span><br><span class="line">        , <span class="built_in">value</span>(<span class="keyword">new</span> <span class="type">double</span>[Nx * Ny * Nz])</span><br><span class="line">        , <span class="built_in">m_mdspan</span>(value, Nx, Ny, Nz)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">field3_mdspan</span>() &#123; <span class="keyword">delete</span>[] value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> </span>&#123; <span class="keyword">return</span> m_mdspan[i, j, k]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SizeX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Nx; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SizeY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Ny; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SizeZ</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Nz; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用一个常见的对流计算函数来做测试，这是一个例子</p><p>因为不同的类的访问可能是 <code>(i, j, k)</code> 或者 <code>[i, j, k]</code> 或者 <code>[i][j][k]</code>，所以我并没有写模板函数，而是每个类都写了对应的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function to calculate convection term u * ∇u + v * ∇v + w * ∇w</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculate_convection_3dp_raw</span><span class="params">(<span class="type">double</span>***    u,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">double</span>***    v,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">double</span>***    w,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">double</span>***    conv_u,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">double</span>***    conv_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">double</span>***    conv_w,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">unsigned</span> <span class="type">int</span> Nx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">unsigned</span> <span class="type">int</span> Ny,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">unsigned</span> <span class="type">int</span> Nz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt; Nx - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">1</span>; j &lt; Ny - <span class="number">1</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> k = <span class="number">1</span>; k &lt; Nz - <span class="number">1</span>; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">double</span> dudx = (u[i + <span class="number">1</span>][j][k] - u[i - <span class="number">1</span>][j][k]) / <span class="number">2.0</span>;</span><br><span class="line">                <span class="type">double</span> dudy = (u[i][j + <span class="number">1</span>][k] - u[i][j - <span class="number">1</span>][k]) / <span class="number">2.0</span>;</span><br><span class="line">                <span class="type">double</span> dudz = (u[i][j][k + <span class="number">1</span>] - u[i][j][k - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">double</span> dvdx = (v[i + <span class="number">1</span>][j][k] - v[i - <span class="number">1</span>][j][k]) / <span class="number">2.0</span>;</span><br><span class="line">                <span class="type">double</span> dvdy = (v[i][j + <span class="number">1</span>][k] - v[i][j - <span class="number">1</span>][k]) / <span class="number">2.0</span>;</span><br><span class="line">                <span class="type">double</span> dvdz = (v[i][j][k + <span class="number">1</span>] - v[i][j][k - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">double</span> dwdx = (w[i + <span class="number">1</span>][j][k] - w[i - <span class="number">1</span>][j][k]) / <span class="number">2.0</span>;</span><br><span class="line">                <span class="type">double</span> dwdy = (w[i][j + <span class="number">1</span>][k] - w[i][j - <span class="number">1</span>][k]) / <span class="number">2.0</span>;</span><br><span class="line">                <span class="type">double</span> dwdz = (w[i][j][k + <span class="number">1</span>] - w[i][j][k - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">                conv_u[i][j][k] = u[i][j][k] * dudx + v[i][j][k] * dudy + w[i][j][k] * dudz;</span><br><span class="line">                conv_v[i][j][k] = u[i][j][k] * dvdx + v[i][j][k] * dvdy + w[i][j][k] * dvdz;</span><br><span class="line">                conv_w[i][j][k] = u[i][j][k] * dwdx + v[i][j][k] * dwdy + w[i][j][k] * dwdz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算效率的过程为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Measure the time for 100 iterations of convection calculation</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> num_iterations = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span>      start_time     = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> iter = <span class="number">0</span>; iter &lt; num_iterations; ++iter)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">calculate_convection_1dp</span>(u, v, w, conv_u, conv_v, conv_w);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;iter = &quot;</span> &lt;&lt; iter &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>                          end_time     = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">std::chrono::duration&lt;<span class="type">double</span>&gt; elapsed_time = end_time - start_time;</span><br></pre></td></tr></table></figure><h2 id="性能测试结果">性能测试结果</h2><p>测试结果如下，在 512^3 的数组大小下进行测试，以保证单次执行的粒度</p><table>    <tr>        <td rowspan="2" align="center">platform</td>        <td rowspan="2" align="center">complier</td>        <td colspan="6" align="center">time(s)</td>    </tr>    <tr>        <td align="center">field3_1dp</td>        <td align="center">field3_1dp_t</td>        <td align="center">field3_3dp</td>        <td align="center">field3_r</td>        <td align="center">field3_map</td>        <td align="center">field3_mdspan</td>    </tr>    <tr>        <td rowspan="3" align="center">windows</td>        <td align="center">msvc</td>        <td align="center">6.1776</td>        <td align="center">3.916</td>        <td align="center">1.37877</td>        <td align="center">1.03</td>        <td align="center">6.43983</td>        <td align="center">6.26672</td>    </tr>    <tr>        <td align="center">g++</td>        <td align="center">5.63062</td>        <td align="center">4.18603</td>        <td align="center">1.12186</td>        <td align="center">1.06282</td>        <td align="center">5.05098</td>        <td align="center">5.11213</td>    </tr>    <tr>        <td align="center">clang++</td>        <td align="center">3.14699</td>        <td align="center">1.68778</td>        <td align="center">1.19851</td>        <td align="center">1.13926</td>        <td align="center">1.99766</td>        <td align="center">1.93895</td>    </tr>    <tr>        <td rowspan="2" align="center">linux</td>        <td align="center">g++</td>        <td align="center">1.90795</td>        <td align="center">1.86067</td>        <td align="center">1.42331</td>        <td align="center">1.42438</td>        <td align="center">1.87503</td>        <td align="center">1.92114</td>    </tr>    <tr>        <td align="center">clang++</td>        <td align="center">1.03195</td>        <td align="center">0.96762</td>        <td align="center">1.10214</td>        <td align="center">1.0981</td>        <td align="center">1.04556</td>        <td align="center">1.0522</td>    </tr></table><p>这里并没有给出硬件参数和编译器版本</p><p>这说明：</p><ol><li><p>操作系统、编译器类型与性能具有很大关系</p></li><li><p>clang 在 linux 上的表现最好，使得不同实现版本的性能表现趋于一致。这同时也证明了，将三维索引映射到一维内存索引的策略是有意义的</p></li></ol><p>这个测试表明了操作系统、编译器类型对性能具有不可忽视的影响，如果可能的话，可以尝试更改编译器来查看性能差异。例如编译 MPI 程序时也可以更换到 clang 编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpicxx -cxx=clang++ main.cpp -O3 -I3rdparty/mdspan/include -march=native -o main_mpicxx_warpper</span><br></pre></td></tr></table></figure><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Mutliple Dimensional Array </tag>
            
            <tag> High Performance Computing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 静态反射学习</title>
      <link href="/2024/05/13/2024-05-13-cpp_static_reflection/"/>
      <url>/2024/05/13/2024-05-13-cpp_static_reflection/</url>
      
        <content type="html"><![CDATA[<p>比较了 Piccolo, Taichi, ykiko 的静态反射做法</p><h2 id="C-静态反射学习">C++静态反射学习</h2><h3 id="Piccolo-中的静态反射">Piccolo 中的静态反射</h3><h4 id="存储类型信息">存储类型信息</h4><p>反射需要存储一些类型信息，Piccolo 用一个 map 存储了类型名对应的工具函数，也就是存储了类型信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">void</span>*, <span class="type">void</span>*)&gt;      SetFuncion;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>*(<span class="type">void</span>*)&gt;            GetFuncion;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">const</span> <span class="type">char</span>*()&gt;           GetNameFuncion;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">void</span>*)&gt; SetArrayFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>*(<span class="type">int</span>, <span class="type">void</span>*)&gt;       GetArrayFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">int</span>(<span class="type">void</span>*)&gt;              GetSizeFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">bool</span>()&gt;                  GetBoolFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">void</span>*)&gt;             InvokeFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>*(<span class="type">const</span> Json&amp;)&gt;                           ConstructorWithJson;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;Json(<span class="type">void</span>*)&gt;                                  WriteJsonByName;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">int</span>(Reflection::ReflectionInstance*&amp;, <span class="type">void</span>*)&gt; GetBaseClassReflectionInstanceListFunc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;SetFuncion, GetFuncion, GetNameFuncion, GetNameFuncion, GetNameFuncion, GetBoolFunc&gt;</span><br><span class="line">                                                    FieldFunctionTuple;</span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;GetNameFuncion, InvokeFunction&gt; MethodFunctionTuple;</span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;GetBaseClassReflectionInstanceListFunc, ConstructorWithJson, WriteJsonByName&gt; ClassFunctionTuple;</span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;SetArrayFunc, GetArrayFunc, GetSizeFunc, GetNameFuncion, GetNameFuncion&gt;      ArrayFunctionTuple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reflection.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::map&lt;std::string, ClassFunctionTuple*&gt;       m_class_map;</span><br><span class="line"><span class="type">static</span> std::multimap&lt;std::string, FieldFunctionTuple*&gt;  m_field_map;</span><br><span class="line"><span class="type">static</span> std::multimap&lt;std::string, MethodFunctionTuple*&gt; m_method_map;</span><br><span class="line"><span class="type">static</span> std::map&lt;std::string, ArrayFunctionTuple*&gt;       m_array_map;</span><br></pre></td></tr></table></figure><p>这些工具函数就是用来访问反射实例的。</p><p>工具函数是怎么来的？在业务代码的定义里面添加宏定义，之后分析业务代码，生成与需要反射的业务代码中的类型一一对应的反射工具类，其中定义了这些工具函数。</p><p>这些生成的反射工具类中包含一组组的工具函数。你需要什么反射功能，你就需要规定生成什么样的工具函数。现在已经写得明确了，就是四组工具函数，<code>FieldFunctionTuple</code> 用来访问字段；<code>MethodFunctionTuple</code> 用来访问方法；<code>ClassFunctionTuple</code> 用来获取基类列表、从 json 反序列化为类的实例、从类的实例序列化为 json；<code>ArrayFunctionTuple</code> 用来访问数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector2.reflection.gen.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Piccolo&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Vector2</span>;</span><br><span class="line"><span class="keyword">namespace</span> Reflection&#123;</span><br><span class="line"><span class="keyword">namespace</span> TypeFieldReflectionOparator&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TypeVector2Operator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getClassName</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;Vector2&quot;</span>;&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">constructorWithJson</span><span class="params">(<span class="type">const</span> Json&amp; json_context)</span></span>&#123;</span><br><span class="line">            Vector2* ret_instance= <span class="keyword">new</span> Vector2;</span><br><span class="line">            Serializer::<span class="built_in">read</span>(json_context, *ret_instance);</span><br><span class="line">            <span class="keyword">return</span> ret_instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> Json <span class="title">writeByName</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Serializer::<span class="built_in">write</span>(*(Vector2*)instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// base class</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getVector2BaseClassReflectionInstanceList</span><span class="params">(ReflectionInstance* &amp;out_list, <span class="type">void</span>* instance)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fields</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldName_x</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;x&quot;</span>;&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldTypeName_x</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;float&quot;</span>;&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_x</span><span class="params">(<span class="type">void</span>* instance, <span class="type">void</span>* field_value)</span></span>&#123; <span class="built_in">static_cast</span>&lt;Vector2*&gt;(instance)-&gt;x = *<span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(field_value);&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">get_x</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;(<span class="built_in">static_cast</span>&lt;Vector2*&gt;(instance)-&gt;x));&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isArray_x</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldName_y</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;y&quot;</span>;&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldTypeName_y</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;float&quot;</span>;&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_y</span><span class="params">(<span class="type">void</span>* instance, <span class="type">void</span>* field_value)</span></span>&#123; <span class="built_in">static_cast</span>&lt;Vector2*&gt;(instance)-&gt;y = *<span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(field_value);&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">get_y</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;(<span class="built_in">static_cast</span>&lt;Vector2*&gt;(instance)-&gt;y));&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isArray_y</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// methods</span></span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;<span class="comment">//namespace TypeFieldReflectionOparator</span></span><br></pre></td></tr></table></figure><p>他这里为了不污染业务代码，把反射生成的工具函数和工具类都放在了一个独立的命名空间里面。每一组工具函数也是处于不同的命名空间里面，看上去更清晰，这里只是展示了字段的工具函数，位于 <code>TypeFieldReflectionOparator</code>，如果原始类型需要反射数组，相关的工具函数就会放在另外的命名空间 <code>ArrayReflectionOperator</code> 中</p><p>工具函数这里可以看到，输入的 instance 是 <code>void*</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector2.reflection.gen.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">get_x</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;(<span class="built_in">static_cast</span>&lt;Vector2*&gt;(instance)-&gt;x));&#125;</span><br></pre></td></tr></table></figure><p>这其实隐含着一个约定是，反射实例的数据都用 <code>void*</code> 表示。<code>void*</code> 很常用，因为使用指针可以避免数据拷贝，使用 <code>void</code> 是方便 cast。</p><p>如果之后和别的反射框架对照，可以发现，你为了统一处理反射逻辑，肯定会把需要反射的东西装箱成一个中间类，或者说，类型擦除</p><p>这个中间类你用 <code>std::any</code> 存指针或者 <code>void*</code> 或者自己定义一个类似 <code>std::any</code> 的东西都可以</p><p>最终反正都是调用 <code>static_cast</code> 把擦除之后的类转换成自定义类型，然后访问自定义类型中的成员，然后再把访问结果用 <code>static_cast</code> 类型擦除</p><p>它这里为了把表示数据的 <code>void*</code> 和表示类型的 <code>string</code> 绑在一起，就创建了 <code>ReflectionInstance</code> <code>ReflectionPtr</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectionInstance</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TypeMeta m_meta;</span><br><span class="line">    <span class="type">void</span>*    m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectionPtr</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_type_name &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">typedef</span> T   m_type;</span><br><span class="line">    T*          m_instance &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>业务代码的反射宏定义中已经把这些反射工具类前向声明为了友元，所以这些反射工具类里面的工具函数是有权限访问到原始类型的成员的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFLECTION_BODY(class_name) \</span></span><br><span class="line"><span class="meta">    friend class Reflection::TypeFieldReflectionOparator::Type##class_name##Operator; \</span></span><br><span class="line"><span class="meta">    friend class Serializer;</span></span><br><span class="line">    <span class="comment">// public: virtual std::string getTypeName() override &#123;return #class_name;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFLECTION_TYPE(class_name) \</span></span><br><span class="line"><span class="meta">    namespace Reflection \</span></span><br><span class="line"><span class="meta">    &#123; \</span></span><br><span class="line"><span class="meta">        namespace TypeFieldReflectionOparator \</span></span><br><span class="line"><span class="meta">        &#123; \</span></span><br><span class="line"><span class="meta">            class Type##class_name##Operator; \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vector2.h</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">REFLECTION_TYPE</span>(Vector2)</span><br><span class="line"><span class="built_in">CLASS</span>(Vector2, Fields)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">REFLECTION_BODY</span>(Vector2);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只是生成了代码，找了一个位置定义了工具函数，如果我们需要从任意一个位置通过类型名字获取工具函数，我们还需要把这些工具函数统一存储在一个地方，方便查找。</p><p>生成的反射工具类中有一个函数，收集四组工具函数，每一组打包成一个 <code>std::tuple</code>，加入全局反射单例的 map</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// animation_clip.reflection.gen.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TypeWrapperRegister_AnimNodeMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FieldFunctionTuple* field_function_tuple_convert=<span class="keyword">new</span> <span class="built_in">FieldFunctionTuple</span>(</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::set_convert,</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::get_convert,</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::getClassName,</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::getFieldName_convert,</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::getFieldTypeName_convert,</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::isArray_convert);</span><br><span class="line">    <span class="built_in">REGISTER_FIELD_TO_MAP</span>(<span class="string">&quot;AnimNodeMap&quot;</span>, field_function_tuple_convert);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ArrayFunctionTuple* array_tuple_stdSSvectorLstdSSstringR = <span class="keyword">new</span>  <span class="built_in">ArrayFunctionTuple</span>(</span><br><span class="line">        &amp;ArrayReflectionOperator::ArraystdSSvectorLstdSSstringROperator::set,</span><br><span class="line">        &amp;ArrayReflectionOperator::ArraystdSSvectorLstdSSstringROperator::get,</span><br><span class="line">        &amp;ArrayReflectionOperator::ArraystdSSvectorLstdSSstringROperator::getSize,</span><br><span class="line">        &amp;ArrayReflectionOperator::ArraystdSSvectorLstdSSstringROperator::getArrayTypeName,</span><br><span class="line">        &amp;ArrayReflectionOperator::ArraystdSSvectorLstdSSstringROperator::getElementTypeName);</span><br><span class="line">    <span class="built_in">REGISTER_ARRAY_TO_MAP</span>(<span class="string">&quot;std::vector&lt;std::string&gt;&quot;</span>, array_tuple_stdSSvectorLstdSSstringR);</span><br><span class="line">    ClassFunctionTuple* class_function_tuple_AnimNodeMap=<span class="keyword">new</span> <span class="built_in">ClassFunctionTuple</span>(</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::getAnimNodeMapBaseClassReflectionInstanceList,</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::constructorWithJson,</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::writeByName);</span><br><span class="line">    <span class="built_in">REGISTER_BASE_CLASS_TO_MAP</span>(<span class="string">&quot;AnimNodeMap&quot;</span>, class_function_tuple_AnimNodeMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他这个解析代码的程序生成反射代码文件与源码中的头文件一一对应，源码里面一个头文件可以定义多个需要反射的类，这个程序都可以处理</p><p>这种情况下，一个反射工具类对应一个用于收集工具函数，创建 tuple 的函数 <code>TypeWrapperRegister_ClassName</code>。一个文件里面最终还需要一个注册函数 <code>TypeWrappersRegister::ClassName</code>，里面调用所有的 <code>TypeWrapperRegister_ClassName</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> TypeWrappersRegister&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AnimationClip</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">TypeWrapperRegister_AnimNodeMap</span>();</span><br><span class="line">        <span class="built_in">TypeWrapperRegister_AnimationChannel</span>();</span><br><span class="line">        <span class="built_in">TypeWrapperRegister_AnimationClip</span>();</span><br><span class="line">        <span class="built_in">TypeWrapperRegister_AnimationAsset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//namespace TypeWrappersRegister</span></span><br></pre></td></tr></table></figure><p>代码生成程序除了一个需要反射的头文件对应一个反射代码文件之外，还会生成一个专门用于注册类型信息的文件，里面调用了所有的注册函数 <code>TypeWrappersRegister::ClassName</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Reflection&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TypeMetaRegister::metaRegister</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">BlendState</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Quaternion</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">AxisAligned</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">TransformComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">ParticleComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Vector3</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Transform</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Color</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Vector4</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Vector2</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Object</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Matrix4</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">MetaExample</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">World</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">AnimationClip</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">AnimationSkeletonNodeMap</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">SkeletonData</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">SkeletonMask</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Animation</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">AnimationComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Camera</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Component</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Material</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">CameraComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">BasicShape</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">RigidBody</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">LuaComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Mesh</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">RenderObject</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">MeshComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Motor</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">MotorComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">GlobalRendering</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Emitter</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">RigidbodyComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">GlobalParticle</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">MeshData</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">CameraConfig</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Level</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个总的注册函数 <code>TypeMetaRegister::metaRegister</code> 在游戏引擎启动的时候被调用，这样就完成了类型信息的存储</p><h4 id="使用反射创建-GUI-树">使用反射创建 GUI 树</h4><p>给定一个反射实例，需要知道他的父类有多少个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// editor_ui.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorUI::createClassUI</span><span class="params">(Reflection::ReflectionInstance&amp; instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Reflection::ReflectionInstance* reflection_instance;</span><br><span class="line">    <span class="type">int</span> count = instance.m_meta.<span class="built_in">getBaseClassReflectionInstanceList</span>(reflection_instance, instance.m_instance);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; count; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">createClassUI</span>(reflection_instance[index]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">createLeafNodeUI</span>(instance);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">delete</span>[] reflection_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他这里是认为 GUI 树的布局跟继承树是一样的</p><p>创建某一个节点的 GUI 是大量使用反射的地方。对一个反射实例，获取他所有的字段，如果字段是数组，那么就要遍历这个数组的所有成员，每一个成员又要创建一个反射实例，继续调用 <code>createClassUI</code>；如果不是，那么用这个字段创建反射实例，继续调用 <code>createClassUI</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// editor_ui.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorUI::createLeafNodeUI</span><span class="params">(Reflection::ReflectionInstance&amp; instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Reflection::FieldAccessor* fields;</span><br><span class="line">    <span class="type">int</span>                        fields_count = instance.m_meta.<span class="built_in">getFieldsList</span>(fields);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> index = <span class="number">0</span>; index &lt; fields_count; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> field = fields[index];</span><br><span class="line">        <span class="keyword">if</span> (field.<span class="built_in">isArrayType</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            Reflection::ArrayAccessor array_accessor;</span><br><span class="line">            <span class="keyword">if</span> (Reflection::TypeMeta::<span class="built_in">newArrayAccessorFromName</span>(field.<span class="built_in">getFieldTypeName</span>(), array_accessor))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">void</span>* field_instance = field.<span class="built_in">get</span>(instance.m_instance);</span><br><span class="line">                <span class="type">int</span>   array_count    = array_accessor.<span class="built_in">getSize</span>(field_instance);</span><br><span class="line">                m_editor_ui_creator[<span class="string">&quot;TreeNodePush&quot;</span>](</span><br><span class="line">                    std::<span class="built_in">string</span>(field.<span class="built_in">getFieldName</span>()) + <span class="string">&quot;[&quot;</span> + std::<span class="built_in">to_string</span>(array_count) + <span class="string">&quot;]&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">auto</span> item_type_meta_item =</span><br><span class="line">                    Reflection::TypeMeta::<span class="built_in">newMetaFromName</span>(array_accessor.<span class="built_in">getElementTypeName</span>());</span><br><span class="line">                <span class="keyword">auto</span> item_ui_creator_iterator = m_editor_ui_creator.<span class="built_in">find</span>(item_type_meta_item.<span class="built_in">getTypeName</span>());</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; array_count; index++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (item_ui_creator_iterator == m_editor_ui_creator.<span class="built_in">end</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        m_editor_ui_creator[<span class="string">&quot;TreeNodePush&quot;</span>](<span class="string">&quot;[&quot;</span> + std::<span class="built_in">to_string</span>(index) + <span class="string">&quot;]&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">                        <span class="keyword">auto</span> object_instance = Reflection::<span class="built_in">ReflectionInstance</span>(</span><br><span class="line">                            Piccolo::Reflection::TypeMeta::<span class="built_in">newMetaFromName</span>(item_type_meta_item.<span class="built_in">getTypeName</span>().<span class="built_in">c_str</span>()),</span><br><span class="line">                            array_accessor.<span class="built_in">get</span>(index, field_instance));</span><br><span class="line">                        <span class="built_in">createClassUI</span>(object_instance);</span><br><span class="line">                        m_editor_ui_creator[<span class="string">&quot;TreeNodePop&quot;</span>](<span class="string">&quot;[&quot;</span> + std::<span class="built_in">to_string</span>(index) + <span class="string">&quot;]&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (item_ui_creator_iterator == m_editor_ui_creator.<span class="built_in">end</span>())</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        m_editor_ui_creator[item_type_meta_item.<span class="built_in">getTypeName</span>()](</span><br><span class="line">                            <span class="string">&quot;[&quot;</span> + std::<span class="built_in">to_string</span>(index) + <span class="string">&quot;]&quot;</span>, array_accessor.<span class="built_in">get</span>(index, field_instance));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                m_editor_ui_creator[<span class="string">&quot;TreeNodePop&quot;</span>](field.<span class="built_in">getFieldName</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> ui_creator_iterator = m_editor_ui_creator.<span class="built_in">find</span>(field.<span class="built_in">getFieldTypeName</span>());</span><br><span class="line">        <span class="keyword">if</span> (ui_creator_iterator == m_editor_ui_creator.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            Reflection::TypeMeta field_meta =</span><br><span class="line">                Reflection::TypeMeta::<span class="built_in">newMetaFromName</span>(field.<span class="built_in">getFieldTypeName</span>());</span><br><span class="line">            <span class="keyword">if</span> (field.<span class="built_in">getTypeMeta</span>(field_meta))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> child_instance =</span><br><span class="line">                    Reflection::<span class="built_in">ReflectionInstance</span>(field_meta, field.<span class="built_in">get</span>(instance.m_instance));</span><br><span class="line">                m_editor_ui_creator[<span class="string">&quot;TreeNodePush&quot;</span>](field_meta.<span class="built_in">getTypeName</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">                <span class="built_in">createClassUI</span>(child_instance);</span><br><span class="line">                m_editor_ui_creator[<span class="string">&quot;TreeNodePop&quot;</span>](field_meta.<span class="built_in">getTypeName</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ui_creator_iterator == m_editor_ui_creator.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                m_editor_ui_creator[field.<span class="built_in">getFieldTypeName</span>()](field.<span class="built_in">getFieldName</span>(),</span><br><span class="line">                                                                        field.<span class="built_in">get</span>(instance.m_instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_editor_ui_creator[field.<span class="built_in">getFieldTypeName</span>()](field.<span class="built_in">getFieldName</span>(),</span><br><span class="line">                                                                    field.<span class="built_in">get</span>(instance.m_instance));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] fields;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，为什么全局反射静态实例里面的 map 的 key 是类型名，<code>FieldFunctionTuple</code> 里面还要放一个获取类型名的函数。因为反射的时候我们并不是直接使用这个 map，而是先去获得字段的名字，然后再根据字段的名字从这个 map 中取东西。</p><p>其中 <code>m_editor_ui_creator</code> 用来存放 Imgui 创建 GUI 的函数。它不仅包含 <code>TreeNodePush</code> 这种 Imgui 自带的函数，更重要的的是包含了引擎里面基本类型的处理，这也是递归创建 GUI 的终止的地方</p><p>指向数据的指针会传入 <code>m_editor_ui_creator</code>，这就完成了 Imgui 对数据的控制</p><p>指向数据的指针是使用反射，遍历某个反射类的所有字段取到的，这就完成了 Imgui 能获取并控制所有被反射的字段</p><p>显示 GUI 的起点是，指定的物体的 components</p><p>从它们开始包装反射实例 <code>Reflection::ReflectionInstance</code> 专门是为了配合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// editor_ui.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp;                 selected_object_components = selected_object-&gt;<span class="built_in">getComponents</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> component_ptr : selected_object_components)</span><br><span class="line">&#123;</span><br><span class="line">    m_editor_ui_creator[<span class="string">&quot;TreeNodePush&quot;</span>]((<span class="string">&quot;&lt;&quot;</span> + component_ptr.<span class="built_in">getTypeName</span>() + <span class="string">&quot;&gt;&quot;</span>).<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">auto</span> object_instance = Reflection::<span class="built_in">ReflectionInstance</span>(</span><br><span class="line">        Piccolo::Reflection::TypeMeta::<span class="built_in">newMetaFromName</span>(component_ptr.<span class="built_in">getTypeName</span>().<span class="built_in">c_str</span>()),</span><br><span class="line">        component_ptr.<span class="keyword">operator</span>-&gt;());</span><br><span class="line">    <span class="built_in">createClassUI</span>(object_instance);</span><br><span class="line">    m_editor_ui_creator[<span class="string">&quot;TreeNodePop&quot;</span>]((<span class="string">&quot;&lt;&quot;</span> + component_ptr.<span class="built_in">getTypeName</span>() + <span class="string">&quot;&gt;&quot;</span>).<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="序列化与反序列化">序列化与反序列化</h4><p>序列化开始的时候，我们是知道我们要序列化或者反序列化某个类的，最终反序列化都是通过资产管理器的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// asset_manager.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AssetManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AssetType&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">loadAsset</span><span class="params">(<span class="type">const</span> std::string&amp; asset_url, AssetType&amp; out_asset)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// read json file to string</span></span><br><span class="line">        std::filesystem::path asset_path = <span class="built_in">getFullPath</span>(asset_url);</span><br><span class="line">        <span class="function">std::ifstream <span class="title">asset_json_file</span><span class="params">(asset_path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!asset_json_file)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;open file: &#123;&#125; failed!&quot;</span>, asset_path.<span class="built_in">generic_string</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::stringstream buffer;</span><br><span class="line">        buffer &lt;&lt; asset_json_file.<span class="built_in">rdbuf</span>();</span><br><span class="line">        <span class="function">std::string <span class="title">asset_json_text</span><span class="params">(buffer.str())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// parse to json object and read to runtime res object</span></span><br><span class="line">        std::string error;</span><br><span class="line">        <span class="keyword">auto</span>&amp;&amp;      asset_json = Json::<span class="built_in">parse</span>(asset_json_text, error);</span><br><span class="line">        <span class="keyword">if</span> (!error.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;parse json file &#123;&#125; failed!&quot;</span>, asset_url);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Serializer::<span class="built_in">read</span>(asset_json, out_asset);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里最终会调用 <code>Serializer::read</code>。它是一个模板函数，有重载有特化。</p><p>如果是派生的自定义子类反序列化，那么会调用代码生成的，模板特化版本的 <code>Serializer::read</code>。</p><p>递归调用下去，遇到 object 类这种类的话，会比较特殊</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object.h</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">REFLECTION_TYPE</span>(ObjectDefinitionRes)</span><br><span class="line"><span class="built_in">CLASS</span>(ObjectDefinitionRes, Fields)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">REFLECTION_BODY</span>(ObjectDefinitionRes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;Reflection::ReflectionPtr&lt;Component&gt;&gt; m_components;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它里面含有的 <code>Reflection::ReflectionPtr&lt;Component&gt;</code> 这个类型的反序列化不是代码生成的，这是手写的</p><p>就，这里会有一些比较绕的事情发生。总的序列化流程我们已经知道了，自定义类型 <code>A</code> 的反序列化函数 <code>Serializer::read</code> 由代码生成，生成的内容就是对 <code>A</code> 的每一个成员继续调用 <code>Serializer::read</code></p><p>如果 <code>A</code> 的成员都是基本类型，那么就会跳到预先写好的特化到基本类型的 <code>Serializer::read</code>；如果 <code>A</code> 的成员也有自定义类型 <code>B</code> <code>C</code>，那么就会跳到代码生成的，特化到 <code>B</code> <code>C</code> 的 <code>Serializer::read</code></p><p>自定义类型中有一些特殊的是 <code>Reflection::ReflectionPtr&lt;T&gt;</code> 这个类型，你要反序列化生成的是自定义类型的指针，单纯是特化到自定义类型的 <code>Serializer::read</code> 还不够用，还需要多写一个实例化，然后获取指针的这个步骤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serializer.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> T*&amp; <span class="title">readPointer</span><span class="params">(<span class="type">const</span> Json&amp; json_context, T*&amp; instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(instance == <span class="literal">nullptr</span>);</span><br><span class="line">    std::string type_name = json_context[<span class="string">&quot;$typeName&quot;</span>].<span class="built_in">string_value</span>();</span><br><span class="line">    <span class="built_in">assert</span>(!type_name.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;*&#x27;</span> == type_name[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> T;</span><br><span class="line">        <span class="built_in">read</span>(json_context[<span class="string">&quot;$context&quot;</span>], *instance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        instance = <span class="built_in">static_cast</span>&lt;T*&gt;(</span><br><span class="line">            Reflection::TypeMeta::<span class="built_in">newFromNameAndJson</span>(type_name, json_context[<span class="string">&quot;$context&quot;</span>]).m_instance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> T*&amp; <span class="title">read</span><span class="params">(<span class="type">const</span> Json&amp; json_context, Reflection::ReflectionPtr&lt;T&gt;&amp; instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string type_name = json_context[<span class="string">&quot;$typeName&quot;</span>].<span class="built_in">string_value</span>();</span><br><span class="line">    instance.<span class="built_in">setTypeName</span>(type_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">readPointer</span>(json_context, instance.<span class="built_in">getPtrReference</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Reflection::ReflectionPtr&lt;T&gt;</code> 这里存储的是基类 <code>T</code> 的指针，用来实现多态。比如一个 gameobject 可能拥有很多不同的 component，但是它们都继承自 component 基类。</p><p>但是我们要生成的是派生类实例，派生类的实例化，可想而知，也是需要读取 json 的。然而读取特定类型的 json 我们是依赖于明确地传入一个自定义类型，才能调用到特化版本的 <code>Serializer::read</code></p><p>而现在我们处理 <code>Reflection::ReflectionPtr</code> 的时候我们只知道是基类类型 <code>T</code>，那就没办法调用到特化版本的 <code>Serializer::read</code> 了</p><p>所以为了处理 <code>Reflection::ReflectionPtr</code> 能够调用到特化版本的 <code>Serializer::read</code>，需要代码里面某处明确写明了派生类的类型，然后把这个派生类的类型的参数传给 <code>Serializer::read</code> 就能调用到特化版本。这个东西写完，或者说这个函数写完之后，处理 <code>Reflection::ReflectionPtr</code> 的时候还需要找得到</p><p>这就再次用到了反射。<code>Reflection::ReflectionPtr</code> 里面存储派生类的类名，我们根据这个类名通过反射获取到反序列化函数 <code>Reflection::TypeMeta::newFromNameAndJson</code>，它里面就是特意调用派生类特化版本的 <code>Serializer::read</code></p><p><code>readPointer</code> 除了处理 <code>Reflection::ReflectionPtr&lt;T&gt;</code> 还会处理 <code>T*</code>。这是因为它们都是表示指针的意义才写在一起的，实际上，<code>Reflection::ReflectionPtr&lt;T&gt;</code> 也可以算是一个值类型了。</p><p>回到我们的总结，反序列化看上去比较绕的就是，对一个类型，递归调用 <code>Serializer::read</code></p><ol><li><p>如果数据成员是基本类型</p><p>调用特化到基本类型的 <code>Serializer::read</code></p></li><li><p>如果数据成员是自定义类型 <code>T</code></p><p>调用生成的，特化到 <code>T</code> 的 <code>Serializer::read</code></p></li><li><p>如果数据成员是某个类型的指针 <code>T*</code></p><p>先 <code>new T</code> 再调用特化到 <code>T</code> 的 <code>Serializer::read</code></p></li><li><p>如果数据成员是 <code>Reflection::ReflectionPtr&lt;T&gt;</code></p><p>从 <code>Reflection::ReflectionPtr</code> 拿到派生类类型信息，根据这个类型信息拿到对应派生类的 <code>Reflection::TypeMeta::newFromNameAndJson</code>，其中调用生成的，特化到自定义类型的，并且这个自定义类型是继承自 <code>T</code> 的 <code>Serializer::read</code></p></li></ol><p>就是这样，不断递归，最终跳到基本类型就结束了</p><p>序列化也是同理，递归调用 <code>Serializer::write</code></p><ol><li><p>如果数据成员是基本类型</p><p>调用特化到基本类型的 <code>Serializer::write</code></p></li><li><p>如果数据成员是自定义类型 <code>T</code></p><p>调用生成的，特化到 <code>T</code> 的 <code>Serializer::write</code></p></li><li><p>如果数据成员是某个类型的指针 <code>T*</code></p><p><code>$typeName</code> 填 <code>*</code>，然后调用特化到 <code>T</code> 的 <code>Serializer::write</code></p></li><li><p>如果数据成员是 <code>Reflection::ReflectionPtr&lt;T&gt;</code></p><p>从 <code>Reflection::ReflectionPtr</code> 拿到派生类类型信息，根据这个类型信息拿到对应派生类的 <code>Reflection::TypeMeta::writeByName</code>，其中调用生成的，特化到自定义类型的，并且这个自定义类型是继承自 <code>T</code> 的 <code>Serializer::write</code></p></li></ol><p>因为 cpp 提供了最基础的静态反射，可以知道一个类型是不是指针，所以 <code>writePointer</code> 这里就单单明确是用于 <code>T*</code> 的，而不是像 <code>readPointer</code> 那样，除了处理 <code>Reflection::ReflectionPtr&lt;T&gt;</code> 还会处理 <code>T*</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> Json <span class="title">writePointer</span><span class="params">(T* instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Json::object &#123; &#123;<span class="string">&quot;$typeName&quot;</span>, Json &#123;<span class="string">&quot;*&quot;</span>&#125;&#125;, &#123;<span class="string">&quot;$context&quot;</span>, Serializer::<span class="built_in">write</span>(*instance)&#125; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> Json <span class="title">write</span><span class="params">(<span class="type">const</span> Reflection::ReflectionPtr&lt;T&gt;&amp; instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T*          instance_ptr = <span class="built_in">static_cast</span>&lt;T*&gt;(instance.<span class="keyword">operator</span>-&gt;());</span><br><span class="line">    std::string type_name    = instance.<span class="built_in">getTypeName</span>();</span><br><span class="line">    <span class="keyword">return</span> Json::object &#123; &#123;<span class="string">&quot;$typeName&quot;</span>, <span class="built_in">Json</span>(type_name)&#125;,</span><br><span class="line">                            &#123;<span class="string">&quot;$context&quot;</span>, Reflection::TypeMeta::<span class="built_in">writeByName</span>(type_name, instance_ptr)&#125; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> Json <span class="title">write</span><span class="params">(<span class="type">const</span> T&amp; instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_pointer&lt;T&gt;::value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">writePointer</span>((T)instance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">static_assert</span>(always_false&lt;T&gt;, <span class="string">&quot;Serializer::write&lt;T&gt; has not been implemented yet!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Json</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么说呢……这个不对称看上去令人强迫症犯了……</p><h4 id="ReflectionPtr-和-ReflectionInstance-用于类型擦除">ReflectionPtr 和 ReflectionInstance 用于类型擦除</h4><p>一些反射教程中没有这两个东西</p><p>他们的示例在做反射的时候，会传入原本被反射的类型，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="type">foo_t</span> = reflect::<span class="built_in">GetByName</span>(<span class="string">&quot;Foo&quot;</span>);</span><br><span class="line">Foo f;</span><br><span class="line"><span class="comment">// Test member variables</span></span><br><span class="line"><span class="keyword">auto</span> name_var = <span class="type">foo_t</span>.<span class="built_in">GetMemberVar</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">name_var.<span class="built_in">SetValue</span>(f, std::string &#123;<span class="string">&quot;taichi&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><p>问题来了，如果我只能这么用的话，那就说明我代码里面已经知道了 <code>Foo f</code>，那我还要这个反射干嘛，我直接对 <code>Foo</code> 操作不就行了</p><p>所以需要有一个东西把任意类型的对象的类型都擦了，假设只留下 <code>void*</code> 然后业务逻辑只接受 <code>void*</code> 的数据，在对这些数据进行操作的时候，根据配套传入的 <code>string</code> 静态获得处理这些数据的函数，才对</p><p>Piccolo 这里的 <code>ReflectionPtr</code> 和 <code>ReflectionInstance</code> 就是用来做类型擦除的</p><p>当然，类型擦除被用在很多地方，这里所说的类型擦除和别的地方的不一样，这里是为了泛化与反射相关的业务逻辑，别的地方比如调用反射出来的函数的时候，内部做参数的转型</p><h4 id="ReflectionPtr-和-ReflectionInstance-的设计">ReflectionPtr 和 ReflectionInstance 的设计</h4><p>其实我一直在想一件事情，就是 <code>ReflectionPtr</code> 和 <code>ReflectionInstance</code> 这个具体怎么实现类型擦除的设计，真的有必要吗</p><p><code>ReflectionInstance</code> 是类型信息 + <code>void*</code> 类型的数据</p><p><code>ReflectionPtr</code> 是类型信息 + <code>T*</code> 类型的数据</p><p>我感觉它们的功能重合了欸。这样就有点混淆。多余的是 <code>ReflectionInstance</code>，他完全可以用 <code>ReflectionPtr&lt;void&gt;</code> 代替</p><p>而且在自定义类型的时候将 <code>ReflectionPtr</code> 和 <code>ReflectionInstance</code> 显式写在定义里面，总感觉有一种侵入式的丑陋</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GObject</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;GObject&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::unordered_set&lt;std::string&gt; TypeNameSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    GObjectID   m_id &#123;k_invalid_gobject_id&#125;;</span><br><span class="line">    std::string m_name;</span><br><span class="line">    std::string m_definition_url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we have to use the ReflectionPtr due to that the components need to be reflected </span></span><br><span class="line">    <span class="comment">// in editor, and it&#x27;s polymorphism</span></span><br><span class="line">    std::vector&lt;Reflection::ReflectionPtr&lt;Component&gt;&gt; m_components;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后还是想通了</p><p>他这里说，在 gameobject 里面使用 <code>ReflectionPtr</code> 的意义是，编辑器的 UI 需要反射信息，所以要用一个反射结构来存类型信息，同时我们还需要这个指针是有一个类型 <code>T</code> 的，以便我们在不一定是 UI 而可以是其他地方，使用到 <code>Component</code> 的多态性</p><p>再加上基类指针的类型擦除功能，总共三个用途，<code>ReflectionPtr&lt;T&gt;</code> 的设计确实是很有价值的</p><p>这里的侵入也是不可避免的。你想要多态，就会擦类型，擦了类型，你就没办法获得派生类的名字，就没法在反射数据库里面找到派生类，所以为了兼得两者，你必须要在存基类指针的时候也存类型信息</p><h4 id="ReflectionPtr-内使用智能指针">ReflectionPtr 内使用智能指针</h4><p>因为 <code>ReflectionPtr&lt;T&gt;</code> 最初设计的是，内部存一个 <code>T*</code> 指针</p><p>所以他没有资源管理的能力，所以 Piccolo 包了一些宏来做</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PICCOLO_REFLECTION_NEW(name, ...) Reflection::ReflectionPtr(#name, new name(__VA_ARGS__));</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICCOLO_REFLECTION_DELETE(value) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (value) \</span></span><br><span class="line"><span class="meta">    &#123; \</span></span><br><span class="line"><span class="meta">        delete value.operator-&gt;(); \</span></span><br><span class="line"><span class="meta">        value.getPtrReference() = nullptr; \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICCOLO_REFLECTION_DEEP_COPY(type, dst_ptr, src_ptr) \</span></span><br><span class="line"><span class="meta">    *static_cast<span class="string">&lt;type*&gt;</span>(dst_ptr) = *static_cast<span class="string">&lt;type*&gt;</span>(src_ptr.getPtr());</span></span><br></pre></td></tr></table></figure><p>使用例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// camera.h</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">REFLECTION_TYPE</span>(CameraComponentRes)</span><br><span class="line"><span class="built_in">CLASS</span>(CameraComponentRes, Fields)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">REFLECTION_BODY</span>(CameraComponentRes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Reflection::ReflectionPtr&lt;CameraParameter&gt; m_parameter;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CameraComponentRes</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">CameraComponentRes</span>(<span class="type">const</span> CameraComponentRes&amp; res);</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CameraComponentRes</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// camera.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Piccolo</span><br><span class="line">&#123;</span><br><span class="line">    CameraComponentRes::<span class="built_in">CameraComponentRes</span>(<span class="type">const</span> CameraComponentRes&amp; res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> std::string&amp; camera_type_name = res.m_parameter.<span class="built_in">getTypeName</span>();</span><br><span class="line">        <span class="keyword">if</span> (camera_type_name == <span class="string">&quot;FirstPersonCameraParameter&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_parameter = <span class="built_in">PICCOLO_REFLECTION_NEW</span>(FirstPersonCameraParameter);</span><br><span class="line">            <span class="built_in">PICCOLO_REFLECTION_DEEP_COPY</span>(FirstPersonCameraParameter, m_parameter, res.m_parameter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (camera_type_name == <span class="string">&quot;ThirdPersonCameraParameter&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_parameter = <span class="built_in">PICCOLO_REFLECTION_NEW</span>(ThirdPersonCameraParameter);</span><br><span class="line">            <span class="built_in">PICCOLO_REFLECTION_DEEP_COPY</span>(ThirdPersonCameraParameter, m_parameter, res.m_parameter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (camera_type_name == <span class="string">&quot;FreeCameraParameter&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_parameter = <span class="built_in">PICCOLO_REFLECTION_NEW</span>(FreeCameraParameter);</span><br><span class="line">            <span class="built_in">PICCOLO_REFLECTION_DEEP_COPY</span>(FreeCameraParameter, m_parameter, res.m_parameter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;invalid camera type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CameraComponentRes::~<span class="built_in">CameraComponentRes</span>() &#123; <span class="built_in">PICCOLO_REFLECTION_DELETE</span>(m_parameter); &#125;</span><br><span class="line">&#125; <span class="comment">// namespace Piccolo</span></span><br></pre></td></tr></table></figure><p>我感觉这样子确实有点麻烦了，不如直接在 <code>ReflectionPtr</code> 里面用智能指针</p><p>既然用了智能指针，那么与不同类型之间的拷贝赋值运算符和移动赋值运算符就不需要了，毕竟智能指针本身是不支持这件事情的</p><h3 id="Taichi-Graphics-cpp-reflection">Taichi Graphics cpp reflection</h3><p><a href="https://www.bilibili.com/video/BV1MY4y1c7hU">https://www.bilibili.com/video/BV1MY4y1c7hU</a></p><h4 id="使用-static-assert-以调试">使用 static_assert 以调试</h4><p>因为在模板编译报错的时候，你是没有运行时的中断的，所以也看不到编译模板中到底发生了什么错，编辑器的报错信息里面也不会说</p><p>所以可以使用 <code>static_assert</code> 来 debug。比如模板中有一个类型是 <code>tuple_t</code>，我们想知道它的类型，那么就</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(std::is_same&lt;<span class="type">tuple_t</span>, TestClassType&gt;::value, <span class="string">&quot;Debug info&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是要注意，为了方便 debug，这个模板只能被传入一种类型。这样，你要查看的那个类型也就是确定了的，这样才能跟你 hard code 的类型作比较</p><p>如果是多处代码调用了这个模板，发生了不同类型的生成，那这个模板里面你的 <code>static_assert</code> 虽然在你期望的某个调用处是通过了，但是在你忽略了的地方就没通过，程序还是编译失败</p><p>当然编译器虽然不会告诉你具体为什么编译失败，但还是会告诉谁调用这个模板失败了，这个时候你会找到你忽略的地方……但是如果你没有这个避免不同生成的意识，或许你会下意识忽略掉报错信息给你的答案……是，我犯了这样的错误</p><h4 id="简化代码以调试">简化代码以调试</h4><p>当我的代码结构比较复杂的时候，我的编译器只会报 <code>std::bad_any_cast</code> 但是不会说明具体是怎么出错了</p><p>等到我简化了代码之后，才出现了明显的报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;initializing&#x27;: cannot convert from &#x27;std::array&lt;ArgWrap,2&gt;&#x27; to &#x27;std::array&lt;ArgWrap,2&gt; &amp;&#x27;</span><br></pre></td></tr></table></figure><p>表明我是不可以把一个值类型转到引用类型</p><p>于是回去看了教程，他是先转成指针再解引用，就能得到引用类型</p><p>这就触及到了我的知识盲区……解引用 * 会返回引用类型</p><p>以前实现赋值运算符重载的时候，返回值类型是 T&amp; 然后函数体里面结尾是 return *this; 我还没多想</p><p>原来解引用还真的是解出了引用……</p><p>以下是简化出来的，能给予更多调试信息的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArgWrap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">ArgWrap</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// for debugging, delete all content</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemberFunction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MemberFunction</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">MemberFunction</span><span class="params">(R(C::* func)(Args...))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        fn_ = [<span class="keyword">this</span>, func](std::any obj_args) -&gt; std::any &#123;</span><br><span class="line">            <span class="comment">// auto&amp; warpped_args = std::any_cast&lt;std::array&lt;ArgWrap, sizeof...(Args) + 1&gt;&gt;(obj_args); // error, &#x27;initializing&#x27;: cannot convert from &#x27;std::array&lt;ArgWrap,2&gt;&#x27; to &#x27;std::array&lt;ArgWrap,2&gt; &amp;&#x27;</span></span><br><span class="line">            <span class="keyword">auto</span>&amp; warpped_args = *std::any_cast&lt;std::array&lt;ArgWrap, <span class="keyword">sizeof</span>...(Args) + <span class="number">1</span>&gt;*&gt;(obj_args); <span class="comment">// right</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> std::any&#123;&#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    std::any <span class="title">Invoke</span><span class="params">(C&amp; c, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::array&lt;ArgWrap, <span class="keyword">sizeof</span>...(Args) + 1&gt; args_arr = &#123; ArgWrap &#123;std::<span class="built_in">reference_wrapper</span>&lt;C&gt;(c)&#125;,</span><br><span class="line">                                                                 ArgWrap &#123;std::forward&lt;Args&gt;(args)&#125;... &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fn_</span>(&amp;args_arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    std::function&lt;std::any(std::any)&gt; fn_&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::unique_ptr will result in compile-time error</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">float</span>&gt; <span class="title">MakeFloatPtr</span><span class="params">(<span class="type">float</span> i)</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">float</span>&gt;(i); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">MemberFunction <span class="title">mem_fun</span><span class="params">(&amp;Foo::MakeFloatPtr)</span></span>;</span><br><span class="line"></span><br><span class="line">    mem_fun.<span class="built_in">Invoke</span>(foo, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出-typeid-T-name-以调试">输出 typeid(T).name() 以调试</h4><p>虽然我把 <code>ArgWrap</code> 装好了，但是测试不通过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> foo_pass_by_cref = <span class="type">foo_t</span>.<span class="built_in">GetMemberFunc</span>(<span class="string">&quot;PassByConstRef&quot;</span>);</span><br><span class="line">foo_pass_by_cref.<span class="built_in">Invoke</span>(f, std::<span class="built_in">ref</span>(hello_s));</span><br></pre></td></tr></table></figure><p>经过 debug 之后发现是参数转换到 tuple，传入函数的时候，Foo 对象能转出来，但是 string 转出来为空</p><p>于是我就在装入值的时候检查了类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="title">ArgWrap</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Debug type T</span></span><br><span class="line">    <span class="comment">// static_assert(std::is_same&lt;T, void&gt;::value, &quot;Hoi!&quot;);</span></span><br><span class="line">    m_ref_type = std::is_reference_v&lt;T&gt;;</span><br><span class="line">    m_is_const = std::is_const_v&lt;T&gt;;</span><br><span class="line">    <span class="keyword">if</span> (m_ref_type == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_storage = &amp;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_storage = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;typeid(std::decay_t&lt;T&gt;).name() = &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(std::<span class="type">decay_t</span>&lt;T&gt;).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;typeid(T).name() = &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> result = std::<span class="built_in">any_cast</span>&lt;<span class="type">const</span> std::string&amp;&gt;(m_storage);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;can any_cast to const std::string&amp;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_any_cast&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;can not any_cast to const std::string&amp;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeid(std::decay_t&lt;T&gt;).name() = class std::reference_wrapper&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &gt;</span><br><span class="line">typeid(T).name() = class std::reference_wrapper&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &gt;</span><br><span class="line">can not any_cast to const std::string&amp;</span><br></pre></td></tr></table></figure><p>这就说明 any_cast 没法处理这个转换……</p><h4 id="any-cast-的严格">any_cast 的严格</h4><p>做个测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span>        str2 = std::<span class="built_in">ref</span>(str1);</span><br><span class="line">    <span class="keyword">auto</span>        str3 = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> std::string&amp;&gt;(str2); <span class="comment">// Ok</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::any str4 = std::<span class="built_in">ref</span>(str1);</span><br><span class="line">    <span class="comment">// auto     str5 = std::any_cast&lt;const std::string&amp;&gt;(str4); // Crash, std::bad_any_cast</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> str6 = std::<span class="built_in">any_cast</span>&lt;<span class="keyword">decltype</span>(str2)&gt;(str4);</span><br><span class="line">    <span class="keyword">auto</span> str7 = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> std::string&amp;&gt;(str6); <span class="comment">// Ok</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>std::ref</code> 返回出来的这个类型，<code>reference_wrapper&lt;T&gt;</code>，如果我 any 里面放的是 <code>reference_wrapper&lt;T&gt;</code>，我是不能直接 <code>any_cast</code> 到 <code>T&amp;</code> 的</p><p>我 <code>any</code> 里面放的是什么类型，<code>any_cast</code> 出来就必须是什么类型，他不会帮你做 <code>static_cast</code></p><p>如果真的有 <code>static_cast</code> 的需求，那么需要 <code>any_cast</code> 之后自己写</p><h4 id="总结">总结</h4><p>他也是静态反射，只是存储函数信息的时候，用模板元编程来生成那个被存的函数</p><p>如果不想用模板，那么用代码生成，也可以生成出被存储的函数，比如 Piccolo</p><p>在模板元编程时，因为需要操作类型，所以常用 <code>std::tuple</code> 打包类型。比如用这个 <code>std::tuple</code> 可以做出包含所有参数的类型的一个 tuple</p><p>他最后考虑到 <code>std::any_cast</code> 需要一一严格对应的类型转换，所以做了一个 <code>ArgWarp</code> 来做类型转换的适配</p><p>具体来说，<code>std::any_cast</code> 需要 cast 到 <code>const std::string&amp;</code> 但是实际 <code>any</code> 存储的如果是 <code>std::string</code> 的话，<code>std::any_cast</code> 就会出错</p><p>也就是输入的实参类型 <code>T1</code> 和记录的函数的形参的类型 <code>T2</code> 之间不匹配，<code>std::any</code> 里面存的是 <code>T1</code>，但是要 <code>std::any_cast</code> 到 <code>T2</code>。<code>std::any_cast</code> 里面是直接比较 <code>typeid</code> 的，所以不会成功，即使你 <code>static_cast</code> 从 <code>T1</code> 到 <code>T2</code> 可以成功</p><p>他做的 <code>ArgWarp</code> 的适配工作是，假设 <code>std::any</code> 存储的类型 <code>T1</code> 和 Cast 接口要输出的类型 <code>T2</code> 的原始类型，也就是 <code>std::decay_t</code> 出来的类型都相同，记为 <code>RawT</code></p><p>他就考虑到 <code>T1</code> <code>T2</code> 分别为 value、const ref、non-const ref 的时候的情况，做了一个 3*3 的转换表，使用 <code>RawT</code> 和指针和解引用配合，就能得到正确的 <code>std::any_cast</code> 方法，使得我能够利用原本严格的 <code>std::any_cast</code> 转换两个不同的但是原始类型相同的类型</p><p>但是他基于的假设是 <code>T1</code> <code>T2</code> 的 <code>std::decay_t</code> 出来的类型都相同</p><p>实际上别人调用你的反射函数的时候，<code>T1</code> <code>T2</code> 的 <code>std::decay_t</code> 出来的类型还真可能不相同</p><p>为什么他会这么用？<s>因为 <code>static_cast</code> 从 <code>T1</code> 到 <code>T2</code> 可以成功，这是不违背直觉的</s></p><p>因为使用者知道从 <code>T1</code> 到 <code>T2</code> 的隐式转换是可以成功的</p><p>这不局限于 <code>static_cast</code>，还有可能是调用了类型转换函数，例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> str2 = std::<span class="built_in">ref</span>(str1);</span><br><span class="line"><span class="function">std::string&amp; <span class="title">str3</span><span class="params">(str2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以通过断点看到，构造 <code>std::string&amp;</code> 的时候，调用了 <code>reference_wrapper&lt;T&gt;</code> 里面的 <code>T&amp;</code> 类型转换函数</p><p>所以我觉得更省心智的方法应该是，不要在反射系统里面加入这个 <code>T1</code> <code>T2</code> 的 <code>std::decay_t</code> 出来的类型都相同 的隐性约束</p><h3 id="YKIKO-reflection">YKIKO reflection</h3><p>重新看了别人的文章</p><p><a href="https://zhuanlan.zhihu.com/p/670191053">https://zhuanlan.zhihu.com/p/670191053</a></p><p>他没有写 registry 和 builder 模式，而是把类型信息存在了 Any 类的偏特化模板中</p><p>这让我想到，为什么我在包装参数的时候用 <code>std::any</code></p><p>为了避免 <code>std::any</code> 的限制，我尝试了使用 <code>void*</code> 来存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeAny</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputClass&gt;</span></span><br><span class="line"><span class="function">    <span class="title">UnsafeAny</span><span class="params">(InputClass&amp;&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_ref_type = std::is_reference_v&lt;InputClass&gt;;</span><br><span class="line">        <span class="keyword">if</span> (m_ref_type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_storage = &amp;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_storage = <span class="keyword">new</span> std::<span class="built_in">decay_t</span>&lt;InputClass&gt;(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">UnsafeAny</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_ref_type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_storage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OutputClass&gt;</span></span><br><span class="line"><span class="function">    OutputClass <span class="title">Cast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> RawTptr = std::<span class="type">decay_t</span>&lt;OutputClass&gt;*;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">static_cast</span>&lt;RawTptr&gt;(m_storage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* m_storage &#123;&#125;;</span><br><span class="line">    <span class="type">int</span>   m_ref_type &#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是传入 <code>reference_wrapper&lt;T&gt;</code> 的时候还是有问题</p><p>之前我是以为从 <code>reference_wrapper&lt;T&gt;</code> 到 <code>T</code> 的转换是隐式调用了 <code>static_cast</code>，实际上不是，实际上是调用了类型转换函数</p><p><code>reference_wrapper&lt;T&gt;</code> 到 <code>T</code> 用 <code>static_cast</code> 是转不了的，它们在类型上是没有关系的</p><p>你需要先从 <code>reference_wrapper&lt;T&gt;</code> 里面取出指针出来</p><p>但是这适用不到任意类型，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你完全不知道他能这么类型转换</p><p>或许你在装箱的时候可以尝试把输入 cast 到一些确定的类型</p><p>但是这样总归是一个需要维护的地方，位于转换表中的东西可以从接口的角度来看可以隐式转换，不在表里面的就不行，行为不统一，还要维护，不如不搞</p><p>现在我完全理解了，如果想要使用这样的反射，还真的就要接受这个规则，就是接受这个无法做隐式类型转换的规则</p><p>只是在写代码的时候多写 cast 而已，可以接受</p><p>那么大的自由度也没必要</p><h3 id="使用-annotate-属性和-libclang-分析-AST-做代码生成">使用 annotate 属性和 libclang 分析 AST 做代码生成</h3><p>现在要解析 annotation，生成注册反射类的代码。原理上宏是可以完成这种任务，但是我感觉太丑，而且这样的话，反射就侵入式太重了。</p><p>虽然 annotation 也算侵入了，但是感觉，更轻量一点。如果写宏的话，人脑就要展开宏，虽然现在 IDE 也会展开</p><h4 id="链接-libclang">链接 libclang</h4><p>我之前在想怎么单纯依赖于 submodule，哪怕是这个 submodule 从某个地方把 llvm 发布版本下载过来的</p><p>比如这个 <a href="https://github.com/deech/libclang-static-build?tab=readme-ov-file#windows-10">https://github.com/deech/libclang-static-build?tab=readme-ov-file#windows-10</a></p><p>搞了一下，还有动态库静态库，release 和 debug 之间的不匹配，也不知道他下载过来的发布版本是怎么构建出来的</p><p>不想去研究了，感觉麻烦</p><p>这种大型工具还是让用户安装吧。规定用户需要设置一个环境变量 <code>LLVM_DIR</code>，存储 LLVM 发布版本的根目录，然后直接链接</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;Your <span class="keyword">Target</span> Name&gt; PUBLIC $ENV&#123;LLVM_DIR&#125;/lib/libclang.lib)</span><br><span class="line"><span class="keyword">target_include_directories</span>(&lt;Your <span class="keyword">Target</span> Name&gt; PUBLIC $ENV&#123;LLVM_DIR&#125;/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><h4 id="annotate-属性">annotate 属性</h4><p>一些更痛苦的事情是，如果想坚持使用属性这个东西，非标准的属性会被编译器删除，所以查看 AST 的时候都看不到</p><p>所以你没有办法做</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[Reflectable]]</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>有两个解决办法，要么改 clang 的代码，参考 <a href="https://www.cs.cmu.edu/~seth/llvm/llvmannotation.html">https://www.cs.cmu.edu/~seth/llvm/llvmannotation.html</a>，然后自己编译一遍 llvm</p><p>但是这样的话，你写出来的代码只有你自己的 clang 能编译通过</p><p>如果是想要把自己修改版本的 llvm 发布出来的话，维护也是一个问题</p><p>考虑到团队合作的话，别人能不能接受你自己编译的这个 llvm 是个问题……当然你可以把你自己的 llvm 的构建放到一个服务器上，让别人从这个服务器下载发布版本，但是这其中又会有静态库和动态库，debug 和 release 等问题，需要发布的 llvm 的库文件的这些设置与引擎的构建设置匹配才行。可能具体我也不太懂为什么，总之就是还是有坑</p><p>或者是想办法把自定义属性的参数都转成字符串给 <code>annotate</code> 这个属性。<code>annotate</code> 是标准里面的，所以能处理</p><p>这一种写法还挺好的 <a href="https://zhuanlan.zhihu.com/p/669360731">https://zhuanlan.zhihu.com/p/669360731</a></p><p>再参考虚幻那种格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> reflectable_class(...)    clang::annotate(<span class="string">&quot;reflectable_class;&quot;</span> #__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reflectable_struct(...)   clang::annotate(<span class="string">&quot;reflectable_struct;&quot;</span> #__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reflectable_field(...)    clang::annotate(<span class="string">&quot;reflectable_field;&quot;</span> #__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reflectable_function(...) clang::annotate(<span class="string">&quot;reflectable_function;&quot;</span> #__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> [[<span class="built_in">reflectable_struct</span>()]] Foo</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">reflectable_field</span>(blueprint_read_write)]]</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">reflectable_function</span>(blueprint_callable, category = <span class="string">&quot;Hello&quot;</span>)]]</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>达成了跟虚幻差不多的格式，虽然看上去没什么稀奇的。虚幻是自己写了一套分析代码的工具 UHT，它与属性相关的宏在编译的时候是被忽略的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObjectMacros.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// These macros wrap metadata parsed by the Unreal Header Tool, and are otherwise</span></span><br><span class="line"><span class="comment">// ignored when code containing them is compiled by the C++ compiler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPROPERTY(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UFUNCTION(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USTRUCT(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UMETA(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPARAM(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UENUM(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDELEGATE(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGVM_METHOD(...)</span></span><br></pre></td></tr></table></figure><p>虚幻的解析文件的方法在 <code>FHeaderParser::ParseHeader</code></p><h4 id="libclang">libclang</h4><p>libclang 的使用方法是提供一个遍历 AST 每一个节点时的回调函数，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;clang-c/Index.h&gt;</span> <span class="comment">// This is libclang.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; stream, <span class="type">const</span> CXString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    stream &lt;&lt; <span class="built_in">clang_getCString</span>(str);</span><br><span class="line">    <span class="built_in">clang_disposeString</span>(str);</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CXIndex           index = <span class="built_in">clang_createIndex</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    CXTranslationUnit unit  = <span class="built_in">clang_parseTranslationUnit</span>(</span><br><span class="line">        index, <span class="string">&quot;header.hpp&quot;</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, CXTranslationUnit_None);</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Unable to parse translation unit. Quitting.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CXCursor cursor = <span class="built_in">clang_getTranslationUnitCursor</span>(unit);</span><br><span class="line">    <span class="built_in">clang_visitChildren</span>(</span><br><span class="line">        cursor,</span><br><span class="line">        [](CXCursor c, CXCursor parent, CXClientData client_data) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Cursor &#x27;&quot;</span> &lt;&lt; <span class="built_in">clang_getCursorSpelling</span>(c) &lt;&lt; <span class="string">&quot;&#x27; of kind &#x27;&quot;</span></span><br><span class="line">                 &lt;&lt; <span class="built_in">clang_getCursorKindSpelling</span>(<span class="built_in">clang_getCursorKind</span>(c)) &lt;&lt; <span class="string">&quot;&#x27;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> CXChildVisit_Recurse;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clang_disposeTranslationUnit</span>(unit);</span><br><span class="line">    <span class="built_in">clang_disposeIndex</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>clang_visitChildren</code> 这里就是遍历每一个节点的时候都会调用传入的回调函数</p><p>但是我们可能会有一些复杂的匹配条件，来决定回调函数在这个节点是否被调用</p><p>使用它来处理之前的属性示例，得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cursor &#x27;Foo&#x27; of kind &#x27;StructDecl&#x27;</span><br><span class="line">Cursor &#x27;reflectable_struct;&#x27; of kind &#x27;attribute(annotate)&#x27;</span><br><span class="line">Cursor &#x27;x&#x27; of kind &#x27;FieldDecl&#x27;</span><br><span class="line">Cursor &#x27;reflectable_field;blueprint_read_write&#x27; of kind &#x27;attribute(annotate)&#x27;</span><br><span class="line">Cursor &#x27;&#x27; of kind &#x27;IntegerLiteral&#x27;</span><br><span class="line">Cursor &#x27;print&#x27; of kind &#x27;CXXMethod&#x27;</span><br><span class="line">Cursor &#x27;reflectable_function;blueprint_callable, category = &quot;Hello&quot;&#x27; of kind &#x27;attribute(annotate)&#x27;</span><br></pre></td></tr></table></figure><p>一个最简单的查找 annotation 属性的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;clang-c/Index.h&gt;</span> <span class="comment">// This is libclang.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper function to convert CXString to std::string</span></span><br><span class="line"><span class="function">std::string <span class="title">toStdString</span><span class="params">(CXString cxStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string result = <span class="built_in">clang_getCString</span>(cxStr);</span><br><span class="line">    <span class="built_in">clang_disposeString</span>(cxStr);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">split</span><span class="params">(std::string text, <span class="type">char</span> delim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string              line;</span><br><span class="line">    std::vector&lt;std::string&gt; vec;</span><br><span class="line">    <span class="function">std::stringstream        <span class="title">ss</span><span class="params">(text)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, line, delim))</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CXIndex           index = <span class="built_in">clang_createIndex</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    CXTranslationUnit unit  = <span class="built_in">clang_parseTranslationUnit</span>(</span><br><span class="line">        index, <span class="string">&quot;header.hpp&quot;</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, CXTranslationUnit_None);</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to parse translation unit. Quitting.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CXCursor cursor = <span class="built_in">clang_getTranslationUnitCursor</span>(unit);</span><br><span class="line">    <span class="built_in">clang_visitChildren</span>(</span><br><span class="line">        cursor,</span><br><span class="line">        [](CXCursor c, CXCursor parent, CXClientData client_data) &#123;</span><br><span class="line">            std::vector&lt;std::string&gt;* fields = <span class="keyword">static_cast</span>&lt;std::vector&lt;std::string&gt;*&gt;(client_data);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">clang_getCursorKind</span>(c) == CXCursor_AnnotateAttr)</span><br><span class="line">            &#123;</span><br><span class="line">                std::vector&lt;std::string&gt; annotations = <span class="built_in">split</span>(<span class="built_in">toStdString</span>(<span class="built_in">clang_getCursorSpelling</span>(c)), <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (annotations.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> CXChildVisit_Recurse;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (annotations[<span class="number">0</span>] == <span class="string">&quot;reflectable_class&quot;</span>)</span><br><span class="line">                    std::cout &lt;&lt; annotations[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (annotations[<span class="number">0</span>] == <span class="string">&quot;reflectable_struct&quot;</span>)</span><br><span class="line">                    std::cout &lt;&lt; annotations[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> CXChildVisit_Recurse;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clang_disposeTranslationUnit</span>(unit);</span><br><span class="line">    <span class="built_in">clang_disposeIndex</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然现在确定了 libclang 能够找到这个属性，但是还是不知道怎么建立属性和他所修饰的成员变量之间的关系</p><p>所以还是输出 AST 才能看到节点之间的关系</p><p>以下是反射示例的 AST 的部分输出，可以看到 <code>AnnotateAttr</code> 是 <code>CXXRecordDecl</code> <code>FieldDecl</code> <code>CXXMethodDecl</code> 的子节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PS ...&gt; clang -Xclang -ast-dump header.hpp</span><br><span class="line">...</span><br><span class="line">`-CXXRecordDecl 0x197c6538cf8 &lt;header.hpp:6:1, line:13:1&gt; line:6:36 struct Foo definition</span><br><span class="line">  |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable literal has_constexpr_non_copy_move_ctor can_const_default_init</span><br><span class="line">  | |-DefaultConstructor exists non_trivial constexpr needs_implicit defaulted_is_constexpr</span><br><span class="line">  | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param</span><br><span class="line">  | |-MoveConstructor exists simple trivial needs_implicit</span><br><span class="line">  | |-CopyAssignment simple trivial has_const_param needs_implicit implicit_has_const_param</span><br><span class="line">  | |-MoveAssignment exists simple trivial needs_implicit</span><br><span class="line">  | `-Destructor simple irrelevant trivial needs_implicit</span><br><span class="line">  |-AnnotateAttr 0x197c6538e18 &lt;line:2:35, col:85&gt; &quot;reflectable_struct;&quot;</span><br><span class="line">  |-CXXRecordDecl 0x197c6538ec0 &lt;line:6:1, col:36&gt; col:36 implicit struct Foo</span><br><span class="line">  |-FieldDecl 0x197c6538fb0 &lt;line:9:5, col:13&gt; col:9 x &#x27;int&#x27;</span><br><span class="line">  | |-IntegerLiteral 0x197c6539328 &lt;col:13&gt; &#x27;int&#x27; 1</span><br><span class="line">  | `-AnnotateAttr 0x197c6539008 &lt;line:3:35, col:84&gt; &quot;reflectable_field;blueprint_read_write&quot;</span><br><span class="line">  `-CXXMethodDecl 0x197c65391a0 &lt;line:12:5, col:16&gt; col:10 print &#x27;void ()&#x27;</span><br><span class="line">    `-AnnotateAttr 0x197c6539248 &lt;line:4:35, col:87&gt; &quot;reflectable_function;blueprint_callable, category = &quot;Hello&quot;&quot;</span><br></pre></td></tr></table></figure><p>所以我们需要获得父节点</p><p><code>clang_getCursorSemanticParent</code> 和 <code>clang_getCursorLexicalParent</code> 都不顶用，它们获得父节点的逻辑不一样，具体我也不懂</p><p><code>clang_visitChildren</code> 的回调函数的参数里面直接就有 parent，我之前没注意到，直接用这个就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clang_visitChildren</span>(</span><br><span class="line">    cursor,</span><br><span class="line">    [](CXCursor c, CXCursor parent, CXClientData client_data) &#123;</span><br><span class="line">        std::vector&lt;std::string&gt;* fields = <span class="keyword">static_cast</span>&lt;std::vector&lt;std::string&gt;*&gt;(client_data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">clang_getCursorKind</span>(c) == CXCursor_AnnotateAttr)</span><br><span class="line">        &#123;</span><br><span class="line">            std::vector&lt;std::string&gt; annotations = <span class="built_in">split</span>(<span class="built_in">toStdString</span>(<span class="built_in">clang_getCursorSpelling</span>(c)), <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (annotations.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> CXChildVisit_Recurse;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (annotations[<span class="number">0</span>] == <span class="string">&quot;reflectable_class&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">clang_getCursorKind</span>(parent) == CXCursor_ClassDecl)</span><br><span class="line">                &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;CXCursor_ClassDecl&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (annotations[<span class="number">0</span>] == <span class="string">&quot;reflectable_struct&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="built_in">toStdString</span>(<span class="built_in">clang_getCursorSpelling</span>(parent)) &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">clang_getCursorKind</span>(parent) == CXCursor_StructDecl)</span><br><span class="line">                &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;CXCursor_StructDecl&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CXChildVisit_Recurse;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><h4 id="clang-visitChildren-回调里面的用户数据指针">clang_visitChildren 回调里面的用户数据指针</h4><p>因为 clang_visitChildren 是 C 接口，所以并没有 C++ 标准的东西</p><p>用的参数是函数指针，不能存储状态</p><p>所以需要最后一个 <code>CXClientData client_data</code> 来存储用户提供的数据指针</p><p>如果你有多个数据的话……那就打包成结构体吧</p><p>lambda 只有在不捕获的时候才能退化成函数指针，std::function 也转不了函数指针，根本原因就是因为函数指针是没有上下文的，所以 <code>CXClientData client_data</code> 这里始终是绕不开的</p><h4 id="生成文件">生成文件</h4><p>思路是，先构建代码生成器，然后生成代码，获取源码文件列表 + 生成代码列表，填到 CMakeLists.txt 里面，然后再构建 Runtime 和 Editor</p><p>因为每处理一个新文件，就要在 include 和函数体两个位置更新，我一开始使用 <code>tellp</code> <code>seekp</code> 的组合，但是后面我搞不懂它为什么会产生 bug，为什么移动输出位置之后，输出一行会直接消除掉下面的两三行</p><p>为了省心，还是使用 <code>std::stringstream</code> 吧</p><h4 id="为-libclang-提供编译选项">为 libclang 提供编译选项</h4><p>libclang 读取头文件的时候，如果后缀是 <code>.h</code> 那么会认为是 C 文件。这样，就会发生解析错误。为了不修改头文件的后缀的同时，还能让 libclang 知道这是 C++，要传入 <code>-xc++</code> 编译选项</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Reflection </tag>
            
            <tag> Template programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fluid Simulation for Computer Graphics Reading Note</title>
      <link href="/2024/01/10/2024-01-10-fluid_simulation_for_computer_graphics_reading_note/"/>
      <url>/2024/01/10/2024-01-10-fluid_simulation_for_computer_graphics_reading_note/</url>
      
        <content type="html"><![CDATA[<p>It is an reading note of “Fluid Simulation for Computer Graphics”, related about fluid simulation coding, such as SPH, Level Set, PIC/FLIP and so on.</p><p>The article can’t cover all details, it just a reading note. Implementation details are so complex that it is recommended to have a look on original source.</p><p>Also see:</p><p><a href="http://rlguy.com/gridfluidsim/">http://rlguy.com/gridfluidsim/</a></p><script type="text/javascript" async  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><h2 id="Chapter-1-The-Equations-of-Fluids">Chapter 1: The Equations of Fluids</h2><h3 id="Force">Force</h3><p>What is the pressure? Whatever it takes to keep the fluid at constant volume.</p><p>It measures the imbalance in pressure at the position of the particle is simply to take the negative gradient of pressure <img src="https://math.now.sh?inline=-%5Cnabla%20p" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>Viscosity force tries to resist deforming. It tries to make our particle move at the average velocity of the nearby particle.</p><p>The differential operator that measures how far a quantity is from the average around it is Laplacian operator <img src="https://math.now.sh?inline=%5Cnabla%20%5Ccdot%20%5Cnabla" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, so viscosity force is <img src="https://math.now.sh?inline=%5Cnabla%20%5Ccdot%20%5Cnabla%20u" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><h3 id="Incompressibility">Incompressibility</h3><p>Incompressibility means volume doesn’t change. It is <img src="https://math.now.sh?inline=%5Ciiint_%7B%5COmega%7D%20%5Cnabla%20%5Ccdot%20u%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>. How to get NS eq <img src="https://math.now.sh?inline=%5Cnabla%20%5Ccdot%20u%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>?</p><p>The integration should be true for any choice of <img src="https://math.now.sh?inline=%5COmega" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, any region of fluid. The only continuous function that integrates to zero independent of the region of integration is zero itself. Thus the integrand has to be zero everywhere.</p><p>One of the tricky parts of simulating incompressible fluids is making sure that the velocity field stays divergence-free. This is where the pressure comes in.</p><p>Optimization View: think of the incompressibility condition as a constraint and the pressure field as the Lagrange multiplier.</p><h3 id="Dropping-Viscosity">Dropping Viscosity</h3><p>Most numerical methods for simulating fluids unavoidably introduce errors that can be physically reinterpreted as viscosity, so even if we drop viscosity in the equations, we will still get something that looks like it.</p><h3 id="Boundary-Conditions">Boundary Conditions</h3><h4 id="Wall-condition">Wall condition</h4><p>…</p><h4 id="Free-surface">Free surface</h4><p>Fluid area and air area can’t share same update process, because air is 700 times lighter than water, it’s not able to have that big of an effect on the water anyhow.</p><p>Bubbles are another topic.</p><p>So instead we make the modeling simplification that the air can be represented as a region with constant atmospheric pressure. In actual fact, since only differences in pressure matter (in incompressible flow), we can set the air pressure to be any arbitrary constant: zero is the most convenient. Thus a free surface is one where p = 0, and we don’t control the velocity in any particular way.</p><p>The other case in which free surfaces arise is where we are trying to simulate a bit of fluid that is part of a much larger domain. We obviously can’t afford to simulate the entire atmosphere of the Earth, so we will just make a grid that covers the region we expect to be &quot;interesting.</p><p>For smaller-scale liquids, surface tension can be very important. So curvature of free surfaces is important.</p><h4 id="Bubbles">Bubbles</h4><p>For normal water, we consider volume and momentum. For bubbles, we only condsider volume. Because air is much lighter than water, and so usually might not be able to transfer much momentum to water.</p><p>But bubbles may immediately collapse (there’s no pressure inside to stop them losing their volume). To handle this kind of situation, you need either hacks based on adding bubble particles to a free surface flow, or more generally a simulation of both air and water (called two-phase flow, because there are two phases or types of fluid involved).</p><h2 id="Chapter-2-Overview-of-Numerical-Simulation">Chapter 2: Overview of Numerical Simulation</h2><h3 id="Splitting">Splitting</h3><p>Split <img src="https://math.now.sh?inline=%5Cdfrac%7B%5Cmathrm%7Bd%7Dq%7D%7B%5Cmathrm%7Bd%7Dt%7D%20%3D%20f%28q%29%20%2B%20g(q)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> into:</p><p><img src="https://math.now.sh?inline=%5Cbegin%7Baligned%7D%0A%20%20%5Cwidetilde%7Bq%7D%20%26%20%3D%20q%5En%20%2B%20%5CDelta%20t%20f%28q%5En%29%20%5C%5C%0A%20%20q%5E%7Bn%2B1%7D%20%26%20%3D%20%5Cwidetilde%7Bq%7D%20%2B%20%5CDelta%20t%20g(%5Cwidetilde%7Bq%7D)%0A%5Cend%7Baligned%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>Use Taylor series to prove firse-order-accurate.</p><p>Simpler equation has simpler method.</p><p><img src="https://math.now.sh?inline=%5Cbegin%7Baligned%7D%0A%20%20%5Cwidetilde%7Bq%7D%20%26%20%3D%20F%28%5CDelta%20t%2C%20q%5En%29%20%5C%5C%0A%20%20q%5E%7Bn%2B1%7D%20%26%20%3D%20G(%5CDelta%20t%2C%20%5Cwidetilde%7Bq%7D)%0A%5Cend%7Baligned%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>We have better method <img src="https://math.now.sh?inline=F%2CG" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><p><img src="https://math.now.sh?inline=F%2CG" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> may be in parallel or not.</p><h3 id="Splitting-the-Fluid-Equations">Splitting the Fluid Equations</h3><p><img src="https://math.now.sh?inline=%5Cbegin%7Baligned%7D%0A%20%20%5Cdfrac%7B%5Cmathrm%7BD%7Dq%7D%7B%5Cmathrm%7BD%7Dt%7D%20%3D%200%20%26%2C%20advection%20%5C%5C%0A%20%20%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bt%7D%7D%20%3D%20g%20%26%2C%20body%5C%20force%20%5C%5C%0A%20%20%5Cdfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bt%7D%7D%20%2B%20%5Cdfrac%7B1%7D%7B%5Crho%7D%5Cnabla%20p%20%3D0%20%26%2C%20pressure%2Fincompressibility%0A%5Cend%7Baligned%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>In advection part, quantity <img src="https://math.now.sh?inline=q" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is anything, not just velocity <img src="https://math.now.sh?inline=v" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><p>For body force part, forward euler <img src="https://math.now.sh?inline=u%20%3D%20u%20%2B%20%5CDelta%20t%20g" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is fine.</p><p>Pressure part is to make sure <img src="https://math.now.sh?inline=%5Cnabla%20%5Ccdot%20u%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>. Here we will project velocity and enforce the solid wall boundary conditions.</p><p>Advection should only be done in a divergence-free velocity field. So sequence matters.</p><ol><li><p>advect</p></li><li><p>add body force</p></li><li><p>project</p></li></ol><h3 id="Time-Steps">Time Steps</h3><p>Find a minimal time step that suits all steps: advect, add body force, project.</p><p>If frame interval <img src="https://math.now.sh?inline=t_%7Bframe%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> &gt; simulation delta time <img src="https://math.now.sh?inline=%5CDelta%20t" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, then run simulation multiple times, until total simulation time &gt;= <img src="https://math.now.sh?inline=t_%7Bframe%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><h3 id="MAC-Grid">MAC Grid</h3><h4 id="Problem-of-central-difference">Problem of central difference</h4><p>First-order central difference:</p><p><img src="https://math.now.sh?inline=%28%5Cdfrac%7B%5Cpartial%7Bq%7D%7D%7B%5Cpartial%7Bx%7D%7D%29_%7Bi%7D%20%5Capprox%20%5Cdfrac%7Bq_%7Bi%2B1%7D-q_%7Bi-1%7D%7D%7B2%5CDelta%20x%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>First-order forward or backward difference:</p><p><img src="https://math.now.sh?inline=%28%5Cdfrac%7B%5Cpartial%7Bq%7D%7D%7B%5Cpartial%7Bx%7D%7D%29_%7Bi%7D%20%5Capprox%20%5Cdfrac%7Bq_%7Bi%2B1%7D-q_%7Bi%7D%7D%7B%5CDelta%20x%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>First-order central difference has a major problem in that the derivative estimate at grid point i completely ignores the value qi sampled there.</p><p>Why ignoring qi is terrible: jagged function has more probability to be estimate as constant function. For example, <img src="https://math.now.sh?inline=q_i%20%3D%20%7B%28-1%29%7D%5E%7Bi%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> to produce <img src="https://math.now.sh?inline=%28%5Cdfrac%7B%5Cpartial%7Bq%7D%7D%7B%5Cpartial%7Bx%7D%7D%29_%7Bi%7D%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> using first-order central difference, but not using first-order forward or backward difference.</p><p>I think it is similar with Undersampling. Nyquist-Shannon sample Theorem says that for an accurate representation of the baseband signal, the sample rate must be at least twice the highest frequency component. Aliasing happens when the sampling rate falls below this limit (the Nyquist Rate).</p><p>Here you can analogize aliasing to <img src="https://math.now.sh?inline=%28%5Cdfrac%7B%5Cpartial%7Bq%7D%7D%7B%5Cpartial%7Bx%7D%7D%29_%7Bi%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> becoming close to 0.</p><figure style="width: 300px" class="align-center"><img src="/images/fluid_sim_reading_note/Undersampling.svg"><figcaption align = "center">Fig: Undersampling</figcaption></figure><h4 id="MAC-Velocity-Grid">MAC Velocity Grid</h4><p>MAC Grid is a staggered grid designed to solve incompressibility.</p><p>Why to use MAC Grid: we can use accurate central differences for the pressure gradient and for the divergence of the velocity field without the usual disadvantages of central differences</p><p>Pressure is defined at center of cell.</p><p><img src="https://math.now.sh?inline=u" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is defined at center of X plane of cell.</p><p><img src="https://math.now.sh?inline=v" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is defined at center of Y plane of cell.</p><p><img src="https://math.now.sh?inline=w" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is defined at center of Z plane of cell.</p><figure style="width: 700px" class="align-center"><img src="/images/fluid_sim_reading_note/mac_velocity_diagram-large-1.png"><figcaption align = "center">Fig: MAC Grid Veocity u</figcaption></figure><figure style="width: 700px" class="align-center"><img src="/images/fluid_sim_reading_note/mac_velocity_diagram-large-2.png"><figcaption align = "center">Fig: MAC Grid Veocity v</figcaption></figure><figure style="width: 700px" class="align-center"><img src="/images/fluid_sim_reading_note/mac_velocity_diagram-large-3.png"><figcaption align = "center">Fig: MAC Grid Veocity w</figcaption></figure><figure style="width: 592px" class="align-center"><img src="/images/fluid_sim_reading_note/One_cell_from_the_three-dimensional_MAC grid.png"><figcaption align = "center">Fig: One cell from the three-dimensional MAC grid</figcaption></figure><p>If pressure grid has dimensions <img src="https://math.now.sh?inline=nx%20%5Ctimes%20ny%20%5Ctimes%20nz" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, then <img src="https://math.now.sh?inline=u" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> grid has dimensions <img src="https://math.now.sh?inline=%28nx%20%2B%201%29%20%5Ctimes%20ny%20%5Ctimes%20nz" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=v" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> grid has dimensions <img src="https://math.now.sh?inline=nx%20%5Ctimes%20%28ny%20%2B%201%29%20%5Ctimes%20nz" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=w" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> grid has dimensions <img src="https://math.now.sh?inline=nx%20%5Ctimes%20ny%20%5Ctimes%20%28nz%20%2B%201%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><p>The half-index notation works well for describing velocity components in this document, but does not translate well into a programming implementation where arrays use integer indexing. The following table demonstrates how half-index notation will be translated into classic array integer indexing:</p><table><thead><tr><th style="text-align:center">Half Index</th><th style="text-align:center">Integer Index</th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://math.now.sh?inline=u_%7Bi-1%2F2%2Cj%2Ck%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></td><td style="text-align:center"><img src="https://math.now.sh?inline=u%28i%2Cj%2Ck%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></td></tr><tr><td style="text-align:center"><img src="https://math.now.sh?inline=u_%7Bi%2B1%2F2%2Cj%2Ck%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></td><td style="text-align:center"><img src="https://math.now.sh?inline=u%28i%2B1%2Cj%2Ck%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></td></tr><tr><td style="text-align:center"><img src="https://math.now.sh?inline=v_%7Bi%2Cj-1%2F2%2Ck%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></td><td style="text-align:center"><img src="https://math.now.sh?inline=v%28i%2Cj%2Ck%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></td></tr><tr><td style="text-align:center"><img src="https://math.now.sh?inline=v_%7Bi%2Cj%2B1%2F2%2Ck%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></td><td style="text-align:center"><img src="https://math.now.sh?inline=v%28i%2Cj%2B1%2Ck%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></td></tr><tr><td style="text-align:center"><img src="https://math.now.sh?inline=w_%7Bi%2Cj%2Ck-1%2F2%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></td><td style="text-align:center"><img src="https://math.now.sh?inline=w%28i%2Cj%2Ck%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></td></tr><tr><td style="text-align:center"><img src="https://math.now.sh?inline=w_%7Bi%2Cj%2Ck%2B1%2F2%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></td><td style="text-align:center"><img src="https://math.now.sh?inline=w%28i%2Cj%2Ck%2B1%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></td></tr></tbody></table><p>Using staggered grid, we can get unbiased second-order accuracy of a central difference:</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cbegin%7Balign*%7D%20%20%0A%20%20%20%20%5Cleft%28%20%5Cfrac%7B%5Cpartial%20u%7D%7B%5Cpartial%20x%7D%20%5Cright%29_%7Bi%2C%5C%20j%2C%5C%20k%20%7D%20%5Capprox%20%26%20%5C%20%0A%20%20%20%20%5Cfrac%7Bu_%7Bi%7B%2B%7D1%2F2%2C%5C%20j%2C%5C%20k%7D%20-%20u_%7Bi%7B-%7D1%2F2%2C%5C%20j%2C%5C%20k%7D%7D%7B%5CDelta%20x%7D%2C%20%5C%5C%5B1.5ex%5D%0A%20%20%20%20%5Cleft(%20%5Cfrac%7B%5Cpartial%20v%7D%7B%5Cpartial%20y%7D%20%5Cright)_%7Bi%2C%5C%20j%2C%5C%20k%20%7D%20%5Capprox%20%26%20%5C%20%0A%20%20%20%20%5Cfrac%7Bv_%7Bi%2C%5C%20j%7B%2B%7D1%2F2%2C%5C%20k%7D%20-%20v_%7Bi%2C%5C%20j%7B-%7D1%2F2%2C%5C%20k%7D%7D%7B%5CDelta%20x%7D%2C%20%5C%5C%5B1.5ex%5D%0A%20%20%20%20%5Cleft(%20%5Cfrac%7B%5Cpartial%20w%7D%7B%5Cpartial%20z%7D%20%5Cright)_%7Bi%2C%5C%20j%2C%5C%20k%20%7D%20%5Capprox%20%26%20%5C%20%0A%20%20%20%20%5Cfrac%7Bw_%7Bi%2C%5C%20j%2C%5C%20k%7B%2B%7D1%2F2%7D%20-%20w_%7Bi%2C%5C%20j%2C%5C%20k%7B-%7D1%2F2%7D%7D%7B%5CDelta%20x%7D%0A%5Cend%7Balign*%7D%0A" /></p><p>The staggered MAC grid is perfectly suited for handling pressure and incompressibility, but it’s frankly a pain for other uses. For example, if we actually want to evaluate the full velocity vector somewhere, we will always need to use some kind of interpolation even if we’re looking at a grid point.</p><p>For an arbitrary location:</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cbegin%7Balign%7D%0A%20%20%20%20%5Cvec%7Bu%7D_%7Bi%2C%5C%20j%2C%5C%20k%7D%5C%20%3D%20%26%20%5C%20%20%5Cleft%28%20%5Cfrac%7Bu_%7Bi%7B-%7D1%2F2%2C%5C%20j%2C%5C%20k%7D%20%2B%20u_%7Bi%7B%2B%7D1%2F2%2C%5C%20j%2C%5C%20k%7D%7D%7B2%7D%2C%20%5C%20%0A%20%20%20%20%5Cfrac%7Bv_%7Bi%2C%5C%20j%7B-%7D1%2F2%2C%5C%20k%7D%20%2B%20v_%7Bi%2C%5C%20j%7B%2B%7D1%2F2%2C%5C%20k%7D%7D%7B2%7D%2C%20%5C%20%0A%20%20%20%20%5Cfrac%7Bw_%7Bi%2C%5C%20j%2C%5C%20k%7B-%7D1%2F2%7D%20%2B%20w_%7Bi%2C%5C%20j%2C%5C%20k%7B%2B%7D1%2F2%7D%7D%7B2%7D%20%0A%20%20%20%20%5Cright%29%20%5C%5C%5B1.5ex%5D%0A%0A%20%20%20%20%5Cvec%7Bu%7D_%7Bi%7B%2B%7D1%2F2%2C%5C%20j%2C%5C%20k%7D%5C%20%3D%20%26%20%5C%20%20%5Cleft(%20u_%7Bi%7B%2B%7D1%2F2%2C%5C%20j%2C%5C%20k%7D%2C%20%5C%20%0A%20%20%20%20%5Cfrac%7B%0A%20%20%20%20%5Cbegin%7Balign%7D%0A%20%20%20%20%20%20%20%20v_%7Bi%2C%5C%20j%7B-%7D1%2F2%2C%5C%20k%7D%20%5C%20%2B%26%20%5C%20v_%7Bi%2C%5C%20j%7B%2B%7D1%2F2%2C%5C%20k%7D%20%5C%5C%5C%20%2B%20%5C%20v_%7Bi%7B%2B%7D1%2C%5C%20j%7B-%7D1%2F2%2C%5C%20k%7D%20%5C%20%2B%26%20%5C%20v_%7Bi%7B%2B%7D1%2C%5C%20j%7B%2B%7D1%2F2%2C%5C%20k%7D%0A%20%20%20%20%5Cend%7Balign%7D%7D%7B4%7D%2C%20%5C%20%0A%20%20%20%20%5Cfrac%7B%0A%20%20%20%20%5Cbegin%7Balign%7D%0A%20%20%20%20%20%20%20%20w_%7Bi%2C%5C%20j%2C%5C%20k%7B-%7D1%2F2%7D%20%5C%20%2B%26%20%5C%20w_%7Bi%2C%5C%20j%2C%5C%20k%7B%2B%7D1%2F2%7D%20%5C%5C%20%5C%20%2B%20%5C%20w_%7Bi%7B%2B%7D1%2C%5C%20j%2C%5C%20k%7B-%7D1%2F2%7D%20%5C%20%2B%26%20%5C%20w_%7Bi%7B%2B%7D1%2C%5C%20j%2C%5C%20k%7B%2B%7D1%2F2%7D%0A%20%20%20%20%5Cend%7Balign%7D%7D%7B4%7D%20%0A%20%20%20%20%5Cright)%20%5C%5C%5B1.5ex%5D%0A%0A%20%20%20%20%5Cvec%7Bu%7D_%7Bi%2C%5C%20j%7B%2B%7D1%2F2%2C%5C%20k%7D%5C%20%3D%20%26%20%5C%20%20%5Cleft(%20%5Cfrac%7B%0A%20%20%20%20%5Cbegin%7Balign%7D%0A%20%20%20%20%20%20%20%20u_%7Bi%7B-%7D1%2F2%2C%5C%20j%2C%5C%20k%7D%20%5C%20%2B%26%20%5C%20u_%7Bi%7B%2B%7D1%2F2%2C%5C%20j%2C%5C%20k%7D%20%5C%5C%20%5C%20%2B%20%5C%20u_%7Bi%7B-%7D1%2F2%2C%5C%20j%7B%2B%7D1%2C%5C%20k%7D%20%5C%20%2B%20%26%20%5C%20%20u_%7Bi%7B%2B%7D1%2F2%2C%5C%20j%7B%2B%7D1%2C%5C%20k%7D%0A%20%20%20%20%5Cend%7Balign%7D%7D%7B4%7D%2C%20%5C%20%0A%20%20%20%20v_%7Bi%2C%5C%20j%7B%2B%7D1%2F2%2C%5C%20k%7D%2C%20%5C%20%0A%20%20%20%20%5Cfrac%7B%0A%20%20%20%20%5Cbegin%7Balign%7D%0A%20%20%20%20%20%20%20%20w_%7Bi%2C%5C%20j%2C%5C%20k%7B-%7D1%2F2%7D%20%5C%20%2B%26%20%5C%20w_%7Bi%2C%5C%20j%2C%5C%20k%7B%2B%7D1%2F2%7D%20%5C%5C%20%5C%20%2B%20%5C%20w_%7Bi%2C%5C%20j%7B%2B%7D1%2C%5C%20k%7B-%7D1%2F2%7D%20%5C%20%2B%26%20%5C%20w_%7Bi%2C%5C%20j%7B%2B%7D1%2C%5C%20k%7B-%7D1%2F2%7D%0A%20%20%20%20%5Cend%7Balign%7D%7D%7B4%7D%0A%20%20%20%20%5Cright)%20%5C%5C%5B1.5ex%5D%0A%0A%20%20%20%20%5Cvec%7Bu%7D_%7Bi%2C%5C%20j%2C%5C%20k%7B%2B%7D1%2F2%7D%5C%20%3D%20%26%20%5C%20%20%5Cleft(%20%5Cfrac%7B%0A%20%20%20%20%5Cbegin%7Balign%7D%0A%20%20%20%20%20%20%20%20u_%7Bi%7B-%7D1%2F2%2C%5C%20j%2C%5C%20k%7D%20%5C%20%2B%26%20%5C%20u_%7Bi%7B%2B%7D1%2F2%2C%5C%20j%2C%5C%20k%7D%20%5C%5C%20%5C%20%2B%20%5C%20u_%7Bi%7B-%7D1%2F2%2C%5C%20j%2C%5C%20k%7B%2B%7D1%7D%20%5C%20%2B%26%20%5C%20u_%7Bi%7B%2B%7D1%2F2%2C%5C%20j%2C%5C%20k%7B%2B%7D1%7D%0A%20%20%20%20%5Cend%7Balign%7D%7D%7B4%7D%2C%20%5C%20%0A%20%20%20%20%5Cfrac%7B%0A%20%20%20%20%5Cbegin%7Balign%7D%0A%20%20%20%20%20%20%20%20v_%7Bi%2C%5C%20j%7B-%7D1%2F2%2C%5C%20k%7D%20%5C%20%2B%26%20%5C%20v_%7Bi%2C%5C%20j%7B%2B%7D1%2F2%2C%5C%20k%7D%20%5C%5C%20%5C%20%2B%20%5C%20v_%7Bi%2C%5C%20j%7B-%7D1%2F2%2C%5C%20k%7B%2B%7D1%7D%20%5C%20%2B%26%20%5C%20v_%7Bi%2C%5C%20j%7B%2B%7D1%2F2%2C%5C%20k%7B%2B%7D1%7D%0A%20%20%20%20%5Cend%7Balign%7D%7D%7B4%7D%2C%20%5C%20%0A%20%20%20%20w_%7Bi%2C%5C%20j%2C%5C%20k%7B%2B%7D1%2F2%7D%0A%20%20%20%20%5Cright)%20%5C%5C%5B1.5ex%5D%0A%5Cend%7Balign%7D%0A" /></p><h3 id="Dynamic-Sparse-Grids">Dynamic Sparse Grids</h3><p>Problem:</p><ol><li><p>If fluid region change over time, using a static grid that covers the entire region can be wasteful</p><p>Solution: Adjust the grid dimensions and where it lies in space at every time step</p><ul><li><p>For fluid: water surface with padding</p></li><li><p>For smoke: smoke can extends into whole space. So calc SDF according smoke concentration.</p></li></ul></li><li><p>Memory access efficiency on modren hardware</p><p>Assume that grid is row-major layout, and row order is <img src="https://math.now.sh?inline=i%2Cj%2Ck" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>. Distance between <img src="https://math.now.sh?inline=%28i%2Cj%2Ck%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=%28i%2B1%2Cj%2Ck%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> will be <img src="https://math.now.sh?inline=ny%20%5Ctimes%20nz" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>So we can expect more page faults and cache misses.</p></li><li><p>Fluid occupies only a small fraction of the volume of its bounding box</p><p>For example: river, waterfall, pouring water…</p></li></ol><p>Using hash table to map index to a large virtual grid (such as <img src="https://math.now.sh?inline=2%5E%7B32%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> along each dimension by signed 32-bit integers in each coordinate). The grid is large enough so you don’t need to move grid origin.</p><p>Since we only store the blocks of the grid we care about, this is a sparse structure and we don’t waste storage or processing on voxels far from the action…</p><p>Because we map blocks of voxels rather than individual voxels, the overhead of the associative data structure can be minimized; meanwhile operations inside a block have extremely good data locality.</p><h3 id="Code-2D-before-3D">Code 2D before 3D</h3><p>Bug about copying and pasting</p><h2 id="Chapter-3-Advection-Algorithms">Chapter 3: Advection Algorithms</h2><p>Advection should only be called with a divergence-free velocity field</p><h3 id="Semi-Lagrangian-Advection">Semi-Lagrangian Advection</h3><h4 id="Forward-Euler">Forward Euler</h4><p>Forward Euler is unconditionally unstable.</p><p>About stability region of forward Euler. The eigenvalues of the Jacobian generated by the central difference are pure imaginary, thus always outside the region of stability.</p><h4 id="Problem-of-spatial-discretization">Problem of spatial discretization</h4><p>Difference seems like pretty accurate estimate of the derivative, but it has dispersion problem.</p><p>High-frequency jagged components of quantity, like <img src="https://math.now.sh?inline=%28%E2%88%921%29%5Ei" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, erroneously register as having zero or near-zero spatial derivative, and so don’t get evolved forward in time or at least move much more slowly than the velocity u they should move at.</p><p>Meanwhile the low frequency components are handled accurately and move at almost exactly the right speed u. Thus the low frequency components end up separating out from the high-frequency components, and you are left with all sorts of strange high-frequency wiggles and oscillations appearing and persisting that shouldn’t be there!</p><blockquote><p>I have known two kinds of problem in discretization: dissipation and dispersion, but I think the view of frequency is novel. When I learnt compute fluid, I had no concept about it.</p></blockquote><h4 id="Semi-Lagrangian-Advection-2">Semi-Lagrangian Advection</h4><p>…</p><blockquote><p>I have learnt it when reading Stable Fluid.</p></blockquote><p>If you are using MAC Grid, then your advence velocity should be interpolated from MAC Grid.</p><h3 id="Boundary-Conditions-2">Boundary Conditions</h3><p>When backtrace the start point of particle, it may locate outside of boundary.</p><p>Two reasons:</p><ol><li><p>The start point is in inlet</p></li><li><p>The start point shouldn’t be outside, it is about numerical error about forward Euler or Runge-Kutta step when calculate the position of start point</p></li></ol><p>The first reason is artificially designed, we have known inlet condition to solve it.</p><p>For the second reason, the appropriate strategy is to extrapolate the quantity from the nearest point on the boundary. So the start point outside can use the extrapolated quantity.</p><p>If the quantity outside is known, then extrapolation will be easy.</p><p>If the quantity outside is unknown, there is two ways:</p><ol><li><p>Extrapolation</p></li><li><p>For fluid:</p><p>Find nearest point in fluid surface, which means minimize the distance from surface to start point, then interpolate quantity at the nearest point found.</p><p>For solid wall:</p><p>Normal velocity condition, or for viscous flow, take the shortcut of just using the solid’s velocity.</p></li></ol><h3 id="Time-Step-Size">Time Step Size</h3><p>Semi-Lagrangian Advection is unconditionally stable, becuase new value is copied from old value, so new value will never be larger than old value.</p><blockquote><p>To avoid artifacts, time step still has limit? I haven’t try it.</p></blockquote><h4 id="CFL-condition">CFL condition</h4><p>From view of domain of dependence, the numerical domain of dependence, at least in the limit, must contain the true domain of dependence if we want to get the correct answer.</p><p>CFL condition depicts how small your <img src="https://math.now.sh?inline=%5CDelta%20t%2C%20%5CDelta%20x" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is can you say close to limit.</p><p>CFL condition: to make result accurate</p><p>stability condition: to make update stable</p><p>CFL number: a parameter in CFL condition</p><p>CFL number represents the maximum number of grid cells the information can propagate</p><p>If a method unconditionally unstable but fit CFL condition, it will still covergence to accurate result.</p><h4 id="Diffusion">Diffusion</h4><p>Assume that we have find start point of particle, then we should know the quantity at start point, so we use interpolation. It introduces diffusion, or in signal-processing terminology, we have a low-pass filter.</p><p>Prove the Semi-Lagrangian Advection introduce dissipation</p><p>…</p><h4 id="Reducing-Numerical-Diffusion">Reducing Numerical Diffusion</h4><p>As we saw in the last section, the problem mainly lies with the excessive averaging induced by linear interpolation (of the quantity being<br>; linearly interpolating the velocity field in which we trace is not the main culprit and can be used as is).</p><p>Solution: use sharper interpolation</p><p>Cubic Interpolation:</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cbegin%7Balign%7D%0A%20%20%20%20f%28q_%7Bi-1%7D%2C%5C%20q_%7Bi%7D%2C%5C%20q_%7Bi%2B1%7D%2C%5C%20q_%7Bi%2B2%7D%2C%5C%20x%29%20%3D%20%5C%20%26%5B-%5Cdfrac%7B1%7D%7B3%7Ds%2B%5Cdfrac%7B1%7D%7B2%7Ds%5E2-%5Cdfrac%7B1%7D%7B6%7Ds%5E3%5Dq_%7Bi-1%7D%20%5C%5C%0A%20%20%20%20%26%2B%20%5B1-s%5E2%2B%5Cdfrac%7B1%7D%7B2%7D(s%5E3-s)%5Dq_%7Bi%7D%20%5C%5C%0A%20%20%20%20%26%2B%20%5Bs%2B%5Cdfrac%7B1%7D%7B2%7D(s%5E2-s%5E3)%5Dq_%7Bi%2B1%7D%20%5C%5C%0A%20%20%20%20%26%2B%20%5B%5Cdfrac%7B1%7D%7B6%7D(s%5E3-s)%5Dq_%7Bi%2B2%7D%0A%5Cend%7Balign%7D%0A" /></p><p>Where <img src="https://math.now.sh?inline=s" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> means fraction between grid points <img src="https://math.now.sh?inline=x_i" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=x_%7Bi%2B1%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>. So <img src="https://math.now.sh?inline=s%3D-1" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> means <img src="https://math.now.sh?inline=x_%7Bi-1%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=s%3D0" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> means <img src="https://math.now.sh?inline=x_%7Bi%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=s%3D1" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> means <img src="https://math.now.sh?inline=x_%7Bi%2B1%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=s%3D2" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> means <img src="https://math.now.sh?inline=x_%7Bi%2B2%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><p>It can be derived from Lagrange Interpolation, base point are <img src="https://math.now.sh?inline=%28-1%2C%20q_%7Bi-1%7D%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%280%2C%20q_%7Bi%7D%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%281%2C%20q_%7Bi%2B1%7D%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%282%2C%20q_%7Bi%2B2%7D%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><p>This algorithm also has another form. Derived from another way <a href="http://www.paulinternet.nl/?page=bicubic">Paul Bourke’s Cubic Interpolation Page</a></p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cbegin%7Balign%7D%0A%20%20%20%20f%28p_0%2C%5C%20p_1%2C%5C%20p_2%2C%5C%20p_3%2C%5C%20x%29%20%3D%20%5C%20%26(-%5Ctfrac%7B1%7D%7B2%7Dp_0%20%2B%20%5Ctfrac%7B3%7D%7B2%7Dp_1%20-%20%5Ctfrac%7B3%7D%7B2%7Dp_2%20%2B%20%5Ctfrac%7B1%7D%7B2%7Dp_3)x%5E3%20%5C%5C%0A%20%20%20%20%26%2B%20(p_0%20-%20%5Ctfrac%7B5%7D%7B2%7Dp_1%20%2B%202p_2%20-%20%5Ctfrac%7B1%7D%7B2%7Dp_3)x%5E2%20%5C%5C%0A%20%20%20%20%26%2B%20(-%5Ctfrac%7B1%7D%7B2%7Dp_0%20%2B%20%5Ctfrac%7B1%7D%7B2%7Dp_2)x%20%5C%5C%0A%20%20%20%20%26%2B%20p_1%0A%5Cend%7Balign%7D%0A" /></p><p>Where <img src="https://math.now.sh?inline=x" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is same as <img src="https://math.now.sh?inline=s" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> below.</p><p>In two or three dimensions, you can cubic interpolation sequentially.</p><p>Code example for 3D:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cubicInterpolate</span><span class="params">(<span class="type">double</span> p[<span class="number">4</span>], <span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[<span class="number">1</span>] + <span class="number">0.5</span> * x*(p[<span class="number">2</span>] - p[<span class="number">0</span>] + </span><br><span class="line">                           x*(<span class="number">2.0</span>*p[<span class="number">0</span>] - <span class="number">5.0</span>*p[<span class="number">1</span>] + <span class="number">4.0</span>*p[<span class="number">2</span>] - p[<span class="number">3</span>] + </span><br><span class="line">                              x*(<span class="number">3.0</span>*(p[<span class="number">1</span>] - p[<span class="number">2</span>]) + p[<span class="number">3</span>] - p[<span class="number">0</span>])));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bicubicInterpolate</span><span class="params">(<span class="type">double</span> p[<span class="number">4</span>][<span class="number">4</span>], <span class="type">double</span> x, <span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> arr[<span class="number">4</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="built_in">cubicInterpolate</span>(p[<span class="number">0</span>], x);</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="built_in">cubicInterpolate</span>(p[<span class="number">1</span>], x);</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="built_in">cubicInterpolate</span>(p[<span class="number">2</span>], x);</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="built_in">cubicInterpolate</span>(p[<span class="number">3</span>], x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cubicInterpolate</span>(arr, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">tricubicInterpolate</span><span class="params">(<span class="type">double</span> p[<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>], <span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> arr[<span class="number">4</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="built_in">bicubicInterpolate</span>(p[<span class="number">0</span>], x, y);</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="built_in">bicubicInterpolate</span>(p[<span class="number">1</span>], x, y);</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="built_in">bicubicInterpolate</span>(p[<span class="number">2</span>], x, y);</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="built_in">bicubicInterpolate</span>(p[<span class="number">3</span>], x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cubicInterpolate</span>(arr, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The weighting coefficients may be negative.</p><h2 id="Chapter-4-Level-Set-Geometry">Chapter 4: Level Set Geometry</h2><ol><li><p>when is a point inside a solid? (the point may be where we traced back to during semi-Lagrangian)</p></li><li><p>what is the closest point on the surface of some geometry?</p></li><li><p>how do we extrapolate values from one region into another?</p></li></ol><h3 id="SDF">SDF</h3><figure style="width: 567px" class="align-center"><img src="/images/fluid_sim_reading_note/sdf_field.png"><figcaption align = "center">Fig: SDF Field. Taken from "Fluid Engine Development"</figcaption></figure><p><img src="https://math.now.sh?inline=%5Cvert%5Cvert%20%5Cnabla%20%5Cphi%28x%29%20%5Cvert%5Cvert%20%3D%201" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><ul><li><p>outside the geometry, <img src="https://math.now.sh?inline=-%5Cnabla%20%5Cphi%28x%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is the unit-length vector pointing towards the closest point on the surface</p></li><li><p>inside the geometry, <img src="https://math.now.sh?inline=%5Cnabla%20%5Cphi%28x%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is the unit-length vector pointing towards the closest point on the surface</p></li><li><p>and on the surface, <img src="https://math.now.sh?inline=%5Cnabla%20%5Cphi%28x%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is the unit-length outward-pointing normal.</p></li></ul><p>This means <img src="https://math.now.sh?inline=x%20-%20%5Cphi%28x%29%5Cnabla%20%5Cphi(x)" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is the closest point on the surface for any point <img src="https://math.now.sh?inline=x" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><p>SDF can also be defined as <img src="https://math.now.sh?inline=%5Cphi%28x%29%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> at boundary.</p><p>SDF can handle topological change easily. To merge two surface, just get minimum value of two SDF.</p><figure style="width: 595px" class="align-center"><img src="/images/fluid_sim_reading_note/sdf_topology.png"><figcaption align = "center">Fig: SDF Topology. Taken from "Fluid Engine Development"</figcaption></figure><h4 id="Reinitializing-SDF">Reinitializing SDF</h4><p>After advection, the SDF field can not keep its distance property. So we should recover it. Luckily, only the SDF value on the surface is correct. So the reinitializeing can start from surface.</p><figure style="width: 626px" class="align-center"><img src="/images/fluid_sim_reading_note/sdf_reinitialize.png"><figcaption align = "center">Fig: SDF Reinitializing. Taken from "Fluid Engine Development"</figcaption></figure><p>Here we prove why the value on the surface is correct.</p><p>We can use the advection equation (Equation 3.23) with extra source term to model this propagation problem.</p><p><img src="https://math.now.sh?inline=%5Cdfrac%7B%5Cpartial%7B%5Cphi%7D%7D%7B%5Cpartial%7B%5Ctau%7D%7D%2B%5Cmathbf%7Bu%7D%20%5Ccdot%20%5Cnabla%20%5Cphi%20%3D%201" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%5Ctau" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is pseudo-time, because it is not physics simulation but more like a geometric postprocessing.</p><p>If source term in right hand side is 0, it means <img src="https://math.now.sh?inline=%5Cphi" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is only carried by the vector field <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>. If a constant <img src="https://math.now.sh?inline=c" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is assigned, it means <img src="https://math.now.sh?inline=c" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is added to <img src="https://math.now.sh?inline=%5Cphi" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> when it travels one distance unit along <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><p>Thus, setting the right-hand side to 1 means we will assign the traveled distance to <img src="https://math.now.sh?inline=%5Cphi" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><p>We have discuss the gredient of <img src="https://math.now.sh?inline=%5Cphi" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> before, we know that if we assign <img src="https://math.now.sh?inline=%5Cphi" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> as distance, then the gredient is 1, it means when <img src="https://math.now.sh?inline=%5Cphi" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> travels one distance unit in space along the steepest direction, the value of <img src="https://math.now.sh?inline=%5Cphi" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> increase 1.</p><p>So if we assign gredient of <img src="https://math.now.sh?inline=%5Cphi" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> as direction of reinitializing velocity, then the advection equation will fit its physical meaning.</p><p>In other word, substitute</p><p><img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D%20%3D%20%5Cdfrac%7B%5Cnabla%20%5Cphi%7D%7B%5Cvert%20%5Cnabla%20%5Cphi%20%5Cvert%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>into advection equation, get</p><p><img src="https://math.now.sh?inline=%5Cdfrac%7B%5Cpartial%7B%5Cphi%7D%7D%7B%5Cpartial%7B%5Ctau%7D%7D%2B%5Cdfrac%7B%5Cnabla%20%5Cphi%7D%7B%5Cvert%20%5Cnabla%20%5Cphi%20%5Cvert%7D%20%5Ccdot%20%5Cnabla%20%5Cphi%20%3D%201" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>which can be further simplified to</p><p><img src="https://math.now.sh?inline=%5Cdfrac%7B%5Cpartial%7B%5Cphi%7D%7D%7B%5Cpartial%7B%5Ctau%7D%7D%2B%28%5Cvert%20%5Cnabla%20%5Cphi%20%5Cvert%20-%201%29%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>Reinitialize outward from the surface, the direction is the same as the gradient, <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D%20%3D%20%5Cdfrac%7B%5Cnabla%20%5Cphi%7D%7B%5Cvert%20%5Cnabla%20%5Cphi%20%5Cvert%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><p>On the contrary, reinitialize inward from the surface, we have <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D%20%3D%20-%5Cdfrac%7B%5Cnabla%20%5Cphi%7D%7B%5Cvert%20%5Cnabla%20%5Cphi%20%5Cvert%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>. Similarly, we have</p><p><img src="https://math.now.sh?inline=%5Cdfrac%7B%5Cpartial%7B%5Cphi%7D%7D%7B%5Cpartial%7B%5Ctau%7D%7D-%28%5Cvert%20%5Cnabla%20%5Cphi%20%5Cvert%20-%201%29%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>In summary, reinitializing equation is</p><p><img src="https://math.now.sh?inline=%5Cdfrac%7B%5Cpartial%7B%5Cphi%7D%7D%7B%5Cpartial%7B%5Ctau%7D%7D%2Bsign%28%5Cphi%29(%5Cvert%20%5Cnabla%20%5Cphi%20%5Cvert%20-%201)%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><h4 id="Medial-Axis">Medial Axis</h4><p>SDF is smooth everywhere except on the medial axis</p><p>The medial axis is exactly where there isn’t a unique closest point, such as the center of a sphere and the middle plane inside a flat slab.</p><p>Discussion about the gradient <img src="https://math.now.sh?inline=%5Cnabla%20%5Cphi%28x%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> breaks down on the medial axis, because the function isn’t differentiable there.</p><h4 id="Discretizing-Signed-Distance-Functions">Discretizing Signed Distance Functions</h4><p>Level set method: signed distance function that has been sampled on a grid</p><p>How to get <img src="https://math.now.sh?inline=%5Cdfrac%7B%5Cpartial%7B%5Cphi%7D%7D%7B%5Cpartial%7Bx%7D%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> at any point? There are two ways:</p><ol><li><p>Interpolate <img src="https://math.now.sh?inline=%5Cphi" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> nearby the given point, then differentiate the interpolant of <img src="https://math.now.sh?inline=%5Cphi" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p></li><li><p>Differentiate <img src="https://math.now.sh?inline=%5Cphi" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> at the grid point nearby the given point, then interpolate between <img src="https://math.now.sh?inline=%5Cdfrac%7B%5Cpartial%7B%5Cphi%7D%7D%7B%5Cpartial%7Bx%7D%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> which lie in grid.</p></li></ol><p>Usually use thel later way, because if interpolate first, interpolant of <img src="https://math.now.sh?inline=%5Cphi" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> may have discontinuities in their derivative between grid cells.</p><h4 id="Computing-Signed-Distance">Computing Signed Distance</h4><ol><li><p>from geom etry (finding closest points and measuring the distance to them).</p><p>geometry is explicitly known</p></li><li><p>from PDEs (solving the Eikonal equation <img src="https://math.now.sh?inline=%5Cvert%5Cvert%20%5Cnabla%20%5Cphi%28x%29%20%5Cvert%5Cvert%20%3D%201" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>).</p><p>geometry isn’t explicitly known</p></li></ol><h5 id="Distance-to-Points">Distance to Points</h5><p>This is algorithm 4 in:</p><p>Y.-H. R. Tsai. Rapid and accurate computation of the distance function using grids. J. Comput. Phys., 178(1):175–195, 2002</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nx):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(ny):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(nz):</span><br><span class="line">            phi[i][j][k] = infty  <span class="comment"># A 3D array of distances</span></span><br><span class="line">            t[i][j][k] = -<span class="number">1</span>  <span class="comment"># A 3D array of integer indices for the closest point</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the arrays near the input geometry</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(all_input_points)):</span><br><span class="line">    pe = all_input_points[e]</span><br><span class="line">    (i,j,k) = get_grid_index_from_position(pe)</span><br><span class="line"></span><br><span class="line">    d = length(vec3(i,j,k) - pe)</span><br><span class="line">    <span class="keyword">if</span> d &lt; phi[i][j][k]:</span><br><span class="line">        phi[i][j][k] = d</span><br><span class="line">        t[i][j][k] = e</span><br><span class="line"></span><br><span class="line"><span class="comment"># Propagate closest point and distance estimates to the rest of the grid</span></span><br><span class="line">loop (i,j,k) <span class="keyword">in</span> a chosen order:</span><br><span class="line">    foreach neighboring grid point (i2,j2,k2) worth considering:</span><br><span class="line">        e = t[i2][j2][k2]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> e != -<span class="number">1</span>:</span><br><span class="line">            pe = all_input_points[e]</span><br><span class="line"></span><br><span class="line">            d = length(vec3(i,j,k) - pe)</span><br><span class="line">            <span class="keyword">if</span> d &lt; phi[i][j][k]:</span><br><span class="line">                phi[i][j][k] = d</span><br><span class="line">                t[i][j][k] = e</span><br></pre></td></tr></table></figure><p>In the first stage we compute exact distance and closest point information directly in the grid cells that surrounding the input points.</p><p>The second stage can efficiently propagate information from neighbor to neighbor through the grid.</p><p>Both stages don’t need extra data structures.</p><h5 id="Loop-Order">Loop Order</h5><p>Two kinds of loop order when propagating information</p><ol><li><p>fast marching method</p></li><li><p>fast sweeping method</p></li></ol><h6 id="Fast-Marching-Method">Fast Marching Method</h6><p>Grid points should get information about the distance to the geometry from points that are closer, not the other way around</p><p>So loop over the grid points going from the closest to the furthest</p><p>Facilitated by storing unknown grid points in a priority queue (typically implemented as a heap) keyed by the current estimate of their distance.</p><p>Each update, remove the minimum</p><p>O(nlogn)</p><h6 id="Fast-Sweeping-Method">Fast Sweeping Method</h6><p>For any grid point, in the end its closest point information is going to come to it from one particular direction in the grid—e.g., from (i + 1, j, k), or maybe from (i, j − 1, k), and so on. To ensure that the information can propagate in the right direction, we thus sweep through the grid points in all possible loop orders: i ascending or descending, j ascending or descending, k ascending or descending.</p><p>8 combinations in 3D.</p><p>For more accuracy, we can repeat the sweeps again; in practice two times through the sweep gives excellent results</p><p>O(n), no extra data structures</p><h6 id="When-using-sparse-tiled-grids">When using sparse tiled grids</h6><p>In this case, a hybrid approach is possible. We can run fast sweeping efficiently inside a tile to update distances based on information in the tile and its neighbors, but we can choose the order in which to solve tiles (and re-solve them when neighbors are updated) in a fast marching style. Begin with the tiles containing input points as the set to “redistance”. Whenever a tile has been redistanced with fast sweeping, check to see if the distance value in any face neighbor is more than ∆x larger than the distance stored in this tile: if so, add the neighboring tile to the set needing redistancing.</p><blockquote><p>I can’t understand it.</p></blockquote><h5 id="Finding-Signed-Distance-for-a-Triangle-Mesh">Finding Signed Distance for a Triangle Mesh</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nx):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(ny):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(nz):</span><br><span class="line">            phi[i][j][k] = infty  <span class="comment"># A 3D array of distances</span></span><br><span class="line">            t[i][j][k] = -<span class="number">1</span>  <span class="comment"># A 3D array of integer indices for the closest point</span></span><br><span class="line">            c[i][j][k] = <span class="number">0</span>  <span class="comment"># A 3D array of integers to keep intersection counts along grid edges</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the arrays near the input geometry</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(all_input_triangles)):</span><br><span class="line">    Te = all_input_triangles[e]</span><br><span class="line">    loop grid edges (i,j,k)-(i+<span class="number">1</span>,j,k) which exactly intersect triangle Te  <span class="comment"># consistently breaking ties at endpoints</span></span><br><span class="line">        c[i][j][k]++</span><br><span class="line"></span><br><span class="line">        d = distance_to_triangle(vec3(i,j,k), Te)</span><br><span class="line">        <span class="keyword">if</span> d &lt; phi[i][j][k]:</span><br><span class="line">            phi[i][j][k] = d</span><br><span class="line">            t[i][j][k] = e</span><br><span class="line"></span><br><span class="line"><span class="comment"># Propagate closest triangle and distance estimates to the rest of the grid</span></span><br><span class="line">loop (i,j,k) <span class="keyword">in</span> a chosen order:</span><br><span class="line">    foreach neighboring grid point (i2,j2,k2) worth considering:</span><br><span class="line">        e = t[i2][j2][k2]</span><br><span class="line">        <span class="keyword">if</span> e != -<span class="number">1</span>:</span><br><span class="line">            Te = all_input_triangles[e]</span><br><span class="line"></span><br><span class="line">            d = distance_to_triangle(vec3(i,j,k), Te)</span><br><span class="line">            <span class="keyword">if</span> d &lt; phi[i][j][k]:</span><br><span class="line">                phi[i][j][k] = d</span><br><span class="line">                t[i][j][k] = e</span><br><span class="line"></span><br><span class="line"><span class="comment"># Determine signs for inside/outside</span></span><br><span class="line">foreach horizontal grid line (j,k):</span><br><span class="line">    C = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nx):</span><br><span class="line">        <span class="keyword">if</span> C % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            phi[i][j][k] = -phi[i][j][k]</span><br><span class="line">        C += c[i][j][k]</span><br></pre></td></tr></table></figure><p>Fast sweeping, fast marching, or a hybrid tiled combination can also be used.</p><h6 id="Computing-the-distance-between-a-point-and-a-triangle">Computing the distance between a point and a triangle</h6><p>Mark W. Jones. 3d distance from a point to a triangle. Technical report, Department of Computer Science, University of Wales, 1995</p><p>Assume we are computing the distance between point pe and triangle Te. Firstly, we should find closest point for pe in the triangle,</p><p>…</p><h2 id="Chapter-5-Making-Fluids-Incompressible">Chapter 5: Making Fluids Incompressible</h2><h3 id="Project">Project</h3><p>To solve <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cmathrm%7BD%7D%5Cmathbf%7Bu%7D%7D%7B%5Cmathrm%7BD%7Dt%7D%2B%5Cfrac%7B1%7D%7B%5Crho%7D%5Cnabla%20p%3D0" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, use forward euler:</p><p><img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7Bn%2B1%7D%20%3D%20%5Cmathbf%7Bu%7D%20-%20%5CDelta%20t%20%5Cdfrac%7B1%7D%7B%5Crho%7D%5Cnabla%20p" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>The solving result should met divergence-free condition:</p><p><img src="https://math.now.sh?inline=%5Cnabla%5Ccdot%5Cmathbf%7Bu%7D%5E%7Bn%2B1%7D%3D0" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>These two equations should be combined to solve pressure, we will see how to discrete them next, and how to substitute one into another.</p><p>For the first equation:</p><p><img src="https://math.now.sh?inline=u_%7Bi%2B1%2F2%2Cj%2Ck%7D%5E%7Bn%2B1%7D%3Du_%7Bi%2B1%2F2%2Cj%2Ck%7D-%5CDelta%20t%20%5Cdfrac%7B1%7D%7B%5Crho%7D%20%5Cdfrac%7Bp_%7Bi%2B1%2Cj%2Ck%7D-p_%7Bi%2Cj%2Ck%7D%7D%7B%5CDelta%20x%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=v_%7Bi%2Cj%2B1%2F2%2Ck%7D%5E%7Bn%2B1%7D%3Dv_%7Bi%2Cj%2B1%2F2%2Ck%7D-%5CDelta%20t%20%5Cdfrac%7B1%7D%7B%5Crho%7D%20%5Cdfrac%7Bp_%7Bi%2Cj%2B1%2Ck%7D-p_%7Bi%2Cj%2Ck%7D%7D%7B%5CDelta%20y%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=w_%7Bi%2Cj%2Ck%2B1%2F2%7D%5E%7Bn%2B1%7D%3Dw_%7Bi%2Cj%2Ck%2B1%2F2%7D-%5CDelta%20t%20%5Cdfrac%7B1%7D%7B%5Crho%7D%20%5Cdfrac%7Bp_%7Bi%2Cj%2Ck%2B1%7D-p_%7Bi%2Cj%2Ck%7D%7D%7B%5CDelta%20z%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>For the second equation:</p><p><img src="https://math.now.sh?inline=%5Cdfrac%7Bu%5E%7Bn%2B1%7D_%7Bi%2B1%2F2%2Cj%2Ck%7D-u%5E%7Bn%2B1%7D_%7Bi-1%2F2%2Cj%2Ck%7D%7D%7B%5CDelta%20x%7D%20%2B%20%5Cdfrac%7Bv%5E%7Bn%2B1%7D_%7Bi%2Cj%2B1%2F2%2Ck%7D-v%5E%7Bn%2B1%7D_%7Bi%2Cj-1%2F2%2Ck%7D%7D%7B%5CDelta%20y%7D%20%2B%20%5Cdfrac%7Bw%5E%7Bn%2B1%7D_%7Bi%2Cj%2Ck%2B1%2F2%7D-w%5E%7Bn%2B1%7D_%7Bi%2Cj%2Ck-1%2F2%7D%7D%7B%5CDelta%20z%7D%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>Assume <img src="https://math.now.sh?inline=%5CDelta%20x%20%3D%20%5CDelta%20y%20%3D%20%5CDelta%20z" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, substitute the <img src="https://math.now.sh?inline=u%5E%7Bn%2B1%7D%2Cv%5E%7Bn%2B1%7D%2Cw%5E%7Bn%2B1%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>:</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cbegin%7Balign*%7D%0A%20%20%20%26%20%5Cdfrac%7B%5CDelta%20t%7D%7B%5Crho%5CDelta%20x%5E2%7D%286p_%7Bi%2Cj%2Ck%7D-p_%7Bi%2B1%2Cj%2Ck%7D-p_%7Bi%2Cj%2B1%2Ck%7D-p_%7Bi%2Cj%2Ck%2B1%7D-p_%7Bi-1%2Cj%2Ck%7D-p_%7Bi%2Cj-1%2Ck%7D-p_%7Bi%2Cj%2Ck-1%7D%29%20%3D%20%5C%5C%0A%20%20%20%20%26%20-(%5Cdfrac%7Bu_%7Bi%2B1%2F2%2Cj%2Ck%7D-u_%7Bi-1%2F2%2Cj%2Ck%7D%7D%7B%5CDelta%20x%7D%20%2B%20%5Cdfrac%7Bv_%7Bi%2Cj%2B1%2F2%2Ck%7D-v_%7Bi%2Cj-1%2F2%2Ck%7D%7D%7B%5CDelta%20x%7D%20%2B%20%5Cdfrac%7Bw_%7Bi%2Cj%2Ck%2B1%2F2%7D-w_%7Bi%2Cj%2Ck-1%2F2%7D%7D%7B%5CDelta%20x%7D)%0A%5Cend%7Balign*%7D%0A" /></p><p>This equation can be written in matrix form as <img src="https://math.now.sh?inline=Ap%3Db" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>. It is easy to know that A is a sparse matrix.</p><p>This system of linear algebraic equations can be solved using direct or iterative methods.</p><p>Considering that the fluid domain can be large and the direct method computationally expensive, using an iterative method may be a better option. Commonly, efficient iterative methods such as conjugate gradient method is used, and acceleration algorithms include preconditioner method and regional equilibrium decomposition algorithm is also used.</p><p>When actually constructing Poisson’s equation, boundary conditions also need to be taken into consideration.</p><blockquote><p>It is my understanding when I read the book firstly.</p><p>After I read other’s, I found that forward Euler is to find fucture state <code>n+1</code> with current state <code>n</code>, and backward Euler is to update current state <code>n</code> with known fucture state <code>n+1</code>.</p><p>So that is why each elements in forward Euler can be calcuated parallelly, but each elements in backward Euler are coupled. In forward Euler, if you want to predict a point, you only need to fetch its neighbor points’ old value. These old value are read-only. But in backward Euler, to update a point, the neighbor you fetch is also required to be writed when updating other points.</p><p>Elements are coupled means that you should solve a <img src="https://math.now.sh?inline=Ax%3Db" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> problem.</p><p>As for pressure solving, The forward-style method would take the current density error to compute pressure. So, in backward sense, we would deduce the pressure by saying that this still-unknown pressure will make the density error to zero. The zero density error means that the density should remain constant, and that leads to <img src="https://math.now.sh?inline=%5Cnabla%5Ccdot%5Cmathbf%7Bu%7D%5E%7Bn%2B1%7D%3D0" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>So it is natural to substitute <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7Bn%2B1%7D%20%3D%20%5Cmathbf%7Bu%7D%20-%20%5CDelta%20t%20%5Cdfrac%7B1%7D%7B%5Crho%7D%5Cnabla%20p" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> into <img src="https://math.now.sh?inline=%5Cnabla%5Ccdot%5Cmathbf%7Bu%7D%5E%7Bn%2B1%7D%3D0" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p></blockquote><h3 id="Why-is-it-called-projection">Why is it called projection?</h3><p>According to Helmholtz-Hodge Decomposition, states that any vector field <img src="https://math.now.sh?inline=%5Cmathrm%7B%5Cmathbf%7Bw%7D%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> can uniquely be decomposed into a divergence-free vector field adding with a gredient of a scalar field.</p><p><img src="https://math.now.sh?inline=%5Cmathrm%7B%5Cmathbf%7Bw%7D%7D%20%3D%20%5Cmathrm%7B%5Cmathbf%7Bu%7D%7D%20%2B%20%5Cnabla%20q." style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>Where <img src="https://math.now.sh?inline=%5Cnabla%20%5Ccdot%20%5Cmathrm%7B%5Cmathbf%7Bu%7D%7D%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><p>Poisson equation can be derived from this equation by multiplying both sides by “<img src="https://math.now.sh?inline=%5Cnabla" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>”.</p><p><img src="https://math.now.sh?inline=%5Cnabla%20%5Ccdot%20%5Cmathrm%7B%5Cmathbf%7Bw%7D%7D%20%3D%20%5Cnabla%5E2%20q." style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>So now we can say the Poisson eq is equivalent to Helmholtz-Hodge Decomposition, while the Helmholtz-Hodge Decomposition can be written as projection:</p><p><img src="https://math.now.sh?inline=%5Cmathrm%7B%5Cmathbf%7Bu%7D%7D%20%3D%20%5Cmathrm%7B%5Cmathbf%7BP%7D%7D%20%5Cmathrm%7B%5Cmathbf%7Bw%7D%7D%20%3D%20%5Cmathrm%7B%5Cmathbf%7Bw%7D%7D%20-%20%5Cnabla%20q." style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>Where <img src="https://math.now.sh?inline=%5Cmathrm%7B%5Cmathbf%7BP%7D%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> satisfies <img src="https://math.now.sh?inline=%5Cmathrm%7B%5Cmathbf%7BP%7D%7D%20%5Cmathrm%7B%5Cmathbf%7Bu%7D%7D%20%3D%20%5Cmathrm%7B%5Cmathbf%7Bu%7D%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%5Cmathrm%7B%5Cmathbf%7BP%7D%7D%20%5Cnabla%20q%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><p>So you can see, solving Poisson eq is projecting velocity field to pressure field.</p><figure style="width: 513px" class="align-center"><img src="/images/fluid_sim_reading_note/velocity_projection.png"><figcaption align = "center">Fig: Velocity Projection. Taken from "Stable Fluid"</figcaption></figure><h3 id="Method-without-projection">Method without projection</h3><p>If you don’t project velocity field to pressure filed, only solve the divergence-free condition, there is simpler algorithm.</p><p>Take 2D as an example,</p><p>we need to accomplish <img src="https://math.now.sh?inline=%5Cdfrac%7Bu%5E%7Bn%2B1%7D_%7Bi%2B1%2F2%2Cj%2Ck%7D-u%5E%7Bn%2B1%7D_%7Bi-1%2F2%2Cj%2Ck%7D%7D%7B%5CDelta%20x%7D%20%2B%20%5Cdfrac%7Bv%5E%7Bn%2B1%7D_%7Bi%2Cj%2B1%2F2%2Ck%7D-v%5E%7Bn%2B1%7D_%7Bi%2Cj-1%2F2%2Ck%7D%7D%7B%5CDelta%20y%7D%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><p>It can be shorten as:</p><p><img src="https://math.now.sh?inline=u_%7Bi%2B1%2F2%2Cj%2Ck%7D-u_%7Bi-1%2F2%2Cj%2Ck%7D%20%2B%20v_%7Bi%2Cj%2B1%2F2%2Ck%7D-v_%7Bi%2Cj-1%2F2%2Ck%7D%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>A quick way is calculating the difference, and distribute it onto the four velocity.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = u[i+<span class="number">1</span>][j] - u[i][j] + v[i][j+<span class="number">1</span>] - v[i][j]</span><br><span class="line"></span><br><span class="line">u[i][j] += d/<span class="number">4</span></span><br><span class="line">u[i+<span class="number">1</span>][j] -= d/<span class="number">4</span></span><br><span class="line">v[i][j] += d/<span class="number">4</span></span><br><span class="line">v[i][j+<span class="number">1</span>] -= d/<span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="Wall-Condition">Wall Condition</h4><p>Considering the wall condition. Wall cell doesn’t have velocity, but if using MAC grid, velocity is defined in cell faces.</p><p>So the border between wall and fluid has velocity.</p><p>Essentially, distributing <code>d</code> is distributing additional flux of the cell to cell face, to make the cell 0 flux.</p><p>But there isn’t flux from wall or to wall, so things change:</p><h5 id="Boolean-flag">Boolean flag</h5><p>Set <img src="https://math.now.sh?inline=s%20%3D%201" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> represent fluid, <img src="https://math.now.sh?inline=s%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> represent wall.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = u[i+<span class="number">1</span>][j] - u[i][j] + v[i][j+<span class="number">1</span>] - v[i][j]</span><br><span class="line">s = s[i+<span class="number">1</span>][j] + s[i-<span class="number">1</span>][j] + s[i][j+<span class="number">1</span>] + s[i][j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">u[i][j] += d * s[i-<span class="number">1</span>][j] / s</span><br><span class="line">u[i+<span class="number">1</span>][j] -= d * s[i+<span class="number">1</span>][j] / s</span><br><span class="line">v[i][j] += d * s[i][j-<span class="number">1</span>] / s</span><br><span class="line">v[i][j+<span class="number">1</span>] -= d * s[i][j+<span class="number">1</span>] / s</span><br></pre></td></tr></table></figure><p>Here we may access cells out of boundary. A solution is adding border cells.</p><p>The current four velocity values being processed, have overlapping value with previous four velocity values. It means that right after you make current four velocity values divergence-free, the previous may get divergence again.</p><p>So you should repeat it over and over again, until the whole field coverge.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> velocity field doesn<span class="string">&#x27;t converge:</span></span><br><span class="line"><span class="string">    d = u[i+1][j] - u[i][j] + v[i][j+1] - v[i][j]</span></span><br><span class="line"><span class="string">    s = s[i+1][j] + s[i-1][j] + s[i][j+1] + s[i][j-1]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    u[i][j] += d * s[i-1][j] / s</span></span><br><span class="line"><span class="string">    u[i+1][j] -= d * s[i+1][j] / s</span></span><br><span class="line"><span class="string">    v[i][j] += d * s[i][j-1] / s</span></span><br><span class="line"><span class="string">    v[i][j+1] -= d * s[i][j+1] / s</span></span><br></pre></td></tr></table></figure><h5 id="Copying-value">Copying value</h5><p>Set <img src="https://math.now.sh?inline=s%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> for border cells is one method, another method is copying neighbor fluid cell value to border cell.</p><h4 id="Drift-problem">Drift problem</h4><p>The method has drift problem, it is common problem of velocity based particles method.</p><blockquote><p>It is what I see in other’s tutorial video.</p><p>I didn’t see the related statement about “drift” in other book?</p></blockquote><p>It means that the method can only see collision of opposite motion. It can’t recognize collision of two particles with parallel velocity.</p><figure style="width: 600px" class="align-center"><img src="/images/fluid_sim_reading_note/velocity_based_particles_method_drift_problem.svg"><figcaption align = "center">Fig: Drift problem</figcaption></figure><blockquote><p>In my personal view, it is because the method only rely on flux to seperate particles. If some particles move in parallel but the flux is 0, then they won’t be affected by divergence-free solving step. But if two particles move in opposite direction, they must result in flux changes.</p></blockquote><h5 id="Solution">Solution</h5><p>There are two solutions.</p><p>One is checking collision of all particles pairs. Obviously, it is very slow.</p><p>Another is computing particles density <img src="https://math.now.sh?inline=d" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> at the center of each cell.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clear rho <span class="keyword">for</span> <span class="built_in">all</span> particles</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">all</span> particles:</span><br><span class="line">    rho1 += w1</span><br><span class="line">    rho2 += w2</span><br><span class="line">    rho3 += w3</span><br><span class="line">    rho4 += w4</span><br></pre></td></tr></table></figure><p>Then considering density when computing delta flux.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = u[i+<span class="number">1</span>][j] - u[i][j] + v[i][j+<span class="number">1</span>] - v[i][j] + k (rho - rho_rest)</span><br></pre></td></tr></table></figure><blockquote><p>It may be a approximation of Possion equation?</p></blockquote><h2 id="Chapter-7-Particle-Methods">Chapter 7: Particle Methods</h2><h3 id="Advection-Troubles-on-Grids">Advection Troubles on Grids</h3><h4 id="Velocity-Field-with-Distortion">Velocity Field with Distortion</h4><p>Eulerian advection schemes:</p><ol><li><p>Begin with the field sampled on a grid</p></li><li><p>Reconstruct the field as a continuous function from the grid samples</p></li><li><p>Advect the reconstructed field</p></li><li><p>Resample the advected field on the grid</p></li></ol><p>Though incompressible velocity field preserves volumes, at any point in space, the advected field may be stretched out along some axes and squished together along others.</p><p>For rendering, there is a local magnification (stretching out) along some axes and a local minification (squishing together) along the others.</p><p>Resampling a magnified field: doesnt’t lose information</p><p>Resampling a minified field: lose information, cause alias</p><p>Still from view of signal processing technology, minified field increase the frequency of singal.</p><h4 id="Velocity-Field-without-Distortion">Velocity Field without Distortion</h4><p>Even for a pure translation velocity field with no distortion, the Nyquist limit essentially means that, the maximum spatial frequency that can be reliably advected has period <img src="https://math.now.sh?inline=4%20%5CDelta%20x" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><blockquote><p>The book says <img src="https://math.now.sh?inline=4%20%5CDelta%20x" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>? Does it should be <img src="https://math.now.sh?inline=2%20%5CDelta%20x" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>?</p></blockquote><p>Higher-frequency signals, even though you might resolve them on the grid at a particular instant in time, cannot be handled in general: e.g., just in one dimension the highest-frequency component you can see on the grid, <img src="https://math.now.sh?inline=%5Ccos%7B%5Cpi%20x%20%2F%20%5CDelta%20x%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, exactly disappears from the grid once you advect it by a distance of <img src="https://math.now.sh?inline=1%2F2%20%5CDelta%20x" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><blockquote><p>Why highest-frequency component of 1D is <img src="https://math.now.sh?inline=%5Ccos%7B%5Cpi%20x%20%2F%20%5CDelta%20x%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>? Why it disappears by a distance of <img src="https://math.now.sh?inline=1%2F2%20%5CDelta%20x" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>?</p></blockquote><h4 id="Eulerian-scheme-filtering-ability">Eulerian scheme filtering ability</h4><p>A “perfect” Eulerian scheme would filter out the high-frequency components that can’t be reliably resampled at each time step, even as a bad one will allow them to alias as artifacts. The distortions inherent in non-rigid velocity fields mean that as time progresses, some of the lower-frequency components get transferred to higher frequencies—and thus must be destroyed by a good scheme. But note that the fluid flow, after squeezing the field along some axes at some point, may later stretch it back out—transferring higher frequencies down to lower frequencies. However, it’s too late if the Eulerian scheme has already filtered them out.</p><blockquote><p>Is that what the author wants to express?</p><p>Becuase in non-rigid velocity fields, some of the lower-frequency components get transferred to higher frequencies.</p><p>So researcher that focus on fluid simulation precision should design a eulerian scheme that filter out the high-frequency components.</p><p>But for computer graphics, we need to keep high-frequency components as much as possible.</p><p>So that is why we turn to particles method?</p></blockquote><h4 id="Why-DNS-works-well">Why DNS works well</h4><p>At small enough length scales, viscosity and other molecular diffusion processes end up dominating advection. That means, : if <img src="https://math.now.sh?inline=%5CDelta%20x" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is small enough, Eulerian schemes can behave perfectly well since the physics itself is effectively bandlimiting everything, dissipating information at higher frequencies.</p><p>That is why DNS works well.</p><p>But it is expensive for compute graphics.</p><h4 id="Adaptive-Grids">Adaptive Grids</h4><p>We have known that if <img src="https://math.now.sh?inline=%5CDelta%20x" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is smaller, the Eulerian scheme will filter higher frequencies and keep higher bandwidth of low frequencies.</p><p>So adaptive grids can be used, where the grid resolution is increased wherever higher resampling density is required to avoid information loss, and decreased where the field is smooth enough that low resolution suffices.</p><p>Data Structure:</p><ul><li><p>Octrees</p></li><li><p>Unstructured tetrahedral meshes</p></li></ul><p>Complex, not really a solution to unwanted grid-caused diffusion</p><h4 id="Store-information-in-Particle">Store information in Particle</h4><p>Store a field on particles that move with the flow</p><p>Then there is no filtering and no information loss</p><p>Particle methods apply best to fields with essentially zero diffusion (or viscosity, or conduction, or whatever other name is appropriate for the quantity in question).</p><h3 id="Particle-Advection">Particle Advection</h3><p>Error in particle advection: accumulated over many time steps</p><p>Error in the semi-Lagrangian method: being reset each time step</p><p>second-order Runge-Kutta</p><p>three-stage third-order Runge-Kutta scheme</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cbegin%7Balign%7D%0A%20%20%20%20k_1%20%26%3D%20u%28x_n%29%2C%20%5C%5C%0A%20%20%20%20k_2%20%26%3D%20u(x_n%20%2B%20%5Cdfrac%7B1%7D%7B2%7D%5CDelta%20t%20k_1)%2C%20%5C%5C%0A%20%20%20%20k_3%20%26%3D%20u(x_n%20%2B%20%5Cdfrac%7B3%7D%7B4%7D%5CDelta%20t%20k_2)%2C%20%5C%5C%0A%20%20%20%20x_%7Bn%2B1%7D%20%26%3D%20x_n%20%2B%20%5Cdfrac%7B2%7D%7B9%7D%5CDelta%20t%20k_1%20%2B%20%5Cdfrac%7B3%7D%7B9%7D%5CDelta%20t%20k_2%20%2B%20%5Cdfrac%7B4%7D%7B9%7D%5CDelta%20t%20k_3.%0A%5Cend%7Balign%7D%0A" /></p><h3 id="Transferring-Particles-to-the-Grid">Transferring Particles to the Grid</h3><p>Common:</p><p>Particles track secondary field such as smoke concentration, foam, bubbles, or other things that would show up in rendering</p><p>Primary fluid variables like velocity store in grids.</p><blockquote><p>But in PIC it is not…?</p><p>I come up with store velocity on particles firstly but not secondary field.</p><p>Maybe it is a differences in thinking between me and author.</p><p>I think when author says “track secondary field” first, he put PIC section to the next. It explains why author doesn’t say particles track velocity firstly.</p></blockquote><p>Use kernel function to transfer value from particles to the grid.</p><p>Like SPH?</p><h3 id="Particle-Seeding">Particle Seeding</h3><p>Make sure it’s consistent across different time steps and grid sizes.</p><p>My understanding is seeding should be related with delta time and grid size.</p><h3 id="Diffusion-2">Diffusion</h3><h3 id="Particle-in-Cell-Methods">Particle-in-Cell Methods</h3><p>Pressure projection to keep the velocity field divergence-free globally couples all the velocities together.</p><h4 id="From-Grid-to-Particle">From Grid to Particle</h4><p>For 2D, bilinear interpolation</p><p>For 3D, trilinear interpolation</p><p>Caution: For 2D as an example, if one grid velocity is undefined (the cell is not fluid), then in your bilinear interpolation, you only average three points. In other word, if <img src="https://math.now.sh?inline=q_4" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is undefined, then right calcuation is <img src="https://math.now.sh?inline=q_p%20%3D%20%5Cdfrac%7Bq_1%20%2B%20q_2%20%2B%20q_3%7D%7Bw_1%20%2B%20w_2%20%2B%20w_3%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> but not <img src="https://math.now.sh?inline=q_p%20%3D%20%5Cdfrac%7Bq_1%20%2B%20q_2%20%2B%20q_3%20%2B%200%7D%7Bw_1%20%2B%20w_2%20%2B%20w_3%20%2B%20w_4%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><p>Because undefined is not 0.</p><p>If you are using MAC grid, then grid position is not integer, it has an offset about h/2 from integer.</p><h4 id="From-Particles-to-Grid">From Particles to Grid</h4><p>Many particles may contributes the same one grid velocity,</p><p>but we are iterating all particles, so we should accumulate q and weight during the loop,</p><p>and calculate result in the last.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">clear q <span class="keyword">and</span> r <span class="keyword">for</span> all cells</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> all particles:</span><br><span class="line">    q1 = q1 + w1 * qp</span><br><span class="line">    q2 = q2 + w2 * qp</span><br><span class="line">    q3 = q3 + w3 * qp</span><br><span class="line">    q4 = q4 + w4 * qp</span><br><span class="line"></span><br><span class="line">    r1 = r1 + w1</span><br><span class="line">    r2 = r2 + w2</span><br><span class="line">    r3 = r3 + w3</span><br><span class="line">    r4 = r4 + w4</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> all cells:</span><br><span class="line">    q = q / r</span><br></pre></td></tr></table></figure><h4 id="PIC">PIC</h4><p>PIC:</p><ol><li><p>Velocity from particles to grids</p></li><li><p>Solve Advection in Grid</p></li><li><p>Interpolate back from grid to particles</p></li><li><p>Advect particles by the interpolated grid velocity field</p></li></ol><p>About particles seeding: If too few particles in grid, seeding; if too many particles, delete the excess.</p><p>PIC suffers from severe numerial dissipation, because there is too many interpolation.</p><h4 id="FLIP">FLIP</h4><p>In FLIP, instead of interpolating a quantity back to the particles, the change in the quantity (as computed on the grid) is interpolated.</p><p>So the delta quantity is used to increment the value in particles.</p><p>Each increment is smoothed because of interpolation, of course, but that is all. Smoothing is not accumulated, and thus FLIP is virtually free of numerical diffusion.</p><ol><li><p>Velocity from particles to grids</p><p>It stores a set of quantity <img src="https://math.now.sh?inline=q" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p></li><li><p>Solve Advection in Grid</p><p>It stores a set of updated quantity <img src="https://math.now.sh?inline=q_%7Bnew%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p></li><li><p>Get delta quantity <img src="https://math.now.sh?inline=%5CDelta%20q%20%3D%20q_%7Bnew%7D%20-%20q" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> in Grid</p></li><li><p>Interpolate <img src="https://math.now.sh?inline=%5CDelta%20q" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> back from grid to particles</p></li><li><p>Advect particles by the interpolated grid velocity field</p></li></ol><h4 id="PIC-FLIP">PIC/FLIP</h4><p>Eight particles pre grid cell, meaning there are more degrees of freedom in particles than in grid.</p><p>So FLIP may develop noise because the delta quantity is not enough to represent all degrees of motion.</p><p>Noise means velocity fluctuations on the particles may, on some time steps, average down to zero and vanish from the grid, and on other time steps show up as unexpected perturbations</p><p>But PIC doesn’t have the problem, because quantity is interpolated.</p><p>So a blending is useful, such as 0.01 PIC and 0.99 FLIP</p><h2 id="Chapter-8-Water">Chapter 8: Water</h2><h3 id="Marker-Particles-and-Voxels">Marker Particles and Voxels</h3><p>Determining a cell is fluid or empty when water moves in or out of it. is the tricky part.</p><p>So one possibility is to define an initial level set of water, then advect is using sharp cubic interpolant.</p><p>But it still have problem about thin structures that thinner than about two grid cells. Droplets rarely can travel more than a few grid cells before disappearing.</p><p>This is where we turn instead to marker particles.</p><p>Marker Particles:</p><ol><li><p>Emitting water particles to fill the volume of water</p><p>If simulation has source, emit from it over time</p></li><li><p>Advect the particles</p></li><li><p>Mark the water cell: containing a marker particles is water, and the rest is empty or default</p></li></ol><h4 id="Density-of-marker-particles">Density of marker particles</h4><p>double of resolution: 4 particles in 2D, 8 in 3D</p><p>more may not bring improvement: sampling frequency is limited by grid resolution</p><p>So emitting particles in a random jittered pattern is a good idea. It is still considering about shearing flow that compresses along one axis and stretches along another can turn a regular lattice into weird anisotropic stripe-like patterns, far from a good uniform sampling.</p><h4 id="Rendering">Rendering</h4><p>Need a smooth surface, we only have cells containing marker particles.</p><p>Blobbies</p><p>J. Blinn. A generalization of algebraic surface drawing. ACM Trans. Graph., 1(3):235–256, 1982</p><p><img src="https://math.now.sh?inline=F%28x%29%20%3D%20%5Csum_%7Bi%7D%7Bk(%5Cdfrac%7B%5Cvert%5Cvert%20x%20-%20x_i%5Cvert%5Cvert%7D%7Bh%7D)%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=k%28s%29%20%3D%20%5Cleft%5Clbrace%5Cbegin%7Balign*%7D%20%7B(1-s%5E2)%7D%5E3%2C%20s%20%3C%201%20%5C%5C%200%2C%20s%20%5Cgeqslant%201.%20%5Cend%7Balign*%7D%5Cright." style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>The blobby surface is implicitly defined as the points <img src="https://math.now.sh?inline=x" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> where <img src="https://math.now.sh?inline=F%28x%29%20%3D%20%5Ctau" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>The blobby surface looks blobby. If using smoothing to mask blobby artifacts, the smoothing will also mask small-scale features.</p><p>An improvement on blobbies is given by Zhu and Bridson</p><p>One exciting direction is to skip the level set construction and directly use a triangle mesh to track the surface of the water.</p><ol><li><p>Mesh may deform significantly, so remeshing is necessary.</p></li><li><p>Mesh spiltting and merging need topology change operation.</p></li><li><p>Numerical errors can cause the mesh to collide with itself.</p></li></ol><h4 id="Combine-marker-particles-and-FLIP">Combine marker particles and FLIP</h4><p>If we have already use particles, why not get th full benefit from them?</p><p>So using FLIP instead of semi-Lagrangian method.</p><blockquote><p>Here you will realize that FLIP is not a solver, it is just a advection method comparing with semi-Largrangian method.</p></blockquote><p>Combination:</p><ol><li><p>From the particles, construct the level set for the liquid.</p></li><li><p>Transfer velocity (and any other additional state) from particles to the grid, and extrapolate from known grid values to at least one grid cell around the fluid, giving a preliminary velocity field <img src="https://math.now.sh?inline=u%5E*" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p></li><li><p>Add body forces such as gravity or artistic controls to the velocity field.</p></li><li><p>Construct solid level sets and solid velocity fields.</p></li><li><p>Solve for and apply pressure to get a divergence-free velocity <img src="https://math.now.sh?inline=u%5E%7Bn%2B1%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> that respects the solid boundaries.</p></li><li><p>Update particle velocities by interpolating the grid update <img src="https://math.now.sh?inline=u%5E%7Bn%2B1%7D%20-%20u%5E*" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> to add to the existing particle velocities (FLIP), or simply interpolating the grid velocity (PIC), or a mix thereof.</p></li><li><p>Advect the particles through the divergence-free velocity field <img src="https://math.now.sh?inline=u%5E%7Bn%2B1%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p></li></ol><blockquote><p>The final step should be advecting the particels through particles velocity? Instead of divergence-free velocity in grid? Or the “divergence-free velocity <img src="https://math.now.sh?inline=u%5E%7Bn%2B1%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>” means velocity in particles?</p></blockquote><h4 id="Why-we-need-More-Accurate-Pressure-Solves-Voxelized-Surface">Why we need More Accurate Pressure Solves: Voxelized Surface</h4><p>Marker particles method create block voxelized surface in field value.</p><p>Simulation core is pressure solving</p><p>Pressure solving only see a block voxelized surface, so as a solving result, velocity filed cannot avoid significant voxel artifacts.</p><p>For example, small “ripples” less than a grid cell high do not show up at all in the pressure solve, and thus they aren’t evolved correctly but rather persist statically in the form of a strange displacement texture.</p><p>So we need to inform the pressure solver about the location of the water-air interface. Then we modify the pressure solver, about how we compute the gradient of pressure near the water-air interface for updating velocities. It naturally will also changes the matrix in the pressure equations.</p><blockquote><p>We modify pressure solver and add an additional process about water-air interface?</p><p>OK. See the ghost fluid method section, I realize it is about how to determine <img src="https://math.now.sh?inline=p%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> location.</p></blockquote><h4 id="Ghost-fluid-Method">Ghost fluid Method</h4><p>Assume that we have known that how to update velocity:</p><p><img src="https://math.now.sh?inline=u_%7Bi%2B1%2F2%2Cj%2Ck%7D%5E%7Bn%2B1%7D%20%3D%20u_%7Bi%2B1%2F2%2Cj%2Ck%7D%20-%20%5Cdfrac%7B%5CDelta%20t%7D%7B%5Crho_%7Bi%2B1%2F2%2Cj%2Ck%7D%7D%5Cdfrac%7Bp_%7Bi%2B1%2Cj%2Ck%7D-p_%7Bi%2Cj%2Ck%7D%7D%7B%5CDelta%20x%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>Suppose that <img src="https://math.now.sh?inline=%28i%2Cj%2Ck%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is in the water, i.e. <img src="https://math.now.sh?inline=%5Cphi_%7Bi%2Cj%2Ck%7D%20%5Cleqslant%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=%28i%2B1%2Cj%2Ck%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> is in the air, i.e. <img src="https://math.now.sh?inline=%5Cphi_%7Bi%2B1%2Cj%2Ck%7D%20%3E%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><p>Simple solver, which causes voxelized surface, set <img src="https://math.now.sh?inline=p_%7Bi%2B1%2Cj%2Ck%7D%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>.</p><p>But it would be more accurate to say that <img src="https://math.now.sh?inline=p%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> happens at the water-air interface, and <img src="https://math.now.sh?inline=%28i%2B1%2Cj%2Ck%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> doesn’t represent interface.</p><p>So we set a <img src="https://math.now.sh?inline=p%5EG_%7Bi%2B1%2Cj%2Ck%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> to present the “ghost” pressure in the air. Now the update is:</p><p><img src="https://math.now.sh?inline=u_%7Bi%2B1%2F2%2Cj%2Ck%7D%5E%7Bn%2B1%7D%20%3D%20u_%7Bi%2B1%2F2%2Cj%2Ck%7D%20-%20%5Cdfrac%7B%5CDelta%20t%7D%7B%5Crho_%7Bi%2B1%2F2%2Cj%2Ck%7D%7D%5Cdfrac%7Bp%5EG_%7Bi%2B1%2Cj%2Ck%7D-p_%7Bi%2Cj%2Ck%7D%7D%7B%5CDelta%20x%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>Now we should solve the unknown <img src="https://math.now.sh?inline=p%5EG_%7Bi%2B1%2Cj%2Ck%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>, we know we should use the water-air interface condition that:</p><p><img src="https://math.now.sh?inline=%281-%5Ctheta%29p_%7Bi%2Cj%2Ck%7D%2B%5Ctheta%20p%5EG_%7Bi%2B1%2Cj%2Ck%7D%20%3D%200" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>Where <img src="https://math.now.sh?inline=%5Ctheta" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> means we do linearly interpolating between <img src="https://math.now.sh?inline=%5Cphi_%7Bi%2Cj%2Ck%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=%5Cphi_%7Bi%2B1%2Cj%2Ck%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> gives the location of the interface at <img src="https://math.now.sh?inline=%28i%20%2B%20%5Ctheta%20%5CDelta%20x%2C%20j%2C%20k%29" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/> where</p><p><img src="https://math.now.sh?inline=%5Ctheta%20%3D%20%5Cdfrac%7B%5Cphi_%7Bi%2Cj%2Ck%7D%7D%7B%5Cphi_%7Bi%2Cj%2Ck%7D%20-%20%5Cphi_%7Bi%2B1%2Cj%2Ck%7D%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>Solve <img src="https://math.now.sh?inline=p%5EG_%7Bi%2B1%2Cj%2Ck%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/>:</p><p><img src="https://math.now.sh?inline=p%5EG_%7Bi%2B1%2Cj%2Ck%7D%20%3D%20%5Cdfrac%7B%28%5Ctheta-1%29p_%7Bi%2Cj%2Ck%7D%7D%7B%5Ctheta%7D" style="filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;"/></p><p>and then substitute it into update eq:</p><p style="filter: opacity(90%);transform:scale(0.85);text-align:center;"><img src="https://math.now.sh?from=%5Cbegin%7Balign*%7D%0Au_%7Bi%2B1%2F2%2Cj%2Ck%7D%5E%7Bn%2B1%7D%20%26%20%3D%20u_%7Bi%2B1%2F2%2Cj%2Ck%7D%20-%20%5Cdfrac%7B%5CDelta%20t%7D%7B%5Crho_%7Bi%2B1%2F2%2Cj%2Ck%7D%7D%5Cdfrac%7B%5Cdfrac%7B%28%5Ctheta-1%29p_%7Bi%2Cj%2Ck%7D%7D%7B%5Ctheta%7D-p_%7Bi%2Cj%2Ck%7D%7D%7B%5CDelta%20x%7D%20%5C%5C%0A%26%20%3D%20u_%7Bi%2B1%2F2%2Cj%2Ck%7D%20%2B%20%5Cdfrac%7B%5CDelta%20t%7D%7B%5Crho%7D%5Cdfrac%7B1%7D%7B%5Ctheta%7D%5Cdfrac%7Bp_%7Bi%2Cj%2Ck%7D%7D%7B%5CDelta%20x%7D%0A%5Cend%7Balign*%7D%0A" /></p><p>that is all.</p><figure style="width: 600px" class="align-center"><img src="/images/fluid_sim_reading_note/ghost_fluid_method.svg"><figcaption align = "center">Fig: Ghost fluid Method</figcaption></figure><p>Other methods …</p><h3 id="Topology-Change-and-Wall-Separation">Topology Change and Wall Separation</h3><h4 id="How-does-Separation-happen">How does Separation happen</h4><p>Why water will separation?</p><p>Only considering numerical scheme, if water is path-connected, then after advection, it must remain path-connected. In other word, in theory, if velocity field path-connected, then it will never separate.</p><p>But in real simulation, if you use level set or marker particles method, you will find the separation happens natually. But it may just caused by numerical error.</p><h4 id="Lose-volume-when-merging-water">Lose volume when merging water</h4><p>A water drop can penetrate quite deeply into a solid wall or into another water region during advection, effectively losing volume in the process.</p><h4 id="How-Liquid-can-Separate-from-Solid-Walls">How Liquid can Separate from Solid Walls</h4><p>In fact, exactly what happens at the moving contact line where air, water, and solid meet is again not fully understood. Complicated physical chemistry, including the influence of past wetting (leaving a nearly invisible film of water on a solid), is at play.</p><p>Other searcher …</p><h3 id="Volume-Control">Volume Control</h3><p>Because of pressure solving error, truncation error in level set representation, advection error, as well as the topology issues noted above, it is not surprising that fluid volume can’t be conserve.</p><p>Other searcher …</p><h3 id="Surface-Tension">Surface Tension</h3><p>Both graphics and scientific computing, are studying how to add surface tension.</p><p>Other searcher …</p><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Fluid Simulation </tag>
            
            <tag> Graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Create SPH Fluid using UE5 Niagara System</title>
      <link href="/2023/12/19/2023-12-19-ue5_niagara_sph/"/>
      <url>/2023/12/19/2023-12-19-ue5_niagara_sph/</url>
      
        <content type="html"><![CDATA[<p>It is an implementation note of SPH using UE5 Niagara System, related about usage of Simulation Stage, Grid 3D, screen space rendering using depth buffer and so on.</p><p>Github repository: <a href="https://github.com/CheapMeow/UE5-NiagaraSPH">https://github.com/CheapMeow/UE5-NiagaraSPH</a></p><p>I also learn other’s tutorial: <a href="https://www.bilibili.com/video/BV1pr4y1v78B">https://www.bilibili.com/video/BV1pr4y1v78B</a></p><h2 id="SPH-Introduction">SPH Introduction</h2><p>Basic knowledge about SPH can see other tutorial.</p><p><a href="https://dl.acm.org/doi/10.5555/846276.846298">Matthias Müller et al, “Particle-based fluid simulation for interactive applications”</a></p><h2 id="Niagara-System-Setup">Niagara System Setup</h2><p>Basic knowledge about Niagara System can see other tutorial.</p><p>To setup, change <code>Sim Target</code> to <code>GPUCompute Sim</code>, because our Niagara System may calculate millions of particles.</p><p>Change <code>Calculate Bounds Mode</code> to <code>Fixed</code>, because particles are upload to GPU so it is hard to calculate bounds every frame.</p><p>Change <code>Life Cycle Mode</code> to <code>Self</code>, in order to set <code>Loop Behaviour</code> as <code>Infinite</code>.</p><h3 id="Add-Neighbor-Grid3D-from-empty">Add Neighbor Grid3D from empty</h3><p>One data structure we should use is <code>Neighbor Grid3D</code>, we will store our particle indice into grid, for convience of searching neighbor particles in 8 grids around certain particle.</p><p>In Niagara System window, find <code>Parameter</code> window (not <code>Details</code> windows), find <code>Emitter Attributes</code>, click “+” button, search <code>neighbor</code> in popup, then you will find <code>Neighbor Grid3D</code> item, confirm.</p><p>You know the adding parameters of Niagara System is similar to actor blueprint.</p><figure style="width: 647px" class="align-center"><img src="/images/ue5_niagara_sph/neighbor_grid.png"><figcaption align = "center">Fig: Neighbor Grid</figcaption></figure><p>After creating a <code>Neighbor Grid3D</code> parameter, you should drag it into you emitter. Then <code>Neighbor Grid3D</code> will take effect in this emitter.</p><figure style="width: 247px" class="align-center"><img src="/images/ue5_niagara_sph/after_drag_neighbor_grid_to_emitter.png"><figcaption align = "center">Fig: After Drag Neighbor Grid to Emitter</figcaption></figure><h3 id="Using-module-script-from-content-example">Using module script from content example</h3><p>After you add <code>Neighbor Grid3D</code> variable, you should also define some variable about extent, transform matrix, etc. To skip these details at the first time, I copy two modules <code>Initialize Neighbor Grid</code> and <code>Populate Neighbor Grid</code> from offical Content Example.</p><figure style="width: 428px" class="align-center"><img src="/images/ue5_niagara_sph/copy_modules.png"><figcaption align = "center">Fig: Copy Modules</figcaption></figure><p>However, after doing this, I add <code>Spawn Rate</code> and then click <code>Fix issue</code>, try to add <code>Emitter State</code>. But UE log “fail to add emitter state” becuase “could not find location”.</p><p>I don’t know why, so I create a emitter from existing copy, and delete redundant module from it. So now I get no error.</p><figure style="width: 440px" class="align-center"><img src="/images/ue5_niagara_sph/copy_other_emitter_to_get_emitter_state.png"><figcaption align = "center">Fig: Copy Other Emitter to Get Emitter State</figcaption></figure><p>When setup your copied module, be carefull to your default value .</p><p>For example, <code>Populate Neighbor Grid</code> has a Neighbor Grid 3D input, its default value is different from your existing Neighbor Grid 3D in your Niagara System.</p><figure style="width: 721px" class="align-center"><img src="/images/ue5_niagara_sph/wrong_default_neighborgrid.png"><figcaption align = "center">Fig: Default Neighbor Grid 3D input is different from existing Neighbor Grid 3D</figcaption></figure><figure style="width: 454px" class="align-center"><img src="/images/ue5_niagara_sph/right_value_in_module.png"><figcaption align = "center">Fig: Right Input value should be your existing Neighbor Grid 3D</figcaption></figure><h3 id="Setup-Parameters-and-Simulaton-Stage">Setup Parameters and Simulaton Stage</h3><p>Next we should add some parameters. Here is an overview of Niagara System and you will what is new.</p><figure style="width: 591px" class="align-center"><img src="/images/ue5_niagara_sph/overview_1.png"><figcaption align = "center">Fig: Overview 1</figcaption></figure><figure style="width: 269px" class="align-center"><img src="/images/ue5_niagara_sph/overview_2.png"><figcaption align = "center">Fig: Overview 2</figcaption></figure><p>Parameter value:</p><table><thead><tr><th style="text-align:center">Module</th><th style="text-align:center">Parameter Name</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td style="text-align:center">Set (SYSTEM) WorldGridExtent</td><td style="text-align:center">WorldGridExtent</td><td style="text-align:center">(6,6,6)</td></tr><tr><td style="text-align:center">Initialize Neighbor Grid</td><td style="text-align:center">MaxNeighborsPerCell</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">Initialize Neighbor Grid</td><td style="text-align:center">NumCellsX</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center">Initialize Neighbor Grid</td><td style="text-align:center">NumCellsY</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center">Initialize Neighbor Grid</td><td style="text-align:center">NumCellsZ</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center">Emitter Spawn</td><td style="text-align:center">RestDensity</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">Emitter Spawn</td><td style="text-align:center">PointMass</td><td style="text-align:center">0.05</td></tr><tr><td style="text-align:center">Emitter Spawn</td><td style="text-align:center">GasConstantK</td><td style="text-align:center">150</td></tr><tr><td style="text-align:center">Emitter Spawn</td><td style="text-align:center">Viscosity</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">Emitter Spawn</td><td style="text-align:center">Gravity</td><td style="text-align:center">(0,0,-9.8)</td></tr><tr><td style="text-align:center">Spawn Rate</td><td style="text-align:center">SpawnRate</td><td style="text-align:center">200</td></tr><tr><td style="text-align:center">Initialize Particle</td><td style="text-align:center">Lifetime</td><td style="text-align:center">50</td></tr><tr><td style="text-align:center">Initialize Particle</td><td style="text-align:center">Uniform Sprite Size</td><td style="text-align:center">0.1</td></tr><tr><td style="text-align:center">Set (PARTICLES) Density</td><td style="text-align:center">Density</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Set (PARTICLES) Pressure</td><td style="text-align:center">Pressure</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Set (PARTICLES) Velocity</td><td style="text-align:center">Velocity</td><td style="text-align:center">(0,10,0)</td></tr><tr><td style="text-align:center">Populate Neighbor Grid</td><td style="text-align:center">NeighborGrid</td><td style="text-align:center">Your Neighbor Grid</td></tr><tr><td style="text-align:center">Populate Neighbor Grid</td><td style="text-align:center">Simulation To Grid Unit Transform</td><td style="text-align:center">WorldToGridUnit</td></tr><tr><td style="text-align:center">Solve Density and Pressure</td><td style="text-align:center">Emitter Name</td><td style="text-align:center">SPHEmitter1</td></tr><tr><td style="text-align:center">Solve Force</td><td style="text-align:center">Emitter Name</td><td style="text-align:center">SPHEmitter1</td></tr><tr><td style="text-align:center">Advent</td><td style="text-align:center">MaxAccel</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">Advent</td><td style="text-align:center">MaxVelocity</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">Advent</td><td style="text-align:center">WallDamping</td><td style="text-align:center">-0.1</td></tr></tbody></table><p>These values are set based on experience. They are only suitable for reference but not necessarily the most appropriate.</p><h2 id="Solve-Density-and-Pressure">Solve Density and Pressure</h2><h3 id="Module-View">Module View</h3><figure style="width: 1017px" class="align-center"><img src="/images/ue5_niagara_sph/solve_pressure_input.png"><figcaption align = "center">Fig: Solve Pressure Input</figcaption></figure><figure style="width: 490px" class="align-center"><img src="/images/ue5_niagara_sph/solve_pressure_output.png"><figcaption align = "center">Fig: Solve Pressure Output</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">Density = 0;</span><br><span class="line">Pressure = 0;</span><br><span class="line"></span><br><span class="line">#if GPU_SIMULATION</span><br><span class="line">const int3 IndexOffsets [ 27 ] = </span><br><span class="line">&#123;</span><br><span class="line">    int3(-1,-1,-1),</span><br><span class="line">    int3(-1,-1, 0),</span><br><span class="line">    int3(-1,-1, 1),</span><br><span class="line">    int3(-1, 0,-1),</span><br><span class="line">    int3(-1, 0, 0),</span><br><span class="line">    int3(-1, 0, 1),</span><br><span class="line">    int3(-1, 1,-1),</span><br><span class="line">    int3(-1, 1, 0),</span><br><span class="line">    int3(-1, 1, 1),</span><br><span class="line"></span><br><span class="line">    int3(0,-1,-1),</span><br><span class="line">    int3(0,-1, 0),</span><br><span class="line">    int3(0,-1, 1),</span><br><span class="line">    int3(0, 0,-1),</span><br><span class="line">    int3(0, 0, 0),</span><br><span class="line">    int3(0, 0, 1),</span><br><span class="line">    int3(0, 1,-1),</span><br><span class="line">    int3(0, 1, 0),</span><br><span class="line">    int3(0, 1, 1),</span><br><span class="line"></span><br><span class="line">    int3(1,-1,-1),</span><br><span class="line">    int3(1,-1, 0),</span><br><span class="line">    int3(1,-1, 1),</span><br><span class="line">    int3(1, 0,-1),</span><br><span class="line">    int3(1, 0, 0),</span><br><span class="line">    int3(1, 0, 1),</span><br><span class="line">    int3(1, 1,-1),</span><br><span class="line">    int3(1, 1, 0),</span><br><span class="line">    int3(1, 1, 1),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Derive the Neighbor Grid Index from the world position</span><br><span class="line">float3 UnitPos;</span><br><span class="line">NeighborGrid.SimulationToUnit(Position, SimulationToUnit, UnitPos);</span><br><span class="line"></span><br><span class="line">int3 Index;</span><br><span class="line">NeighborGrid.UnitToIndex(UnitPos, Index.x,Index.y,Index.z);</span><br><span class="line"></span><br><span class="line">int3 NumCells;</span><br><span class="line">NeighborGrid.GetNumCells(NumCells.x, NumCells.y, NumCells.z);</span><br><span class="line"></span><br><span class="line">// loop over all neighbors in this cell</span><br><span class="line">int MaxNeighborsPerCell;</span><br><span class="line">NeighborGrid.MaxNeighborsPerCell(MaxNeighborsPerCell);</span><br><span class="line"></span><br><span class="line">float3 CellSize = WorldGridExtent / NumCells;</span><br><span class="line"></span><br><span class="line">float DesitySum = 0;</span><br><span class="line">float SmoothRadius = CellSize.x;  // In UE, the length unit is cm, but now just see it as m</span><br><span class="line">float h2 = SmoothRadius * SmoothRadius;</span><br><span class="line"></span><br><span class="line">float KernelPoly6 = 315.0 / (64.0 * 3.141592 * pow(SmoothRadius, 9));  // 1/m^9</span><br><span class="line"></span><br><span class="line">float temp_max = 0;</span><br><span class="line">for(int xxx = 0; xxx &lt; 27; ++xxx)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i &lt; MaxNeighborsPerCell; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        const int3 IndexToUse = Index + IndexOffsets[xxx];</span><br><span class="line">        </span><br><span class="line">        int NeighborLinearIndex;</span><br><span class="line">        NeighborGrid.NeighborGridIndexToLinear(IndexToUse.x, IndexToUse.y, IndexToUse.z, i, NeighborLinearIndex);</span><br><span class="line">        </span><br><span class="line">        int CurrNeighborIdx;</span><br><span class="line">        NeighborGrid.GetParticleNeighbor(NeighborLinearIndex, CurrNeighborIdx);</span><br><span class="line">        </span><br><span class="line">        // temp bool used to catch valid/invalid results for direct reads</span><br><span class="line">        bool myBool; </span><br><span class="line">        float3 OtherPos;</span><br><span class="line">        DirectReads.GetVectorByIndex&lt;Attribute=&quot;Position&quot;&gt;(CurrNeighborIdx, myBool, OtherPos);</span><br><span class="line"></span><br><span class="line">        const float3 vectorFromOtherToSelf = Position - OtherPos;</span><br><span class="line">        const float r = length(vectorFromOtherToSelf);  // In UE, the length unit is cm, but now just see it as m</span><br><span class="line">        const float h2_r2 = h2 - r * r;</span><br><span class="line"></span><br><span class="line">        if(IndexToUse.x &gt;= 0 &amp;&amp; IndexToUse.x &lt; NumCells.x &amp;&amp;</span><br><span class="line">           IndexToUse.y &gt;= 0 &amp;&amp; IndexToUse.y &lt; NumCells.y &amp;&amp;</span><br><span class="line">           IndexToUse.z &gt;= 0 &amp;&amp; IndexToUse.z &lt; NumCells.z &amp;&amp;</span><br><span class="line">           CurrNeighborIdx != -1 &amp;&amp; r &lt; SmoothRadius)</span><br><span class="line">        &#123;</span><br><span class="line">            if(SelfParticleIndex == CurrNeighborIdx)</span><br><span class="line">            &#123;</span><br><span class="line">                DesitySum += pow(h2, 3);  // m^3</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                DesitySum += pow(h2_r2, 3);  // m^3</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Density = KernelPoly6 * PointMass * DesitySum;  // kg/m^3</span><br><span class="line">Pressure = max((Density - RestDensity) * GasConstantK, 0);  // N/m^2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="Problem-NeighborGrid-GetCellSize-return-0">Problem: NeighborGrid.GetCellSize return 0</h3><p>This method has an error, that <code>NeighborGrid.GetCellSize</code> always return 0.</p><p>I have post a thread in UE forum,</p><p><a href="https://forums.unrealengine.com/t/ue5-niagara-how-does-neighbor-grid-3d-getcellsize-working-it-always-return-0/1564078">UE5 Niagara How does Neighbor Grid 3D GetCellSize working? It always return 0</a></p><h3 id="Solution">Solution</h3><p>but now just quickly fix it by passing extra value.</p><p>Solution is to add <code>WorldGridExtent</code> input, and calcuate cellsize by myself.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 CellSize = WorldGridExtent / NumCells;</span><br></pre></td></tr></table></figure><h3 id="Problem-pow-0-01-3-return-NaN">Problem: pow(-0.01, 3) return NaN</h3><p>After that, I found power of negative number may return NaN, such as <code>pow(-0.01, 3)</code> return NaN.</p><figure style="width: 529px" class="align-center"><img src="/images/ue5_niagara_sph/pow_return_NaN.png"><figcaption align = "center">Fig: pow(-0.01, 3) return NaN</figcaption></figure><h3 id="Solution-2">Solution</h3><p>So solution is add a condition statement <code>r &lt; SmoothRadius</code>, to avoid power of negative number.</p><h2 id="Solve-Force">Solve Force</h2><h3 id="Module-View-2">Module View</h3><figure style="width: 1001px" class="align-center"><img src="/images/ue5_niagara_sph/solve_force_input.png"><figcaption align = "center">Fig: Solve Force Input</figcaption></figure><figure style="width: 376px" class="align-center"><img src="/images/ue5_niagara_sph/solve_force_output.png"><figcaption align = "center">Fig: Solve Force Output</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">OutAcceleration = float3(0,0,0);</span><br><span class="line"></span><br><span class="line">#if GPU_SIMULATION</span><br><span class="line">const int3 IndexOffsets [ 27 ] = </span><br><span class="line">&#123;</span><br><span class="line">    int3(-1,-1,-1),</span><br><span class="line">    int3(-1,-1, 0),</span><br><span class="line">    int3(-1,-1, 1),</span><br><span class="line">    int3(-1, 0,-1),</span><br><span class="line">    int3(-1, 0, 0),</span><br><span class="line">    int3(-1, 0, 1),</span><br><span class="line">    int3(-1, 1,-1),</span><br><span class="line">    int3(-1, 1, 0),</span><br><span class="line">    int3(-1, 1, 1),</span><br><span class="line"></span><br><span class="line">    int3(0,-1,-1),</span><br><span class="line">    int3(0,-1, 0),</span><br><span class="line">    int3(0,-1, 1),</span><br><span class="line">    int3(0, 0,-1),</span><br><span class="line">    int3(0, 0, 0),</span><br><span class="line">    int3(0, 0, 1),</span><br><span class="line">    int3(0, 1,-1),</span><br><span class="line">    int3(0, 1, 0),</span><br><span class="line">    int3(0, 1, 1),</span><br><span class="line"></span><br><span class="line">    int3(1,-1,-1),</span><br><span class="line">    int3(1,-1, 0),</span><br><span class="line">    int3(1,-1, 1),</span><br><span class="line">    int3(1, 0,-1),</span><br><span class="line">    int3(1, 0, 0),</span><br><span class="line">    int3(1, 0, 1),</span><br><span class="line">    int3(1, 1,-1),</span><br><span class="line">    int3(1, 1, 0),</span><br><span class="line">    int3(1, 1, 1),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Derive the Neighbor Grid Index from the world position</span><br><span class="line">float3 UnitPos;</span><br><span class="line">NeighborGrid.SimulationToUnit(Position, SimulationToUnit, UnitPos);</span><br><span class="line"></span><br><span class="line">int3 Index;</span><br><span class="line">NeighborGrid.UnitToIndex(UnitPos, Index.x,Index.y,Index.z);</span><br><span class="line"></span><br><span class="line">int3 NumCells;</span><br><span class="line">NeighborGrid.GetNumCells(NumCells.x, NumCells.y, NumCells.z);</span><br><span class="line"></span><br><span class="line">// loop over all neighbors in this cell</span><br><span class="line">int MaxNeighborsPerCell;</span><br><span class="line">NeighborGrid.MaxNeighborsPerCell(MaxNeighborsPerCell);</span><br><span class="line"></span><br><span class="line">float3 CellSize = WorldGridExtent / NumCells;  // cm</span><br><span class="line"></span><br><span class="line">float SmoothRadius = CellSize.x;  // In UE, the length unit is cm, but now just see it as m</span><br><span class="line">float h2 = SmoothRadius * SmoothRadius;  // m^2</span><br><span class="line"></span><br><span class="line">float KernelSpiky = -45.0 / (3.141592 * pow(SmoothRadius, 6));  // 1/m^6</span><br><span class="line">float KernelViscosity = 45.0 / (3.141592 * pow(SmoothRadius, 6));  // 1/m^6</span><br><span class="line"></span><br><span class="line">for(int xxx = 0; xxx &lt; 27; ++xxx)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i &lt; MaxNeighborsPerCell; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        const int3 IndexToUse = Index + IndexOffsets[xxx];</span><br><span class="line">        </span><br><span class="line">        int NeighborLinearIndex;</span><br><span class="line">        NeighborGrid.NeighborGridIndexToLinear(IndexToUse.x, IndexToUse.y, IndexToUse.z, i, NeighborLinearIndex);</span><br><span class="line">        </span><br><span class="line">        int CurrNeighborIdx;</span><br><span class="line">        NeighborGrid.GetParticleNeighbor(NeighborLinearIndex, CurrNeighborIdx);</span><br><span class="line">        </span><br><span class="line">        // avoid r divided by 0</span><br><span class="line">        if (SelfParticleIndex == CurrNeighborIdx)</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // temp bool used to catch valid/invalid results for direct reads</span><br><span class="line">        bool myBool; </span><br><span class="line">        float3 OtherPos;</span><br><span class="line">        DirectReads.GetVectorByIndex&lt;Attribute=&quot;Position&quot;&gt;(CurrNeighborIdx, myBool, OtherPos);</span><br><span class="line">        float OtherDensity;</span><br><span class="line">        DirectReads.GetFloatByIndex&lt;Attribute=&quot;Density&quot;&gt;(CurrNeighborIdx, myBool, OtherDensity);</span><br><span class="line">        float OtherPressure;</span><br><span class="line">        DirectReads.GetFloatByIndex&lt;Attribute=&quot;Pressure&quot;&gt;(CurrNeighborIdx, myBool, OtherPressure);</span><br><span class="line">        float3 OtherVel;</span><br><span class="line">        DirectReads.GetVectorByIndex&lt;Attribute=&quot;Velocity&quot;&gt;(CurrNeighborIdx, myBool, OtherVel);</span><br><span class="line"></span><br><span class="line">        const float3 vectorFromOtherToSelf = Position - OtherPos;</span><br><span class="line">        const float3 dirFromOtherToSelf = normalize(vectorFromOtherToSelf);  // unit dir</span><br><span class="line">        const float r = length(vectorFromOtherToSelf);  // In UE, the length unit is cm, but now just see it as m</span><br><span class="line"></span><br><span class="line">        if(IndexToUse.x &gt;= 0 &amp;&amp; IndexToUse.x &lt; NumCells.x &amp;&amp;</span><br><span class="line">           IndexToUse.y &gt;= 0 &amp;&amp; IndexToUse.y &lt; NumCells.y &amp;&amp;</span><br><span class="line">           IndexToUse.z &gt;= 0 &amp;&amp; IndexToUse.z &lt; NumCells.z &amp;&amp;</span><br><span class="line">           CurrNeighborIdx != -1 &amp;&amp; r &lt; SmoothRadius)</span><br><span class="line">        &#123;</span><br><span class="line">            const float h_r = SmoothRadius - r; // m</span><br><span class="line">            const float h2_r2 = h2 - r * r; // m^2</span><br><span class="line"></span><br><span class="line">            // F_Pressure</span><br><span class="line">            const float3 pterm = -PointMass * KernelSpiky * h_r * h_r * (Pressure + OtherPressure) / (2.f * Density * OtherDensity) * dirFromOtherToSelf;</span><br><span class="line"></span><br><span class="line">            // F_Viscosity</span><br><span class="line">            const float3 vterm = PointMass * KernelViscosity * Viscosity * h_r * (OtherVel - Velocity) / (Density * OtherDensity);</span><br><span class="line"></span><br><span class="line">            OutAcceleration += pterm + vterm;  // m/s^2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="Advent">Advent</h2><h3 id="Module-View-3">Module View</h3><figure style="width: 580px" class="align-center"><img src="/images/ue5_niagara_sph/advent_input.png"><figcaption align = "center">Fig: Advent Input</figcaption></figure><figure style="width: 635px" class="align-center"><img src="/images/ue5_niagara_sph/advent_output.png"><figcaption align = "center">Fig: Advent Output</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">OutVelocity = float3(0.0, 0.0, 0.0);</span><br><span class="line">OutPosition = float3(0.0, 0.0, 0.0);</span><br><span class="line"></span><br><span class="line">#if GPU_SIMULATION</span><br><span class="line"></span><br><span class="line">Acceleration += Gravity;  // m/s^2</span><br><span class="line"></span><br><span class="line">// acceleration limit</span><br><span class="line">if(length(Acceleration) &gt; MaxAccel)</span><br><span class="line">&#123;</span><br><span class="line">Acceleration = normalize(Acceleration) * MaxAccel;  // m/s^2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// advent</span><br><span class="line">Velocity += 100 * Acceleration * DeltaTime;  // cm/s</span><br><span class="line"></span><br><span class="line">// velocity limit</span><br><span class="line">if(length(Velocity) &gt; MaxVelocity)</span><br><span class="line">&#123;</span><br><span class="line">Velocity = normalize(Velocity) * MaxVelocity;  // cm/s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// advent</span><br><span class="line">Position += Velocity * DeltaTime;  // cm</span><br><span class="line"></span><br><span class="line">// wall avoidance</span><br><span class="line">if(Position.x &lt; -WorldGridExtent.x/2)</span><br><span class="line">&#123;</span><br><span class="line">    Velocity.x *= WallDamping;</span><br><span class="line">    Position.x = -WorldGridExtent.x/2;</span><br><span class="line">&#125;</span><br><span class="line">if(Position.x &gt; WorldGridExtent.x/2)</span><br><span class="line">&#123;</span><br><span class="line">    Velocity.x *= WallDamping;</span><br><span class="line">    Position.x = WorldGridExtent.x/2;</span><br><span class="line">&#125;</span><br><span class="line">if(Position.y &lt; -WorldGridExtent.y/2)</span><br><span class="line">&#123;</span><br><span class="line">    Velocity.y *= WallDamping;</span><br><span class="line">    Position.y = -WorldGridExtent.y/2;</span><br><span class="line">&#125;</span><br><span class="line">if(Position.y &gt; WorldGridExtent.y/2)</span><br><span class="line">&#123;</span><br><span class="line">    Velocity.y *= WallDamping;</span><br><span class="line">    Position.y = WorldGridExtent.y/2;</span><br><span class="line">&#125;</span><br><span class="line">if(Position.z &lt; -WorldGridExtent.z/2)</span><br><span class="line">&#123;</span><br><span class="line">    Velocity.z *= WallDamping;</span><br><span class="line">    Position.z = -WorldGridExtent.z/2;</span><br><span class="line">&#125;</span><br><span class="line">if(Position.z &gt; WorldGridExtent.z/2)</span><br><span class="line">&#123;</span><br><span class="line">    Velocity.z *= WallDamping;</span><br><span class="line">    Position.z = WorldGridExtent.z/2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OutPosition = Position;  // cm</span><br><span class="line">OutVelocity = Velocity;  // cm</span><br><span class="line"></span><br><span class="line">#endif // GPU_SIMULATION</span><br></pre></td></tr></table></figure><h3 id="Problem-Oscillation-may-be-too-violent">Problem: Oscillation may be too violent</h3><p>You may find your particles have violent oscillation and never become idle, which is unexpected.</p><h3 id="Solution-3">Solution</h3><p>Simulation method has common problem about stability, a direct solution is to reduce your timestep.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeltaTime = DeltaTime / 5;</span><br></pre></td></tr></table></figure><p>However, it will make your particle effect very slow, it is unbearable for gamer.</p><p>Or you can increase viscoity, reduce acceleration limit and velocity limit.</p><h2 id="Current-Effect">Current Effect</h2><p>Current effect is as below, the particles should be stacked multiple layer, and have little oscillation.</p><figure style="width: 345px" class="align-center"><img src="/images/ue5_niagara_sph/effect_1.gif"><figcaption align = "center">Fig: Current Effect</figcaption></figure><h3 id="Problem-Effect-doesn’t-show-up-in-level">Problem: Effect doesn’t show up in level</h3><p>If you drag your Niagara System to your level and then there is nothing show up.</p><h3 id="Solution-4">Solution</h3><p>If particles is too small, then, maybe because of LOD or some built-in engine behaviour, you can’t see it in the level. To make particles visible, you should change <code>Sprite Size</code>.</p><figure style="width: 536px" class="align-center"><img src="/images/ue5_niagara_sph/too_small_to_see.png"><figcaption align = "center">Fig: Too small to see particles</figcaption></figure><figure style="width: 273px" class="align-center"><img src="/images/ue5_niagara_sph/change_sprite_size.png"><figcaption align = "center">Fig: Change Sprite Size</figcaption></figure><h2 id="Render-Setup">Render Setup</h2><p>Traditional method of rendering water surface is marching cube method. It generates density field from particles, then extract polygon mesh isosurface. It can be done on GPU, but very expensive.</p><p>Another way is to project all all particles into screen space. A direct idea is using depth buffer, but I think that depth buffer can only tells where the particles are. However, later I learned that normal can be calculated from depth buffer.</p><h3 id="Another-Neighbor-Grid-3D-Used-for-rendering-in-Screen-Space">Another Neighbor Grid 3D Used for rendering in Screen Space</h3><p>At first, project all particles into screen space. More specifically, you create an empty depth buffer, then project each particle’s world position into screen space position, and draw a circle with given radius, in the depth buffer, with the particle’s depth. For sure, small depth value will override large depth value.</p><p>However, if you draw circle into depth buffer, you may encounter memory access conflict becuase you are running kernel function on each particles. Then each thread may need to write same pixel of depth buffer at the same time. You should take strategy to solve the conflict, such as mutex lock. It definitly hurts parallel performance.</p><p>Think in the opposite way, after creating an empty depth buffer, for each pixels in screen space, find particles projected in the screen space position of pixel. To do this, create a new Neighbor Grid 3D, which is used for accelerating searching particles. From the view of occupying space, the Neighbor Grid 3D should occupys full space of screen, so one cell of Neighbor Grid 3D may overlaps with many pixels.</p><p>Now kernel function on each pixels may read particles attributes at the same time, but there is not conflict problem.</p><figure style="width: 600px" class="align-center"><img src="/images/ue5_niagara_sph/sph_render.svg"><figcaption align = "center">Fig: Render each pixels</figcaption></figure><h3 id="Use-Grid-2D-to-Store-Depth-Value">Use Grid 2D to Store Depth Value</h3><p>Here Grid 2D is used to stored depth and then write it into Render Target.</p><p>To initialize Grid 2D, you can use bulit-in module <code>Grid 2D Set Resolution</code>. But if can’t find it after clicking plus symbol on the right side of <code>Emitter Spawn</code>, the reason may be you should uncheck <code>Library Only</code>.</p><p><a href="https://forums.unrealengine.com/t/grid2d-collection-no-cellnums-setting-shown-in-ue5-niagara/531971/4">Grid2d collection no cellnums setting shown in ue5 niagara</a></p><p>Similarly, you can use built-in module <code>Neighbor Grid 3D Set Resolution</code> to initialize your Render Neighbor Grid 3D.</p><p>You can also set half float format for Grid 2D.</p><figure style="width: 587px" class="align-center"><img src="/images/ue5_niagara_sph/set_grid_2d_half_float.png"><figcaption align = "center">Fig: Set Half Float Format for Grid 2D</figcaption></figure><h3 id="Texture-Render-Target-and-Render-Target-2D">Texture Render Target and Render Target 2D</h3><p>You should be familiar with Render Target file in Content Browser, but you may don’t know how to link it with Niagara System.</p><p>First you should create a Texture Render Target with <code>User</code> namespace.</p><p>Be caution, it is not Render Target 2D. For example, you can see I create a Render Target 2D named <code>RT_Depth</code> and a Texture Render Target named <code>TextureRenderTarget_Depth</code>.</p><figure style="width: 510px" class="align-center"><img src="/images/ue5_niagara_sph/RT_2D_and_Texture_RT.png"><figcaption align = "center">Fig: Texture Render Target and Render Target 2D</figcaption></figure><p>Then crate a Render Target 2D also named <code>RT_Depth</code> with <code>Emitter</code> namespace, drag it into <code>Emitter Spawn</code> to initialize it.</p><p>Then you will see, in property <code>Render Target User Parameter</code>, there is only one choice <code>TextureRenderTarget_Depth</code>. It means that you can only assign Texture Render Target as Render Target User Parameter of Render Target 2D.</p><figure style="width: 1079px" class="align-center"><img src="/images/ue5_niagara_sph/set_Texture_RT_to_RT_2D.png"><figcaption align = "center">Fig: Set Texture Render Target as Render Target User Parameter of Render Target 2D</figcaption></figure><p>After setting, you validate whether the Render Target is associate with Niagara System immediately. To do this, create a new simulation stage, set <code>Data Interface</code> as Render Target 2D. Create a new module, enter the module, add Render Target 2D in Map Get, drag from Render Target 2D input and search <code>Set Render Target Value</code> in the popup. Create <code>Execution Index</code> block, link to <code>Linear To Index</code>, link <code>IndexX, IndexY</code> to <code>Set Render Target Value</code>. Create <code>Make Linear Color</code> and link to <code>Set Render Target Value</code>. For example, choose a purple color, open your Render Target file from Content Browser, then you will see your Render Target change corresponding to your <code>Make Linear Color</code> block.</p><h3 id="Overview">Overview</h3><figure style="width: 250px" class="align-center"><img src="/images/ue5_niagara_sph/overview_3.png"><figcaption align = "center">Fig: Overview 3</figcaption></figure><figure style="width: 266px" class="align-center"><img src="/images/ue5_niagara_sph/overview_4.png"><figcaption align = "center">Fig: Overview 4</figcaption></figure><h2 id="Calc-Depth-And-Write-Neighbor">Calc Depth And Write Neighbor</h2><h3 id="Module-View-4">Module View</h3><p>First module is <code>CalcuateParticleDepth</code>.</p><figure style="width: 1171px" class="align-center"><img src="/images/ue5_niagara_sph/CalcuateParticleDepth_1.png"><figcaption align = "center">Fig: CalcuateParticleDepth Module View 1</figcaption></figure><figure style="width: 1105px" class="align-center"><img src="/images/ue5_niagara_sph/CalcuateParticleDepth_2.png"><figcaption align = "center">Fig: CalcuateParticleDepth Module View 2</figcaption></figure><p>The hlsl is borrow from <code>World Position to Screen UV</code> block. This is about projecting particle’s position into screen space.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ScreenUV = float2(0,0);</span><br><span class="line"></span><br><span class="line">#if GPU_SIMULATION</span><br><span class="line"></span><br><span class="line">float4 SamplePosition = float4(In_SamplePos, 1);</span><br><span class="line">float4 ClipPosition = mul(SamplePosition, View.WorldToClip);</span><br><span class="line">float2 ScreenPosition = ClipPosition.xy / ClipPosition.w;</span><br><span class="line"></span><br><span class="line">ScreenUV = float2(ScreenPosition.x, ScreenPosition.y*-1)/2 + (0.5, 0.5);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>Calcuating depth is simple, in short, it is vector multiples with forward.</p><figure style="width: 600px" class="align-center"><img src="/images/ue5_niagara_sph/sph_particle_depth.svg"><figcaption align = "center">Fig: Particle Depth</figcaption></figure><p>You should also check whether the particle is behind camera, if so, then discard.</p><p>The second module is <code>WriteRenderNeighbor</code>. This is about storing particles into Neighbor Grid 3D according to particle’s projected position.</p><figure style="width: 788px" class="align-center"><img src="/images/ue5_niagara_sph/WriteRenderNeighbor_1.png"><figcaption align = "center">Fig: WriteRenderNeighbor Module View 1</figcaption></figure><figure style="width: 677px" class="align-center"><img src="/images/ue5_niagara_sph/WriteRenderNeighbor_2.png"><figcaption align = "center">Fig: WriteRenderNeighbor Module View 2</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#if GPU_SIMULATION</span><br><span class="line"></span><br><span class="line">int3 Index;</span><br><span class="line">NeighborGrid.UnitToIndex(float3(UnitPos, 0), Index.x,Index.y,Index.z);</span><br><span class="line"></span><br><span class="line">int3 NumCells;</span><br><span class="line">NeighborGrid.GetNumCells(NumCells.x, NumCells.y, NumCells.z);</span><br><span class="line"></span><br><span class="line">int MaxNeighborsPerCell;</span><br><span class="line">NeighborGrid.MaxNeighborsPerCell(MaxNeighborsPerCell);</span><br><span class="line"></span><br><span class="line">if (Index.x &gt;= 0 &amp;&amp; Index.x &lt; NumCells.x &amp;&amp; </span><br><span class="line">    Index.y &gt;= 0 &amp;&amp; Index.y &lt; NumCells.y)</span><br><span class="line">&#123;</span><br><span class="line">    int LinearIndex;</span><br><span class="line">    NeighborGrid.IndexToLinear(Index.x, Index.y, 0, LinearIndex);</span><br><span class="line"></span><br><span class="line">    int PreviousNeighborCount;</span><br><span class="line">    NeighborGrid.SetParticleNeighborCount(LinearIndex, 1, PreviousNeighborCount);</span><br><span class="line"></span><br><span class="line">    if (PreviousNeighborCount &lt; MaxNeighborsPerCell)</span><br><span class="line">    &#123;</span><br><span class="line">        int NeighborGridLinear;</span><br><span class="line">        NeighborGrid.NeighborGridIndexToLinear(Index.x, Index.y, Index.z, PreviousNeighborCount, NeighborGridLinear);</span><br><span class="line"></span><br><span class="line">        int IGNORE;</span><br><span class="line">        NeighborGrid.SetParticleNeighbor(NeighborGridLinear, InstanceIdx, IGNORE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="Problem-Capturing-result-of-camera-query-always-located-at-world-origin">Problem: Capturing result of camera query always located at world origin</h3><p>Niagara System capturing result of camera query always located at world origin. That means, only when player look at world origin can player see it, no matter where the Niagara System instance is.</p><p>For example, in this gif, Niagara System is moving in the world, but capturing result doesn’t move in the Render Target.</p><figure style="width: 622px" class="align-center"><img src="/images/ue5_niagara_sph/sph_moving_but_dont_move_in_render_target.gif"><figcaption align = "center">Fig: Capturing result of camera query always located at world origin</figcaption></figure><h3 id="Solution-5">Solution</h3><p>I don’t know it is a bug or not. Maybe it is because I enable <code>Local Space</code> in emitter property. Anyway, it is confusing.</p><p>However, simple hack is adding Niagara System position to particle’s position when you are capturing particles.</p><figure style="width: 860px" class="align-center"><img src="/images/ue5_niagara_sph/simple_hack.png"><figcaption align = "center">Fig: Simple hack to ensure camera captures right particle position</figcaption></figure><p>I have post a discussion in UE forum, maybe someone knows why.</p><p><a href="https://forums.unrealengine.com/t/niagara-system-capturing-result-of-camera-query-always-located-at-world-origin/1582261">Niagara System capturing result of camera query always located at world origin</a></p><p>But only add a Niagara System position is not enough. The result position reflected on the Render Target is still not correct.</p><p>So after trying, the correct position is particles’ position + Niagara System position / 2.</p><figure style="width: 848px" class="align-center"><img src="/images/ue5_niagara_sph/correct_pos_hack.png"><figcaption align = "center">Fig: Correct position hack</figcaption></figure><p>Although I haven’t said it here yet, if you have set Render Target as Material Input, and link it with opacity mask, you will see:</p><figure style="width: 662px" class="align-center"><img src="/images/ue5_niagara_sph/render_mask.gif"><figcaption align = "center">Fig: Correct Position in Render Target</figcaption></figure><p>To observe this, scale of plane should be a litter smaller than it should be.</p><h2 id="Draw-Depth-To-Grid-2D">Draw Depth To Grid 2D</h2><p>Set <code>Iteration Source</code> as <code>Data Interface</code>, and drag <code>RenderGrid2D</code> to <code>Data Interface</code>, then in the module, if you set namespace of a value in map out as <code>STACKCONTEXT</code>, the value will be stored into <code>Data Interface</code> automatically.</p><p>Now, if you want <code>for loop</code> pixels, logically you first traverse Grid 2D, stored your desired value into cells of Grid 2D. After travering finished, you write value from Grid 2D to a render target.</p><figure style="width: 600px" class="align-center"><img src="/images/ue5_niagara_sph/sph_is_particle_overlap_with_cell.svg"><figcaption align = "center">Fig: Is particle overlap with cell?</figcaption></figure><p>If you found your Render Target shows cube-like particle but not sphere, try to adjust <code>RenderSpriteSize</code> from small value to large one.</p><h3 id="Module-View-5">Module View</h3><figure style="width: 987px" class="align-center"><img src="/images/ue5_niagara_sph/draw_depth_input.png"><figcaption align = "center">Fig: Draw Depth To Grid 2D Input</figcaption></figure><figure style="width: 631px" class="align-center"><img src="/images/ue5_niagara_sph/draw_depth_output.png"><figcaption align = "center">Fig: Draw Depth To Grid 2D Output</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">const int2 IndexOffsets [ 9 ] = </span><br><span class="line">&#123;</span><br><span class="line">    int2(-1,-1),</span><br><span class="line">    int2(-1, 0),</span><br><span class="line">    int2(-1, 1),</span><br><span class="line">    int2(0,-1),</span><br><span class="line">    int2(0, 0),</span><br><span class="line">    int2(0, 1),</span><br><span class="line">    int2(1,-1),</span><br><span class="line">    int2(1, 0),</span><br><span class="line">    int2(1, 1)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OutDepth = 0;</span><br><span class="line"></span><br><span class="line">#if GPU_SIMULATION</span><br><span class="line"></span><br><span class="line">int3 Index;</span><br><span class="line">NeighborGrid.UnitToIndex(float3(CellPos, 0), Index.x,Index.y,Index.z);</span><br><span class="line"></span><br><span class="line">int3 NumCells;</span><br><span class="line">NeighborGrid.GetNumCells(NumCells.x, NumCells.y, NumCells.z);</span><br><span class="line"></span><br><span class="line">int MaxNeighborsPerCell;</span><br><span class="line">NeighborGrid.MaxNeighborsPerCell(MaxNeighborsPerCell);</span><br><span class="line"></span><br><span class="line">float minDepth = 3.402823466e+38;</span><br><span class="line"></span><br><span class="line">for(int xxx = 0; xxx &lt; 9; ++xxx)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i &lt; MaxNeighborsPerCell; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        const int3 IndexToUse = int3(Index.x + IndexOffsets[xxx].x, Index.y + IndexOffsets[xxx].y, 0);</span><br><span class="line">        </span><br><span class="line">        int NeighborLinearIndex;</span><br><span class="line">        NeighborGrid.NeighborGridIndexToLinear(IndexToUse.x, IndexToUse.y, IndexToUse.z, i, NeighborLinearIndex);</span><br><span class="line">        </span><br><span class="line">        int CurrNeighborIdx;</span><br><span class="line">        NeighborGrid.GetParticleNeighbor(NeighborLinearIndex, CurrNeighborIdx);</span><br><span class="line"></span><br><span class="line">        bool myBool; </span><br><span class="line">        float2 ProjectedParticlePos;</span><br><span class="line">        ParticleReader.GetVector2DByIndex&lt;Attribute=&quot;ProjectedPos&quot;&gt;(CurrNeighborIdx, myBool, ProjectedParticlePos);</span><br><span class="line"></span><br><span class="line">        float ParticleDepth;</span><br><span class="line">        ParticleReader.GetFloatByIndex&lt;Attribute=&quot;Depth&quot;&gt;(CurrNeighborIdx, myBool, ParticleDepth);</span><br><span class="line">        </span><br><span class="line">        float DistanceFromCellToParticle = length(ProjectedParticlePos - CellPos);</span><br><span class="line">        float ProjectedRenderSpriteSize = RenderSpriteSize/ParticleDepth;</span><br><span class="line"></span><br><span class="line">        if(IndexToUse.x &gt;= 0 &amp;&amp; IndexToUse.x &lt; NumCells.x &amp;&amp;</span><br><span class="line">           IndexToUse.y &gt;= 0 &amp;&amp; IndexToUse.y &lt; NumCells.y &amp;&amp;</span><br><span class="line">           CurrNeighborIdx != -1 &amp;&amp;</span><br><span class="line">           DistanceFromCellToParticle &lt; ProjectedRenderSpriteSize &amp;&amp;</span><br><span class="line">           ParticleDepth != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            minDepth = minDepth &lt; ParticleDepth ? minDepth : ParticleDepth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if(minDepth &lt; 1e+38)</span><br><span class="line">&#123;</span><br><span class="line">    OutDepth = minDepth;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>There is still concern about we shouldn’t stored particle depth directly, because it is depth at particle cell. What we need is actually depth at cell center.</p><figure style="width: 600px" class="align-center"><img src="/images/ue5_niagara_sph/sph_actual_depth.svg"><figcaption align = "center">Fig: Particle actual depth</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">const int2 IndexOffsets [ 9 ] = </span><br><span class="line">&#123;</span><br><span class="line">    int2(-1,-1),</span><br><span class="line">    int2(-1, 0),</span><br><span class="line">    int2(-1, 1),</span><br><span class="line">    int2(0,-1),</span><br><span class="line">    int2(0, 0),</span><br><span class="line">    int2(0, 1),</span><br><span class="line">    int2(1,-1),</span><br><span class="line">    int2(1, 0),</span><br><span class="line">    int2(1, 1)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OutDepth = 0;</span><br><span class="line"></span><br><span class="line">#if GPU_SIMULATION</span><br><span class="line"></span><br><span class="line">int3 Index;</span><br><span class="line">NeighborGrid.UnitToIndex(float3(CellPos, 0), Index.x,Index.y,Index.z);</span><br><span class="line"></span><br><span class="line">int3 NumCells;</span><br><span class="line">NeighborGrid.GetNumCells(NumCells.x, NumCells.y, NumCells.z);</span><br><span class="line"></span><br><span class="line">int MaxNeighborsPerCell;</span><br><span class="line">NeighborGrid.MaxNeighborsPerCell(MaxNeighborsPerCell);</span><br><span class="line"></span><br><span class="line">float minDepth = 3.402823466e+38;</span><br><span class="line">int minDepthIndex = -1;</span><br><span class="line"></span><br><span class="line">for(int xxx = 0; xxx &lt; 9; ++xxx)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0; i &lt; MaxNeighborsPerCell; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        const int3 IndexToUse = int3(Index.x + IndexOffsets[xxx].x, Index.y + IndexOffsets[xxx].y, 0);</span><br><span class="line">        </span><br><span class="line">        int NeighborLinearIndex;</span><br><span class="line">        NeighborGrid.NeighborGridIndexToLinear(IndexToUse.x, IndexToUse.y, IndexToUse.z, i, NeighborLinearIndex);</span><br><span class="line">        </span><br><span class="line">        int CurrNeighborIdx;</span><br><span class="line">        NeighborGrid.GetParticleNeighbor(NeighborLinearIndex, CurrNeighborIdx);</span><br><span class="line"></span><br><span class="line">        bool myBool; </span><br><span class="line">        float2 ProjectedParticlePos;</span><br><span class="line">        ParticleReader.GetVector2DByIndex&lt;Attribute=&quot;ProjectedPos&quot;&gt;(CurrNeighborIdx, myBool, ProjectedParticlePos);</span><br><span class="line"></span><br><span class="line">        float ParticleDepth;</span><br><span class="line">        ParticleReader.GetFloatByIndex&lt;Attribute=&quot;Depth&quot;&gt;(CurrNeighborIdx, myBool, ParticleDepth);</span><br><span class="line">        </span><br><span class="line">        float DistanceFromCellToParticle = length(ProjectedParticlePos - CellPos);</span><br><span class="line">        float ProjectedRenderSpriteSize = RenderSpriteSize/ParticleDepth;</span><br><span class="line"></span><br><span class="line">        if(IndexToUse.x &gt;= 0 &amp;&amp; IndexToUse.x &lt; NumCells.x &amp;&amp;</span><br><span class="line">           IndexToUse.y &gt;= 0 &amp;&amp; IndexToUse.y &lt; NumCells.y &amp;&amp;</span><br><span class="line">           CurrNeighborIdx != -1 &amp;&amp;</span><br><span class="line">           DistanceFromCellToParticle &lt; ProjectedRenderSpriteSize &amp;&amp;</span><br><span class="line">           ParticleDepth != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            minDepth = minDepth &lt; ParticleDepth ? minDepth : ParticleDepth;</span><br><span class="line">            minDepthIndex = minDepth &lt; ParticleDepth ? minDepthIndex : CurrNeighborIdx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(minDepthIndex != -1)</span><br><span class="line">&#123;</span><br><span class="line">    bool myBool; </span><br><span class="line">    float2 ProjectedParticlePos;</span><br><span class="line">    ParticleReader.GetVector2DByIndex&lt;Attribute=&quot;ProjectedPos&quot;&gt;(minDepthIndex, myBool, ProjectedParticlePos);</span><br><span class="line"></span><br><span class="line">    float DistanceFromCellToParticle = length(ProjectedParticlePos - CellPos);</span><br><span class="line">    float ProjectedRenderSpriteSize = RenderSpriteSize/minDepth;</span><br><span class="line"></span><br><span class="line">    OutDepth = minDepth + ProjectedRenderSpriteSize - sqrt(ProjectedRenderSpriteSize * ProjectedRenderSpriteSize - DistanceFromCellToParticle * DistanceFromCellToParticle);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>But I think there is little difference between them.</p><h3 id="Problem-Performance-is-N-A">Problem: Performance is N/A</h3><p>Niagara is compiled successfully, but the running time of a certain simulation stage is N/A.</p><figure style="width: 887px" class="align-center"><img src="/images/ue5_niagara_sph/performance_NA.png"><figcaption align = "center">Fig: Performance is N/A</figcaption></figure><p>I have post a question in UE forum.</p><p><a href="https://forums.unrealengine.com/t/ue5-niagara-compilation-succeeded-but-certain-simulation-stages-performance-time-is-n-a/1575522">UE5 Niagara Compilation succeeded but certain simulation stage’s performance time is N/A</a></p><h3 id="Solution-6">Solution</h3><p>After one day of work, I found the error disappear surprisingly.</p><p>From the time I encounter the problem to the time I found the problem disappear, I have done many step, most of them are irrelevant about Grid 2D. The only relevant step is adding a built-in <code>Grid 2D Set Resolution</code> module. But if I delete the module, the performance logging time is still work well. So it is a magic and I don’t want to pay attention to this issue anymore.</p><h2 id="Bilateral-Filtering">Bilateral Filtering</h2><p>The module does Bilateral Filtering on depth map stored in Grid 2D. Blur will make your depth map smooth, which will make your normal map look less like particles. Gauss Filterign will blur the whole image, but Bilateral Filtering will preserves sharp edges.</p><h3 id="Module-View-6">Module View</h3><figure style="width: 736px" class="align-center"><img src="/images/ue5_niagara_sph/Bilateral_Filtering_input.png"><figcaption align = "center">Fig: Bilateral Filtering Input</figcaption></figure><figure style="width: 752px" class="align-center"><img src="/images/ue5_niagara_sph/Bilateral_Filtering_output.png"><figcaption align = "center">Fig: Bilateral Filtering Output</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">OutDepth = 0;</span><br><span class="line"></span><br><span class="line">#if GPU_SIMULATION</span><br><span class="line"></span><br><span class="line">int2 NumCells;</span><br><span class="line">Grid2D.GetNumCells(NumCells.x, NumCells.y);</span><br><span class="line"></span><br><span class="line">float weightSum = 0;</span><br><span class="line">float depthSum = 0;</span><br><span class="line"></span><br><span class="line">float CurrDepth;</span><br><span class="line">Grid2D.GetFloatValue&lt;Attribute=&quot;Depth&quot;&gt;(IndexX, IndexY, CurrDepth);</span><br><span class="line"></span><br><span class="line">if(CurrDepth &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">    for(int x = -BlurRadius; x &lt;= BlurRadius; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int y = -BlurRadius; y &lt;= BlurRadius; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            float spaceWeight = exp(-(x*x + y*y)*BlurScale*BlurScale);</span><br><span class="line"></span><br><span class="line">            float NeighborDepth;</span><br><span class="line">            Grid2D.GetFloatValue&lt;Attribute=&quot;Depth&quot;&gt;(IndexX + x, IndexY + y, NeighborDepth);</span><br><span class="line">            float r2 = (NeighborDepth - CurrDepth)*BlurDepthFalloff;</span><br><span class="line">            float depthWeight = exp(-r2*r2);</span><br><span class="line"></span><br><span class="line">            if(NeighborDepth &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                weightSum += spaceWeight * depthWeight;</span><br><span class="line">                depthSum += NeighborDepth * spaceWeight * depthWeight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(weightSum &gt; 0)&#123;</span><br><span class="line">    OutDepth = depthSum / weightSum;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>Toggle Blur module, you should see the difference.</p><figure style="width: 342px" class="align-center"><img src="/images/ue5_niagara_sph/disable_blur.png"><figcaption align = "center">Fig: Disable Blur</figcaption></figure><figure style="width: 330px" class="align-center"><img src="/images/ue5_niagara_sph/enable_blur.png"><figcaption align = "center">Fig: Enable Blur</figcaption></figure><p>However, blur parameter also matters. Inappropriate parameters are equivalent to you not blurring, and your normal map will end up looking like particles, such as the image above.</p><p>In the last I will show a more natural result, where parameters setting is:</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td style="text-align:center">BlurRadius</td><td style="text-align:center">5.0</td></tr><tr><td style="text-align:center">RenderSpriteSize</td><td style="text-align:center">3.0</td></tr><tr><td style="text-align:center">BlurDepthFalloff</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">BlurScale</td><td style="text-align:center">0.1</td></tr></tbody></table><h2 id="Draw-Depth-To-Render-Target">Draw Depth To Render Target</h2><p>Now <code>Data Interface</code> can choose Render Target 2D or Grid 2D.</p><h3 id="Module-View-7">Module View</h3><figure style="width: 1029px" class="align-center"><img src="/images/ue5_niagara_sph/DrawDepthRenderTarget_input.png"><figcaption align = "center">Fig: Draw Depth Render Target Input</figcaption></figure><figure style="width: 968px" class="align-center"><img src="/images/ue5_niagara_sph/DrawDepthRenderTarget_middle.png"><figcaption align = "center">Fig: Draw Depth Render Target Middle Part</figcaption></figure><figure style="width: 669px" class="align-center"><img src="/images/ue5_niagara_sph/DrawDepthRenderTarget_output.png"><figcaption align = "center">Fig: Draw Depth Render Target Output</figcaption></figure><h3 id="Problem-Only-one-line-in-Render-Target-is-white">Problem: Only one line in Render Target is white</h3><p>After drawing to render target, there should be a beautiful depth map in Render Target, but I only see one line in Render Target is white.</p><figure style="width: 1011px" class="align-center"><img src="/images/ue5_niagara_sph/only_one_line_is_white.png"><figcaption align = "center">Fig: Only One Line in Render Target is White</figcaption></figure><p>Log the proejcted position stored on particles, and it seems correct, because all of them are in (0,1) and there are not strange values.</p><figure style="width: 373px" class="align-center"><img src="/images/ue5_niagara_sph/projected_position_is_correct.png"><figcaption align = "center">Fig: Projected Position is Correct</figcaption></figure><p>Depth values stored on particles are also checked. They are located in (10, 100) roughly, and it is reasonable. My WorldGridExtent is (6,6,6), so distance of camera to particles should be of the same magnitude as grid length, if camera want to see the particles clearly.</p><p>Then another reason may be calcuation of index is wrong. Error may located in <code>Write Depth to Grid 2D</code> module or <code>Write Depth to Render Target</code> module.</p><p>Firstly I validate <code>Write Depth to Render Target</code> module quickly. I add a test module before <code>Write Depth to Render Target</code> module, add output <code>x*y</code> as <code>Depth</code>.</p><figure style="width: 249px" class="align-center"><img src="/images/ue5_niagara_sph/quick_validate_write_depth_to_render_target_1.png"><figcaption align = "center">Fig: Quickly Validate Write Depth to Render Target 1</figcaption></figure><figure style="width: 1240px" class="align-center"><img src="/images/ue5_niagara_sph/quick_validate_write_depth_to_render_target_2.png"><figcaption align = "center">Fig: Quickly Validate Write Depth to Render Target 2</figcaption></figure><figure style="width: 511px" class="align-center"><img src="/images/ue5_niagara_sph/quick_validate_write_depth_to_render_target_3.png"><figcaption align = "center">Fig: Quickly Validate Write Depth to Render Target 3</figcaption></figure><p>You can see Render Target perfectly displayed <code>x*y</code> result, so <code>Write Depth to Render Target</code> module has no error. So problem is in <code>Write Depth to Grid 2D</code> module.</p><p>In <code>Write Depth to Grid 2D</code> module, type same testing code in the end of custom hlsl, and you will get same result on Render Target.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutDepth = (float)Index.x/(float)NumCells.x * (float)Index.y/(float)NumCells.y;</span><br></pre></td></tr></table></figure><p>Use <code>CellPos</code> to get same result.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutDepth = CellPos.x * CellPos.y;</span><br></pre></td></tr></table></figure><p>At least it shows that grid index and <code>CellPos</code> is right.</p><p>After I add condition statement between <code>IndexToUse</code> and <code>NumCells</code>, the flashing white line disappear, only pure black left.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(IndexToUse.x &gt;= 0 &amp;&amp; IndexToUse.x &lt; NumCells.x &amp;&amp;</span><br><span class="line">    IndexToUse.y &gt;= 0 &amp;&amp; IndexToUse.y &lt; NumCells.y &amp;&amp;</span><br><span class="line">    CurrNeighborIdx != -1 &amp;&amp;</span><br><span class="line">    DistanceFromCellToParticle &lt; ProjectedRenderSpriteSize &amp;&amp;</span><br><span class="line">    ParticleDepth != 0)</span><br><span class="line">&#123;</span><br><span class="line">    minDepth = minDepth &lt; ParticleDepth ? minDepth : ParticleDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then I realize that problem may not lies in Grid 2D but in Neighbor Grid 3D.</p><p>In fact, if you set <code>-CurrNeighborIdx</code> to depth then you will see pure white in Render Target, it means you never find a valid neighbor.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minDepth = -CurrNeighborIdx;</span><br></pre></td></tr></table></figure><p>I guess particles may not be stored into Neighbor Grid 3D, so I go back to <code>Write Render Neighbor</code> module.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#if GPU_SIMULATION</span><br><span class="line"></span><br><span class="line">int3 Index;</span><br><span class="line">NeighborGrid.UnitToIndex(float3(UnitPos, 0), Index.x,Index.y,Index.z);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">OutIndexX = Index.x;</span><br><span class="line">OutIndexY = Index.y;</span><br><span class="line">OutIndexZ = Index.z;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><figure style="width: 496px" class="align-center"><img src="/images/ue5_niagara_sph/unit_to_index_is_right.png"><figcaption align = "center">Fig: Unit to Index is right</figcaption></figure><p>So next I have tried other debug method, but still don’t know what is wrong.</p><h3 id="Solution-7">Solution</h3><p>The finally solution is pretty simple: I should drag Neighbor Grid 3D to Emitter Spawn Group to initialize it.</p><figure style="width: 267px" class="align-center"><img src="/images/ue5_niagara_sph/have_to_drag_neighbor_grid_3d_to_emitter_spawn.png"><figcaption align = "center">Fig: Have to drag Neighbor Grid 3D to Emitter Spawn Group</figcaption></figure><p>It is confusing me bacause if I use the Neighbor Grid 3D in later module, there is no error.</p><p>Anyway, leave it behind.</p><h3 id="Problem-Unexpected-Render-Target-Flickering">Problem: Unexpected Render Target Flickering</h3><p>Right after fix the problem of initializing Neighbor Grid 3D, my Render Target finally have right depth map but unexpected flickering occurs.</p><p>The flickering in the recorded gif is not due to image compression.</p><figure style="width: 688px" class="align-center"><img src="/images/ue5_niagara_sph/flashing_render_target.gif"><figcaption align = "center">Fig: Unexpected Flickering</figcaption></figure><figure style="width: 688px" class="align-center"><img src="/images/ue5_niagara_sph/flashing_render_target_stop_at_one_frame.png"><figcaption align = "center">Fig: Render Target Stop at One Frame</figcaption></figure><p>I have searched UE forum:</p><p><a href="https://forums.unrealengine.com/t/niagara-particles-flickering-in-latest-26-release/153007/1">Niagara particles flickering in latest .26 release</a></p><p>Their solutions:</p><ol><li><p>Reduce spawn rate</p></li><li><p>Reduce particle emitter sphere radius</p></li><li><p>Enlarge <code>Fixed Bounds</code> in <code>Emitter Properties</code></p></li><li><p>Change to <code>CPU Simualtion</code></p></li><li><p>Set the <code>Sort Mode</code> to <code>View Depth</code> in Sprite Renderer</p><p>It mey be problem about translucent sorting</p></li><li><p>Enable <code>Camera Distance Culling</code> in Sprite Renderer, adjust max camera distance</p></li><li><p>Change the mesh size much smaller</p></li></ol><p>However, in this case, it is not about translucent particles, because it is not about capturing particles actually. The camera capture only capture particles’ depth. Then simulation stage writes the depth into Grid 2D. So my situation may be totally different from other.</p><h3 id="Solution-8">Solution</h3><p>Finally I don’t want to waste my time on the engine bug, so I give up trying.</p><p>But just after an hour I come back to work, the problem disapper amazingly.</p><p>Nothing to say with the kind of situtation.</p><p>Updated: After a few days, I happen to find the flickering reason: Render Target is switching between scene capturing result and Niagara System capturing result. You can see it clearly in my record.</p><figure style="width: 955px" class="align-center"><img src="/images/ue5_niagara_sph/flickering_reason.gif"><figcaption align = "center">Fig: Flickering Reason</figcaption></figure><p>So it is engine bug, not my fault.</p><h3 id="Problem-Render-Target-has-content-in-Niagara-System-Preview-but-no-in-the-level">Problem: Render Target has content in Niagara System Preview but no in the level</h3><p>After I found Render Target doesn’t flicker, I put the Niagara System into level. Becuase my WorldGridExtent is very small, which is (6, 6, 6), so I had to scale the Niagara System to (100, 100, 100) size. I had talked before sprite size should also be large, but now we don’t need sprite to show where the particles are, we only need a plane to show fluid rendering result, so we can disable sprite renderer in the SPH emitter. But as I continued to make the fluid material, I found that Render Target has content in Niagara System Preview but no in the level.</p><figure style="width: 955px" class="align-center"><img src="/images/ue5_niagara_sph/no_content_in_the_level.png"><figcaption align = "center">Fig: Render Target has content in Niagara System Preview but no in the level</figcaption></figure><h3 id="Solution-9">Solution</h3><p>It recalls me that small particles is invisible, so I guess that even though we scale Niagara System to make particles visible, in the camera view, it doesn’t apply scale transform to particles in the level. Camera is always capturing particles of original size, so particles move in small space. While small size particles is invisible, or I guess it is also related with small spacing. Combining these two factors, which makes camera can’t capture particles in the level.</p><p>To solve it, the only way is to change WorldGridExtent and adjust SPH parameters to adapt with new extent. This is a torturous thing, so after I obtained a seemingly acceptable result in the small extent, I did not adjust the parameters in the large extent. Now, it seems like an unavoidable task.</p><p>If only want to validate the camera problem, we can leave the quality of visual effect behind. Practice shows that the assumption is right. Make WorldGridExtent larger, then particles move in a larger space, then camera can capture them effectively.</p><figure style="width: 716px" class="align-center"><img src="/images/ue5_niagara_sph/have_to_make_niagara_system_large.png"><figcaption align = "center">Fig: Have to make WorldGridExtent Large</figcaption></figure><p>New parameter:</p><table><thead><tr><th style="text-align:center">Module</th><th style="text-align:center">Parameter Name</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td style="text-align:center">Set (SYSTEM) WorldGridExtent</td><td style="text-align:center">WorldGridExtent</td><td style="text-align:center">(200,200,200)</td></tr><tr><td style="text-align:center">Emitter Spawn</td><td style="text-align:center">RestDensity</td><td style="text-align:center">-50</td></tr><tr><td style="text-align:center">Emitter Spawn</td><td style="text-align:center">PointMass</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">Emitter Spawn</td><td style="text-align:center">GasConstantK</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">Emitter Spawn</td><td style="text-align:center">Viscosity</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center">Advent</td><td style="text-align:center">MaxAccel</td><td style="text-align:center">200</td></tr><tr><td style="text-align:center">Advent</td><td style="text-align:center">MaxVelocity</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">Advent</td><td style="text-align:center">WallDamping</td><td style="text-align:center">-0.8</td></tr></tbody></table><p>After this parameter adjustment, I found a way to quickly obtain the appropriate parameters: first increase the pressure, such as increasing the gas parameters, and then increase the viscosity. Finally, you will get an effect that looks a bit like a fluid. Although this cannot avoid the so-called jelly water, at least you must first be able to obtain a stable effect before you can start optimizing it.</p><h3 id="Problem-Move-Niagara-System-but-particles-are-blocked-at-border">Problem: Move Niagara System but particles are blocked at border</h3><figure style="width: 221px" class="align-center"><img src="/images/ue5_niagara_sph/sph_blocked_at_border.gif"><figcaption align = "center">Fig: Move Niagara System but particles are blocked at border</figcaption></figure><h3 id="Solution-10">Solution</h3><p>Enable <code>Local Space</code> in Emitter property, then all particles’ position are calcuated in local space. In other word, the particles’ coordinate follows actor but not world coordinate.</p><h2 id="New-An-Emitter-to-Emit-Plane-for-rendering">New An Emitter to Emit Plane for rendering</h2><p>You should create a plane to show the rendering result. It can be created in Niagara System or in world level. The former looks nice because it hides details into Niagara System itself.</p><p>To do this, new an emitter to emit a plane sprite. The sprite lifetime should be long enough, so it can be set as <code>LoopDuration</code></p><figure style="width: 368px" class="align-center"><img src="/images/ue5_niagara_sph/lifetime_is_loop_duration.png"><figcaption align = "center">Fig: Lifetime is LoopDuration</figcaption></figure><p>The plane sprite should be located between camera and Niagara System, and should be large enough to cover the whold Niagara System.</p><figure style="width: 354px" class="align-center"><img src="/images/ue5_niagara_sph/calc_plane_pos.png"><figcaption align = "center">Fig: Calculated Plane Position</figcaption></figure><figure style="width: 254px" class="align-center"><img src="/images/ue5_niagara_sph/large_scale_of_plane.png"><figcaption align = "center">Fig: Large scale of Plane</figcaption></figure><p>There is room to decide specific distance from camera to plane. Here I choose 100.</p><figure style="width: 1132px" class="align-center"><img src="/images/ue5_niagara_sph/distance_100.png"><figcaption align = "center">Fig: Distance is 100</figcaption></figure><h3 id="Overview-2">Overview</h3><figure style="width: 793px" class="align-center"><img src="/images/ue5_niagara_sph/overview_5.png"><figcaption align = "center">Fig: Overview 5</figcaption></figure><h3 id="Problem-Emitter-turns-into-balck-in-the-Niagara-System-Overview-and-Sprite-doesn’t-show-up">Problem: Emitter turns into balck in the Niagara System Overview and Sprite doesn’t show up</h3><p>Sometimes, my plane emitter turns into balck in the Niagara System Overview and plane sprite doesn’t show up.</p><figure style="width: 212px" class="align-center"><img src="/images/ue5_niagara_sph/emitter_turns_balck.png"><figcaption align = "center">Fig: turns into balck in the Niagara System Overview and Sprite doesn't show up</figcaption></figure><h3 id="Solution-11">Solution</h3><p>It may be UE bug, restart UE project will solve the problem.</p><h2 id="Create-Fluid-Material">Create Fluid Material</h2><p>Next you should add a material to your plane.</p><figure style="width: 351px" class="align-center"><img src="/images/ue5_niagara_sph/set_material_to_plane.png"><figcaption align = "center">Fig: Set Material to Plane</figcaption></figure><p>This material should have a <code>TextureSampleParameter2D</code> paramter, to get Render Target.</p><p>Create an instance of the material, then you can assign Render Target to the instance parameter.</p><figure style="width: 426px" class="align-center"><img src="/images/ue5_niagara_sph/assign_render_target_to_texture_input.png"><figcaption align = "center">Fig: Assgin Render Target to Texture Input</figcaption></figure><h3 id="Get-Normal-from-Depth-Map">Get Normal from Depth Map</h3><p>There is method to get normal from depth map, but I haven’t pay time to understand it.</p><p><a href="https://developer.download.nvidia.com/presentations/2010/gdc/Direct3D_Effects.pdf">Screen Space Fluid Rendering for Games - Nvidia</a></p><p>Unreal has built-in <code>Normal From Height Map</code> block, but it only receives <code>Texture 2D</code> object. So I copy the content from it and replace the <code>Texture 2D</code> part with <code>Input</code> parameter.</p><figure style="width: 639px" class="align-center"><img src="/images/ue5_niagara_sph/built_in_normal_from_height_map.png"><figcaption align = "center">Fig: Built-in Normal From Height Map Block</figcaption></figure><p align="center"><iframe src="https://blueprintue.com/render/y2jbegzh/" height="600" width="900" scrolling="no" allowfullscreen></iframe></p><p>Becuase I store depth to RGB of Render Target, so when you take depth from Render Target, you should choose the same channel.</p><h3 id="Get-Opacity-Mask-from-Depth-Map">Get Opacity Mask from Depth Map</h3><p>To mask space without fluid, sample from Render Target and link it directly to Opacity Mask.</p><p align="center"><iframe src="https://blueprintue.com/render/_aluyoo5/" height="600" width="900" scrolling="no" allowfullscreen></iframe></p><p>But if you want other objects to cover fluid, you should compare <code>SceneDepthWithoutWater</code> with fluid depth. If <code>SceneDepthWithoutWater</code> is smaller than fluid depth, then other objects can cover fluid.</p><h3 id="Single-Layer-Water-Material">Single Layer Water Material</h3><p>To use <code>SceneDepthWithoutWater</code> block, you should set your <code>Shading Model</code> to <code>Single Layer Water</code>.</p><figure style="width: 320px" class="align-center"><img src="/images/ue5_niagara_sph/switch_to_single_layer_water.png"><figcaption align = "center">Fig: Switch to Single Layer Water</figcaption></figure><p>To compile the material, you should have <code>Single Layer Water Material</code> block.</p><figure style="width: 778px" class="align-center"><img src="/images/ue5_niagara_sph/single_layer_water_material.png"><figcaption align = "center">Fig: Single Layer Water Material</figcaption></figure><h4 id="Problem-ScatteringCoefficients-Node-Link-in-Single-Layer-Water-Material-breaks-alpha-blending">Problem: ScatteringCoefficients Node Link in Single Layer Water Material breaks alpha blending</h4><p>I have fed an occlusion-tested depth into the alpha. The specific method of the occlusion test is, water depth is compared with <code>Single Layer Water Material</code> block, output depth is <code>0  * water depth = 0</code> when water is covered by other objects, <code>1 * water depth = water depth</code> when nothing to block.</p><p>If I link a input value into <code>ScatteringCoefficients</code> node in <code>Single Layer Water Material</code> block, then alpha blending will be break.</p><figure style="width: 528px" class="align-center"><img src="/images/ue5_niagara_sph/break_alpha_blending.png"><figcaption align = "center">Fig: ScatteringCoefficients Node Link in Single Layer Water Material breaks alpha blending</figcaption></figure><p>If I break <code>ScatteringCoefficients</code> node link, then alpha blending will be correct.</p><figure style="width: 497px" class="align-center"><img src="/images/ue5_niagara_sph/correct_alpha_blending.png"><figcaption align = "center">Fig: Correct alpha blending</figcaption></figure><p>I have post a thread in UE forum waiting the answer.</p><p><a href="https://forums.unrealengine.com/t/scatteringcoefficients-node-link-in-single-layer-water-material-breaks-alpha-blending/1586830">ScatteringCoefficients Node Link in Single Layer Water Material breaks alpha blending</a></p><h4 id="Solution-12">Solution(?)</h4><p>Don’t use <code>ScatteringCoefficients</code> node.</p><h4 id="Problem-Water-border-shows-up-ignoring-occlusion">Problem: Water border shows up ignoring occlusion</h4><p>In the image above, you will see water border shows up ignoring occlusion，it is because depth map in Render Target appears weird blur margin.</p><figure style="width: 315px" class="align-center"><img src="/images/ue5_niagara_sph/blur_marigin_of_render_target.png"><figcaption align = "center">Fig: Blur Margin of Render Target</figcaption></figure><p>Current stage I don’t have a solution to deal with this. Maybe a material hack can takes effect.</p><h2 id="Final-Result">Final Result</h2><p>Although it doesn’t look very good, at least it has normals that look reasonable. How to make it look better after that is a matter for the shader.</p><figure style="width: 213px" class="align-center"><img src="/images/ue5_niagara_sph/final_sph_effect.gif"><figcaption align = "center">Fig: Final Result</figcaption></figure><script src="https://utteranc.es/client.js"        repo="CheapMeow/cheapmeow.github.io"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      
        <tags>
            
            <tag> Unreal Engine 5 </tag>
            
            <tag> Niagara System </tag>
            
            <tag> Game Effect </tag>
            
            <tag> Fluid Simulation </tag>
            
            <tag> SPH </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
