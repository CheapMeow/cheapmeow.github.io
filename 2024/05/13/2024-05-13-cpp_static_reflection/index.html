<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="John Doe" />
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  
  
  <title>
    
      C++ 静态反射学习 
      
      
      |
    
     CheapMeow
  </title>

  
    <link rel="apple-touch-icon" href="/images/avatar.png">
    <link rel="icon" href="/images/avatar.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">CheapMeow</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">C++ 静态反射学习</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2025-06-01 10:52:45
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Cpp/" title="Cpp">
                    #Cpp
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Reflection/" title="Reflection">
                    #Reflection
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Template-programming/" title="Template programming">
                    #Template programming
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>比较了 Piccolo, Taichi, ykiko 的静态反射做法</p>
<h2 id="C-静态反射学习">C++静态反射学习</h2>
<h3 id="Piccolo-中的静态反射">Piccolo 中的静态反射</h3>
<h4 id="存储类型信息">存储类型信息</h4>
<p>反射需要存储一些类型信息，Piccolo 用一个 map 存储了类型名对应的工具函数，也就是存储了类型信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">void</span>*, <span class="type">void</span>*)&gt;      SetFuncion;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>*(<span class="type">void</span>*)&gt;            GetFuncion;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">const</span> <span class="type">char</span>*()&gt;           GetNameFuncion;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">void</span>*)&gt; SetArrayFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>*(<span class="type">int</span>, <span class="type">void</span>*)&gt;       GetArrayFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">int</span>(<span class="type">void</span>*)&gt;              GetSizeFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">bool</span>()&gt;                  GetBoolFunc;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">void</span>*)&gt;             InvokeFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>*(<span class="type">const</span> Json&amp;)&gt;                           ConstructorWithJson;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;Json(<span class="type">void</span>*)&gt;                                  WriteJsonByName;</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">int</span>(Reflection::ReflectionInstance*&amp;, <span class="type">void</span>*)&gt; GetBaseClassReflectionInstanceListFunc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;SetFuncion, GetFuncion, GetNameFuncion, GetNameFuncion, GetNameFuncion, GetBoolFunc&gt;</span><br><span class="line">                                                    FieldFunctionTuple;</span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;GetNameFuncion, InvokeFunction&gt; MethodFunctionTuple;</span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;GetBaseClassReflectionInstanceListFunc, ConstructorWithJson, WriteJsonByName&gt; ClassFunctionTuple;</span><br><span class="line"><span class="keyword">typedef</span> std::tuple&lt;SetArrayFunc, GetArrayFunc, GetSizeFunc, GetNameFuncion, GetNameFuncion&gt;      ArrayFunctionTuple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reflection.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::map&lt;std::string, ClassFunctionTuple*&gt;       m_class_map;</span><br><span class="line"><span class="type">static</span> std::multimap&lt;std::string, FieldFunctionTuple*&gt;  m_field_map;</span><br><span class="line"><span class="type">static</span> std::multimap&lt;std::string, MethodFunctionTuple*&gt; m_method_map;</span><br><span class="line"><span class="type">static</span> std::map&lt;std::string, ArrayFunctionTuple*&gt;       m_array_map;</span><br></pre></td></tr></table></figure>
<p>这些工具函数就是用来访问反射实例的。</p>
<p>工具函数是怎么来的？在业务代码的定义里面添加宏定义，之后分析业务代码，生成与需要反射的业务代码中的类型一一对应的反射工具类，其中定义了这些工具函数。</p>
<p>这些生成的反射工具类中包含一组组的工具函数。你需要什么反射功能，你就需要规定生成什么样的工具函数。现在已经写得明确了，就是四组工具函数，<code>FieldFunctionTuple</code> 用来访问字段；<code>MethodFunctionTuple</code> 用来访问方法；<code>ClassFunctionTuple</code> 用来获取基类列表、从 json 反序列化为类的实例、从类的实例序列化为 json；<code>ArrayFunctionTuple</code> 用来访问数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector2.reflection.gen.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Piccolo&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Vector2</span>;</span><br><span class="line"><span class="keyword">namespace</span> Reflection&#123;</span><br><span class="line"><span class="keyword">namespace</span> TypeFieldReflectionOparator&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TypeVector2Operator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getClassName</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;Vector2&quot;</span>;&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">constructorWithJson</span><span class="params">(<span class="type">const</span> Json&amp; json_context)</span></span>&#123;</span><br><span class="line">            Vector2* ret_instance= <span class="keyword">new</span> Vector2;</span><br><span class="line">            Serializer::<span class="built_in">read</span>(json_context, *ret_instance);</span><br><span class="line">            <span class="keyword">return</span> ret_instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> Json <span class="title">writeByName</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Serializer::<span class="built_in">write</span>(*(Vector2*)instance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// base class</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getVector2BaseClassReflectionInstanceList</span><span class="params">(ReflectionInstance* &amp;out_list, <span class="type">void</span>* instance)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fields</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldName_x</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;x&quot;</span>;&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldTypeName_x</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;float&quot;</span>;&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_x</span><span class="params">(<span class="type">void</span>* instance, <span class="type">void</span>* field_value)</span></span>&#123; <span class="built_in">static_cast</span>&lt;Vector2*&gt;(instance)-&gt;x = *<span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(field_value);&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">get_x</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;(<span class="built_in">static_cast</span>&lt;Vector2*&gt;(instance)-&gt;x));&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isArray_x</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldName_y</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;y&quot;</span>;&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">getFieldTypeName_y</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;float&quot;</span>;&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_y</span><span class="params">(<span class="type">void</span>* instance, <span class="type">void</span>* field_value)</span></span>&#123; <span class="built_in">static_cast</span>&lt;Vector2*&gt;(instance)-&gt;y = *<span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(field_value);&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">get_y</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;(<span class="built_in">static_cast</span>&lt;Vector2*&gt;(instance)-&gt;y));&#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isArray_y</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// methods</span></span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;<span class="comment">//namespace TypeFieldReflectionOparator</span></span><br></pre></td></tr></table></figure>
<p>他这里为了不污染业务代码，把反射生成的工具函数和工具类都放在了一个独立的命名空间里面。每一组工具函数也是处于不同的命名空间里面，看上去更清晰，这里只是展示了字段的工具函数，位于 <code>TypeFieldReflectionOparator</code>，如果原始类型需要反射数组，相关的工具函数就会放在另外的命名空间 <code>ArrayReflectionOperator</code> 中</p>
<p>工具函数这里可以看到，输入的 instance 是 <code>void*</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector2.reflection.gen.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">get_x</span><span class="params">(<span class="type">void</span>* instance)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;(<span class="built_in">static_cast</span>&lt;Vector2*&gt;(instance)-&gt;x));&#125;</span><br></pre></td></tr></table></figure>
<p>这其实隐含着一个约定是，反射实例的数据都用 <code>void*</code> 表示。<code>void*</code> 很常用，因为使用指针可以避免数据拷贝，使用 <code>void</code> 是方便 cast。</p>
<p>如果之后和别的反射框架对照，可以发现，你为了统一处理反射逻辑，肯定会把需要反射的东西装箱成一个中间类，或者说，类型擦除</p>
<p>这个中间类你用 <code>std::any</code> 存指针或者 <code>void*</code> 或者自己定义一个类似 <code>std::any</code> 的东西都可以</p>
<p>最终反正都是调用 <code>static_cast</code> 把擦除之后的类转换成自定义类型，然后访问自定义类型中的成员，然后再把访问结果用 <code>static_cast</code> 类型擦除</p>
<p>它这里为了把表示数据的 <code>void*</code> 和表示类型的 <code>string</code> 绑在一起，就创建了 <code>ReflectionInstance</code> <code>ReflectionPtr</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectionInstance</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TypeMeta m_meta;</span><br><span class="line">    <span class="type">void</span>*    m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectionPtr</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_type_name &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">typedef</span> T   m_type;</span><br><span class="line">    T*          m_instance &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>业务代码的反射宏定义中已经把这些反射工具类前向声明为了友元，所以这些反射工具类里面的工具函数是有权限访问到原始类型的成员的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflection.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFLECTION_BODY(class_name) \</span></span><br><span class="line"><span class="meta">    friend class Reflection::TypeFieldReflectionOparator::Type##class_name##Operator; \</span></span><br><span class="line"><span class="meta">    friend class Serializer;</span></span><br><span class="line">    <span class="comment">// public: virtual std::string getTypeName() override &#123;return #class_name;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFLECTION_TYPE(class_name) \</span></span><br><span class="line"><span class="meta">    namespace Reflection \</span></span><br><span class="line"><span class="meta">    &#123; \</span></span><br><span class="line"><span class="meta">        namespace TypeFieldReflectionOparator \</span></span><br><span class="line"><span class="meta">        &#123; \</span></span><br><span class="line"><span class="meta">            class Type##class_name##Operator; \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vector2.h</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">REFLECTION_TYPE</span>(Vector2)</span><br><span class="line"><span class="built_in">CLASS</span>(Vector2, Fields)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">REFLECTION_BODY</span>(Vector2);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这只是生成了代码，找了一个位置定义了工具函数，如果我们需要从任意一个位置通过类型名字获取工具函数，我们还需要把这些工具函数统一存储在一个地方，方便查找。</p>
<p>生成的反射工具类中有一个函数，收集四组工具函数，每一组打包成一个 <code>std::tuple</code>，加入全局反射单例的 map</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// animation_clip.reflection.gen.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TypeWrapperRegister_AnimNodeMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FieldFunctionTuple* field_function_tuple_convert=<span class="keyword">new</span> <span class="built_in">FieldFunctionTuple</span>(</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::set_convert,</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::get_convert,</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::getClassName,</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::getFieldName_convert,</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::getFieldTypeName_convert,</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::isArray_convert);</span><br><span class="line">    <span class="built_in">REGISTER_FIELD_TO_MAP</span>(<span class="string">&quot;AnimNodeMap&quot;</span>, field_function_tuple_convert);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ArrayFunctionTuple* array_tuple_stdSSvectorLstdSSstringR = <span class="keyword">new</span>  <span class="built_in">ArrayFunctionTuple</span>(</span><br><span class="line">        &amp;ArrayReflectionOperator::ArraystdSSvectorLstdSSstringROperator::set,</span><br><span class="line">        &amp;ArrayReflectionOperator::ArraystdSSvectorLstdSSstringROperator::get,</span><br><span class="line">        &amp;ArrayReflectionOperator::ArraystdSSvectorLstdSSstringROperator::getSize,</span><br><span class="line">        &amp;ArrayReflectionOperator::ArraystdSSvectorLstdSSstringROperator::getArrayTypeName,</span><br><span class="line">        &amp;ArrayReflectionOperator::ArraystdSSvectorLstdSSstringROperator::getElementTypeName);</span><br><span class="line">    <span class="built_in">REGISTER_ARRAY_TO_MAP</span>(<span class="string">&quot;std::vector&lt;std::string&gt;&quot;</span>, array_tuple_stdSSvectorLstdSSstringR);</span><br><span class="line">    ClassFunctionTuple* class_function_tuple_AnimNodeMap=<span class="keyword">new</span> <span class="built_in">ClassFunctionTuple</span>(</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::getAnimNodeMapBaseClassReflectionInstanceList,</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::constructorWithJson,</span><br><span class="line">        &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::writeByName);</span><br><span class="line">    <span class="built_in">REGISTER_BASE_CLASS_TO_MAP</span>(<span class="string">&quot;AnimNodeMap&quot;</span>, class_function_tuple_AnimNodeMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他这个解析代码的程序生成反射代码文件与源码中的头文件一一对应，源码里面一个头文件可以定义多个需要反射的类，这个程序都可以处理</p>
<p>这种情况下，一个反射工具类对应一个用于收集工具函数，创建 tuple 的函数 <code>TypeWrapperRegister_ClassName</code>。一个文件里面最终还需要一个注册函数 <code>TypeWrappersRegister::ClassName</code>，里面调用所有的 <code>TypeWrapperRegister_ClassName</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> TypeWrappersRegister&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AnimationClip</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">TypeWrapperRegister_AnimNodeMap</span>();</span><br><span class="line">        <span class="built_in">TypeWrapperRegister_AnimationChannel</span>();</span><br><span class="line">        <span class="built_in">TypeWrapperRegister_AnimationClip</span>();</span><br><span class="line">        <span class="built_in">TypeWrapperRegister_AnimationAsset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//namespace TypeWrappersRegister</span></span><br></pre></td></tr></table></figure>
<p>代码生成程序除了一个需要反射的头文件对应一个反射代码文件之外，还会生成一个专门用于注册类型信息的文件，里面调用了所有的注册函数 <code>TypeWrappersRegister::ClassName</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Reflection&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TypeMetaRegister::metaRegister</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">BlendState</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Quaternion</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">AxisAligned</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">TransformComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">ParticleComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Vector3</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Transform</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Color</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Vector4</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Vector2</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Object</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Matrix4</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">MetaExample</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">World</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">AnimationClip</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">AnimationSkeletonNodeMap</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">SkeletonData</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">SkeletonMask</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Animation</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">AnimationComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Camera</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Component</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Material</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">CameraComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">BasicShape</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">RigidBody</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">LuaComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Mesh</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">RenderObject</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">MeshComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Motor</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">MotorComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">GlobalRendering</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Emitter</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">RigidbodyComponent</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">GlobalParticle</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">MeshData</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">CameraConfig</span>();</span><br><span class="line">        TypeWrappersRegister::<span class="built_in">Level</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个总的注册函数 <code>TypeMetaRegister::metaRegister</code> 在游戏引擎启动的时候被调用，这样就完成了类型信息的存储</p>
<h4 id="使用反射创建-GUI-树">使用反射创建 GUI 树</h4>
<p>给定一个反射实例，需要知道他的父类有多少个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// editor_ui.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorUI::createClassUI</span><span class="params">(Reflection::ReflectionInstance&amp; instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Reflection::ReflectionInstance* reflection_instance;</span><br><span class="line">    <span class="type">int</span> count = instance.m_meta.<span class="built_in">getBaseClassReflectionInstanceList</span>(reflection_instance, instance.m_instance);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; count; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">createClassUI</span>(reflection_instance[index]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">createLeafNodeUI</span>(instance);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">delete</span>[] reflection_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他这里是认为 GUI 树的布局跟继承树是一样的</p>
<p>创建某一个节点的 GUI 是大量使用反射的地方。对一个反射实例，获取他所有的字段，如果字段是数组，那么就要遍历这个数组的所有成员，每一个成员又要创建一个反射实例，继续调用 <code>createClassUI</code>；如果不是，那么用这个字段创建反射实例，继续调用 <code>createClassUI</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// editor_ui.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorUI::createLeafNodeUI</span><span class="params">(Reflection::ReflectionInstance&amp; instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Reflection::FieldAccessor* fields;</span><br><span class="line">    <span class="type">int</span>                        fields_count = instance.m_meta.<span class="built_in">getFieldsList</span>(fields);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> index = <span class="number">0</span>; index &lt; fields_count; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> field = fields[index];</span><br><span class="line">        <span class="keyword">if</span> (field.<span class="built_in">isArrayType</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            Reflection::ArrayAccessor array_accessor;</span><br><span class="line">            <span class="keyword">if</span> (Reflection::TypeMeta::<span class="built_in">newArrayAccessorFromName</span>(field.<span class="built_in">getFieldTypeName</span>(), array_accessor))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">void</span>* field_instance = field.<span class="built_in">get</span>(instance.m_instance);</span><br><span class="line">                <span class="type">int</span>   array_count    = array_accessor.<span class="built_in">getSize</span>(field_instance);</span><br><span class="line">                m_editor_ui_creator[<span class="string">&quot;TreeNodePush&quot;</span>](</span><br><span class="line">                    std::<span class="built_in">string</span>(field.<span class="built_in">getFieldName</span>()) + <span class="string">&quot;[&quot;</span> + std::<span class="built_in">to_string</span>(array_count) + <span class="string">&quot;]&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">auto</span> item_type_meta_item =</span><br><span class="line">                    Reflection::TypeMeta::<span class="built_in">newMetaFromName</span>(array_accessor.<span class="built_in">getElementTypeName</span>());</span><br><span class="line">                <span class="keyword">auto</span> item_ui_creator_iterator = m_editor_ui_creator.<span class="built_in">find</span>(item_type_meta_item.<span class="built_in">getTypeName</span>());</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; array_count; index++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (item_ui_creator_iterator == m_editor_ui_creator.<span class="built_in">end</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        m_editor_ui_creator[<span class="string">&quot;TreeNodePush&quot;</span>](<span class="string">&quot;[&quot;</span> + std::<span class="built_in">to_string</span>(index) + <span class="string">&quot;]&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">                        <span class="keyword">auto</span> object_instance = Reflection::<span class="built_in">ReflectionInstance</span>(</span><br><span class="line">                            Piccolo::Reflection::TypeMeta::<span class="built_in">newMetaFromName</span>(item_type_meta_item.<span class="built_in">getTypeName</span>().<span class="built_in">c_str</span>()),</span><br><span class="line">                            array_accessor.<span class="built_in">get</span>(index, field_instance));</span><br><span class="line">                        <span class="built_in">createClassUI</span>(object_instance);</span><br><span class="line">                        m_editor_ui_creator[<span class="string">&quot;TreeNodePop&quot;</span>](<span class="string">&quot;[&quot;</span> + std::<span class="built_in">to_string</span>(index) + <span class="string">&quot;]&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (item_ui_creator_iterator == m_editor_ui_creator.<span class="built_in">end</span>())</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        m_editor_ui_creator[item_type_meta_item.<span class="built_in">getTypeName</span>()](</span><br><span class="line">                            <span class="string">&quot;[&quot;</span> + std::<span class="built_in">to_string</span>(index) + <span class="string">&quot;]&quot;</span>, array_accessor.<span class="built_in">get</span>(index, field_instance));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                m_editor_ui_creator[<span class="string">&quot;TreeNodePop&quot;</span>](field.<span class="built_in">getFieldName</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> ui_creator_iterator = m_editor_ui_creator.<span class="built_in">find</span>(field.<span class="built_in">getFieldTypeName</span>());</span><br><span class="line">        <span class="keyword">if</span> (ui_creator_iterator == m_editor_ui_creator.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            Reflection::TypeMeta field_meta =</span><br><span class="line">                Reflection::TypeMeta::<span class="built_in">newMetaFromName</span>(field.<span class="built_in">getFieldTypeName</span>());</span><br><span class="line">            <span class="keyword">if</span> (field.<span class="built_in">getTypeMeta</span>(field_meta))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> child_instance =</span><br><span class="line">                    Reflection::<span class="built_in">ReflectionInstance</span>(field_meta, field.<span class="built_in">get</span>(instance.m_instance));</span><br><span class="line">                m_editor_ui_creator[<span class="string">&quot;TreeNodePush&quot;</span>](field_meta.<span class="built_in">getTypeName</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">                <span class="built_in">createClassUI</span>(child_instance);</span><br><span class="line">                m_editor_ui_creator[<span class="string">&quot;TreeNodePop&quot;</span>](field_meta.<span class="built_in">getTypeName</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ui_creator_iterator == m_editor_ui_creator.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                m_editor_ui_creator[field.<span class="built_in">getFieldTypeName</span>()](field.<span class="built_in">getFieldName</span>(),</span><br><span class="line">                                                                        field.<span class="built_in">get</span>(instance.m_instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_editor_ui_creator[field.<span class="built_in">getFieldTypeName</span>()](field.<span class="built_in">getFieldName</span>(),</span><br><span class="line">                                                                    field.<span class="built_in">get</span>(instance.m_instance));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] fields;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，为什么全局反射静态实例里面的 map 的 key 是类型名，<code>FieldFunctionTuple</code> 里面还要放一个获取类型名的函数。因为反射的时候我们并不是直接使用这个 map，而是先去获得字段的名字，然后再根据字段的名字从这个 map 中取东西。</p>
<p>其中 <code>m_editor_ui_creator</code> 用来存放 Imgui 创建 GUI 的函数。它不仅包含 <code>TreeNodePush</code> 这种 Imgui 自带的函数，更重要的的是包含了引擎里面基本类型的处理，这也是递归创建 GUI 的终止的地方</p>
<p>指向数据的指针会传入 <code>m_editor_ui_creator</code>，这就完成了 Imgui 对数据的控制</p>
<p>指向数据的指针是使用反射，遍历某个反射类的所有字段取到的，这就完成了 Imgui 能获取并控制所有被反射的字段</p>
<p>显示 GUI 的起点是，指定的物体的 components</p>
<p>从它们开始包装反射实例 <code>Reflection::ReflectionInstance</code> 专门是为了配合</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// editor_ui.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp;                 selected_object_components = selected_object-&gt;<span class="built_in">getComponents</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> component_ptr : selected_object_components)</span><br><span class="line">&#123;</span><br><span class="line">    m_editor_ui_creator[<span class="string">&quot;TreeNodePush&quot;</span>]((<span class="string">&quot;&lt;&quot;</span> + component_ptr.<span class="built_in">getTypeName</span>() + <span class="string">&quot;&gt;&quot;</span>).<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">auto</span> object_instance = Reflection::<span class="built_in">ReflectionInstance</span>(</span><br><span class="line">        Piccolo::Reflection::TypeMeta::<span class="built_in">newMetaFromName</span>(component_ptr.<span class="built_in">getTypeName</span>().<span class="built_in">c_str</span>()),</span><br><span class="line">        component_ptr.<span class="keyword">operator</span>-&gt;());</span><br><span class="line">    <span class="built_in">createClassUI</span>(object_instance);</span><br><span class="line">    m_editor_ui_creator[<span class="string">&quot;TreeNodePop&quot;</span>]((<span class="string">&quot;&lt;&quot;</span> + component_ptr.<span class="built_in">getTypeName</span>() + <span class="string">&quot;&gt;&quot;</span>).<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="序列化与反序列化">序列化与反序列化</h4>
<p>序列化开始的时候，我们是知道我们要序列化或者反序列化某个类的，最终反序列化都是通过资产管理器的接口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// asset_manager.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AssetManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> AssetType&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">loadAsset</span><span class="params">(<span class="type">const</span> std::string&amp; asset_url, AssetType&amp; out_asset)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// read json file to string</span></span><br><span class="line">        std::filesystem::path asset_path = <span class="built_in">getFullPath</span>(asset_url);</span><br><span class="line">        <span class="function">std::ifstream <span class="title">asset_json_file</span><span class="params">(asset_path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!asset_json_file)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;open file: &#123;&#125; failed!&quot;</span>, asset_path.<span class="built_in">generic_string</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::stringstream buffer;</span><br><span class="line">        buffer &lt;&lt; asset_json_file.<span class="built_in">rdbuf</span>();</span><br><span class="line">        <span class="function">std::string <span class="title">asset_json_text</span><span class="params">(buffer.str())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// parse to json object and read to runtime res object</span></span><br><span class="line">        std::string error;</span><br><span class="line">        <span class="keyword">auto</span>&amp;&amp;      asset_json = Json::<span class="built_in">parse</span>(asset_json_text, error);</span><br><span class="line">        <span class="keyword">if</span> (!error.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;parse json file &#123;&#125; failed!&quot;</span>, asset_url);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Serializer::<span class="built_in">read</span>(asset_json, out_asset);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里最终会调用 <code>Serializer::read</code>。它是一个模板函数，有重载有特化。</p>
<p>如果是派生的自定义子类反序列化，那么会调用代码生成的，模板特化版本的 <code>Serializer::read</code>。</p>
<p>递归调用下去，遇到 object 类这种类的话，会比较特殊</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object.h</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">REFLECTION_TYPE</span>(ObjectDefinitionRes)</span><br><span class="line"><span class="built_in">CLASS</span>(ObjectDefinitionRes, Fields)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">REFLECTION_BODY</span>(ObjectDefinitionRes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;Reflection::ReflectionPtr&lt;Component&gt;&gt; m_components;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它里面含有的 <code>Reflection::ReflectionPtr&lt;Component&gt;</code> 这个类型的反序列化不是代码生成的，这是手写的</p>
<p>就，这里会有一些比较绕的事情发生。总的序列化流程我们已经知道了，自定义类型 <code>A</code> 的反序列化函数 <code>Serializer::read</code> 由代码生成，生成的内容就是对 <code>A</code> 的每一个成员继续调用 <code>Serializer::read</code></p>
<p>如果 <code>A</code> 的成员都是基本类型，那么就会跳到预先写好的特化到基本类型的 <code>Serializer::read</code>；如果 <code>A</code> 的成员也有自定义类型 <code>B</code> <code>C</code>，那么就会跳到代码生成的，特化到 <code>B</code> <code>C</code> 的 <code>Serializer::read</code></p>
<p>自定义类型中有一些特殊的是 <code>Reflection::ReflectionPtr&lt;T&gt;</code> 这个类型，你要反序列化生成的是自定义类型的指针，单纯是特化到自定义类型的 <code>Serializer::read</code> 还不够用，还需要多写一个实例化，然后获取指针的这个步骤</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serializer.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> T*&amp; <span class="title">readPointer</span><span class="params">(<span class="type">const</span> Json&amp; json_context, T*&amp; instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(instance == <span class="literal">nullptr</span>);</span><br><span class="line">    std::string type_name = json_context[<span class="string">&quot;$typeName&quot;</span>].<span class="built_in">string_value</span>();</span><br><span class="line">    <span class="built_in">assert</span>(!type_name.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;*&#x27;</span> == type_name[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> T;</span><br><span class="line">        <span class="built_in">read</span>(json_context[<span class="string">&quot;$context&quot;</span>], *instance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        instance = <span class="built_in">static_cast</span>&lt;T*&gt;(</span><br><span class="line">            Reflection::TypeMeta::<span class="built_in">newFromNameAndJson</span>(type_name, json_context[<span class="string">&quot;$context&quot;</span>]).m_instance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> T*&amp; <span class="title">read</span><span class="params">(<span class="type">const</span> Json&amp; json_context, Reflection::ReflectionPtr&lt;T&gt;&amp; instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string type_name = json_context[<span class="string">&quot;$typeName&quot;</span>].<span class="built_in">string_value</span>();</span><br><span class="line">    instance.<span class="built_in">setTypeName</span>(type_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">readPointer</span>(json_context, instance.<span class="built_in">getPtrReference</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Reflection::ReflectionPtr&lt;T&gt;</code> 这里存储的是基类 <code>T</code> 的指针，用来实现多态。比如一个 gameobject 可能拥有很多不同的 component，但是它们都继承自 component 基类。</p>
<p>但是我们要生成的是派生类实例，派生类的实例化，可想而知，也是需要读取 json 的。然而读取特定类型的 json 我们是依赖于明确地传入一个自定义类型，才能调用到特化版本的 <code>Serializer::read</code></p>
<p>而现在我们处理 <code>Reflection::ReflectionPtr</code> 的时候我们只知道是基类类型 <code>T</code>，那就没办法调用到特化版本的 <code>Serializer::read</code> 了</p>
<p>所以为了处理 <code>Reflection::ReflectionPtr</code> 能够调用到特化版本的 <code>Serializer::read</code>，需要代码里面某处明确写明了派生类的类型，然后把这个派生类的类型的参数传给 <code>Serializer::read</code> 就能调用到特化版本。这个东西写完，或者说这个函数写完之后，处理 <code>Reflection::ReflectionPtr</code> 的时候还需要找得到</p>
<p>这就再次用到了反射。<code>Reflection::ReflectionPtr</code> 里面存储派生类的类名，我们根据这个类名通过反射获取到反序列化函数 <code>Reflection::TypeMeta::newFromNameAndJson</code>，它里面就是特意调用派生类特化版本的 <code>Serializer::read</code></p>
<p><code>readPointer</code> 除了处理 <code>Reflection::ReflectionPtr&lt;T&gt;</code> 还会处理 <code>T*</code>。这是因为它们都是表示指针的意义才写在一起的，实际上，<code>Reflection::ReflectionPtr&lt;T&gt;</code> 也可以算是一个值类型了。</p>
<p>回到我们的总结，反序列化看上去比较绕的就是，对一个类型，递归调用 <code>Serializer::read</code></p>
<ol>
<li>
<p>如果数据成员是基本类型</p>
<p>调用特化到基本类型的 <code>Serializer::read</code></p>
</li>
<li>
<p>如果数据成员是自定义类型 <code>T</code></p>
<p>调用生成的，特化到 <code>T</code> 的 <code>Serializer::read</code></p>
</li>
<li>
<p>如果数据成员是某个类型的指针 <code>T*</code></p>
<p>先 <code>new T</code> 再调用特化到 <code>T</code> 的 <code>Serializer::read</code></p>
</li>
<li>
<p>如果数据成员是 <code>Reflection::ReflectionPtr&lt;T&gt;</code></p>
<p>从 <code>Reflection::ReflectionPtr</code> 拿到派生类类型信息，根据这个类型信息拿到对应派生类的 <code>Reflection::TypeMeta::newFromNameAndJson</code>，其中调用生成的，特化到自定义类型的，并且这个自定义类型是继承自 <code>T</code> 的 <code>Serializer::read</code></p>
</li>
</ol>
<p>就是这样，不断递归，最终跳到基本类型就结束了</p>
<p>序列化也是同理，递归调用 <code>Serializer::write</code></p>
<ol>
<li>
<p>如果数据成员是基本类型</p>
<p>调用特化到基本类型的 <code>Serializer::write</code></p>
</li>
<li>
<p>如果数据成员是自定义类型 <code>T</code></p>
<p>调用生成的，特化到 <code>T</code> 的 <code>Serializer::write</code></p>
</li>
<li>
<p>如果数据成员是某个类型的指针 <code>T*</code></p>
<p><code>$typeName</code> 填 <code>*</code>，然后调用特化到 <code>T</code> 的 <code>Serializer::write</code></p>
</li>
<li>
<p>如果数据成员是 <code>Reflection::ReflectionPtr&lt;T&gt;</code></p>
<p>从 <code>Reflection::ReflectionPtr</code> 拿到派生类类型信息，根据这个类型信息拿到对应派生类的 <code>Reflection::TypeMeta::writeByName</code>，其中调用生成的，特化到自定义类型的，并且这个自定义类型是继承自 <code>T</code> 的 <code>Serializer::write</code></p>
</li>
</ol>
<p>因为 cpp 提供了最基础的静态反射，可以知道一个类型是不是指针，所以 <code>writePointer</code> 这里就单单明确是用于 <code>T*</code> 的，而不是像 <code>readPointer</code> 那样，除了处理 <code>Reflection::ReflectionPtr&lt;T&gt;</code> 还会处理 <code>T*</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> Json <span class="title">writePointer</span><span class="params">(T* instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Json::object &#123; &#123;<span class="string">&quot;$typeName&quot;</span>, Json &#123;<span class="string">&quot;*&quot;</span>&#125;&#125;, &#123;<span class="string">&quot;$context&quot;</span>, Serializer::<span class="built_in">write</span>(*instance)&#125; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> Json <span class="title">write</span><span class="params">(<span class="type">const</span> Reflection::ReflectionPtr&lt;T&gt;&amp; instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T*          instance_ptr = <span class="built_in">static_cast</span>&lt;T*&gt;(instance.<span class="keyword">operator</span>-&gt;());</span><br><span class="line">    std::string type_name    = instance.<span class="built_in">getTypeName</span>();</span><br><span class="line">    <span class="keyword">return</span> Json::object &#123; &#123;<span class="string">&quot;$typeName&quot;</span>, <span class="built_in">Json</span>(type_name)&#125;,</span><br><span class="line">                            &#123;<span class="string">&quot;$context&quot;</span>, Reflection::TypeMeta::<span class="built_in">writeByName</span>(type_name, instance_ptr)&#125; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> Json <span class="title">write</span><span class="params">(<span class="type">const</span> T&amp; instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_pointer&lt;T&gt;::value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">writePointer</span>((T)instance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">static_assert</span>(always_false&lt;T&gt;, <span class="string">&quot;Serializer::write&lt;T&gt; has not been implemented yet!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Json</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么说呢……这个不对称看上去令人强迫症犯了……</p>
<h4 id="ReflectionPtr-和-ReflectionInstance-用于类型擦除">ReflectionPtr 和 ReflectionInstance 用于类型擦除</h4>
<p>一些反射教程中没有这两个东西</p>
<p>他们的示例在做反射的时候，会传入原本被反射的类型，例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="type">foo_t</span> = reflect::<span class="built_in">GetByName</span>(<span class="string">&quot;Foo&quot;</span>);</span><br><span class="line">Foo f;</span><br><span class="line"><span class="comment">// Test member variables</span></span><br><span class="line"><span class="keyword">auto</span> name_var = <span class="type">foo_t</span>.<span class="built_in">GetMemberVar</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">name_var.<span class="built_in">SetValue</span>(f, std::string &#123;<span class="string">&quot;taichi&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>问题来了，如果我只能这么用的话，那就说明我代码里面已经知道了 <code>Foo f</code>，那我还要这个反射干嘛，我直接对 <code>Foo</code> 操作不就行了</p>
<p>所以需要有一个东西把任意类型的对象的类型都擦了，假设只留下 <code>void*</code> 然后业务逻辑只接受 <code>void*</code> 的数据，在对这些数据进行操作的时候，根据配套传入的 <code>string</code> 静态获得处理这些数据的函数，才对</p>
<p>Piccolo 这里的 <code>ReflectionPtr</code> 和 <code>ReflectionInstance</code> 就是用来做类型擦除的</p>
<p>当然，类型擦除被用在很多地方，这里所说的类型擦除和别的地方的不一样，这里是为了泛化与反射相关的业务逻辑，别的地方比如调用反射出来的函数的时候，内部做参数的转型</p>
<h4 id="ReflectionPtr-和-ReflectionInstance-的设计">ReflectionPtr 和 ReflectionInstance 的设计</h4>
<p>其实我一直在想一件事情，就是 <code>ReflectionPtr</code> 和 <code>ReflectionInstance</code> 这个具体怎么实现类型擦除的设计，真的有必要吗</p>
<p><code>ReflectionInstance</code> 是类型信息 + <code>void*</code> 类型的数据</p>
<p><code>ReflectionPtr</code> 是类型信息 + <code>T*</code> 类型的数据</p>
<p>我感觉它们的功能重合了欸。这样就有点混淆。多余的是 <code>ReflectionInstance</code>，他完全可以用 <code>ReflectionPtr&lt;void&gt;</code> 代替</p>
<p>而且在自定义类型的时候将 <code>ReflectionPtr</code> 和 <code>ReflectionInstance</code> 显式写在定义里面，总感觉有一种侵入式的丑陋</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GObject</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;GObject&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::unordered_set&lt;std::string&gt; TypeNameSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    GObjectID   m_id &#123;k_invalid_gobject_id&#125;;</span><br><span class="line">    std::string m_name;</span><br><span class="line">    std::string m_definition_url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we have to use the ReflectionPtr due to that the components need to be reflected </span></span><br><span class="line">    <span class="comment">// in editor, and it&#x27;s polymorphism</span></span><br><span class="line">    std::vector&lt;Reflection::ReflectionPtr&lt;Component&gt;&gt; m_components;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后还是想通了</p>
<p>他这里说，在 gameobject 里面使用 <code>ReflectionPtr</code> 的意义是，编辑器的 UI 需要反射信息，所以要用一个反射结构来存类型信息，同时我们还需要这个指针是有一个类型 <code>T</code> 的，以便我们在不一定是 UI 而可以是其他地方，使用到 <code>Component</code> 的多态性</p>
<p>再加上基类指针的类型擦除功能，总共三个用途，<code>ReflectionPtr&lt;T&gt;</code> 的设计确实是很有价值的</p>
<p>这里的侵入也是不可避免的。你想要多态，就会擦类型，擦了类型，你就没办法获得派生类的名字，就没法在反射数据库里面找到派生类，所以为了兼得两者，你必须要在存基类指针的时候也存类型信息</p>
<h4 id="ReflectionPtr-内使用智能指针">ReflectionPtr 内使用智能指针</h4>
<p>因为 <code>ReflectionPtr&lt;T&gt;</code> 最初设计的是，内部存一个 <code>T*</code> 指针</p>
<p>所以他没有资源管理的能力，所以 Piccolo 包了一些宏来做</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PICCOLO_REFLECTION_NEW(name, ...) Reflection::ReflectionPtr(#name, new name(__VA_ARGS__));</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICCOLO_REFLECTION_DELETE(value) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (value) \</span></span><br><span class="line"><span class="meta">    &#123; \</span></span><br><span class="line"><span class="meta">        delete value.operator-&gt;(); \</span></span><br><span class="line"><span class="meta">        value.getPtrReference() = nullptr; \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICCOLO_REFLECTION_DEEP_COPY(type, dst_ptr, src_ptr) \</span></span><br><span class="line"><span class="meta">    *static_cast<span class="string">&lt;type*&gt;</span>(dst_ptr) = *static_cast<span class="string">&lt;type*&gt;</span>(src_ptr.getPtr());</span></span><br></pre></td></tr></table></figure>
<p>使用例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// camera.h</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">REFLECTION_TYPE</span>(CameraComponentRes)</span><br><span class="line"><span class="built_in">CLASS</span>(CameraComponentRes, Fields)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">REFLECTION_BODY</span>(CameraComponentRes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Reflection::ReflectionPtr&lt;CameraParameter&gt; m_parameter;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CameraComponentRes</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">CameraComponentRes</span>(<span class="type">const</span> CameraComponentRes&amp; res);</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CameraComponentRes</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// camera.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Piccolo</span><br><span class="line">&#123;</span><br><span class="line">    CameraComponentRes::<span class="built_in">CameraComponentRes</span>(<span class="type">const</span> CameraComponentRes&amp; res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> std::string&amp; camera_type_name = res.m_parameter.<span class="built_in">getTypeName</span>();</span><br><span class="line">        <span class="keyword">if</span> (camera_type_name == <span class="string">&quot;FirstPersonCameraParameter&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_parameter = <span class="built_in">PICCOLO_REFLECTION_NEW</span>(FirstPersonCameraParameter);</span><br><span class="line">            <span class="built_in">PICCOLO_REFLECTION_DEEP_COPY</span>(FirstPersonCameraParameter, m_parameter, res.m_parameter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (camera_type_name == <span class="string">&quot;ThirdPersonCameraParameter&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_parameter = <span class="built_in">PICCOLO_REFLECTION_NEW</span>(ThirdPersonCameraParameter);</span><br><span class="line">            <span class="built_in">PICCOLO_REFLECTION_DEEP_COPY</span>(ThirdPersonCameraParameter, m_parameter, res.m_parameter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (camera_type_name == <span class="string">&quot;FreeCameraParameter&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_parameter = <span class="built_in">PICCOLO_REFLECTION_NEW</span>(FreeCameraParameter);</span><br><span class="line">            <span class="built_in">PICCOLO_REFLECTION_DEEP_COPY</span>(FreeCameraParameter, m_parameter, res.m_parameter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;invalid camera type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CameraComponentRes::~<span class="built_in">CameraComponentRes</span>() &#123; <span class="built_in">PICCOLO_REFLECTION_DELETE</span>(m_parameter); &#125;</span><br><span class="line">&#125; <span class="comment">// namespace Piccolo</span></span><br></pre></td></tr></table></figure>
<p>我感觉这样子确实有点麻烦了，不如直接在 <code>ReflectionPtr</code> 里面用智能指针</p>
<p>既然用了智能指针，那么与不同类型之间的拷贝赋值运算符和移动赋值运算符就不需要了，毕竟智能指针本身是不支持这件事情的</p>
<h3 id="Taichi-Graphics-cpp-reflection">Taichi Graphics cpp reflection</h3>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1MY4y1c7hU">https://www.bilibili.com/video/BV1MY4y1c7hU</a></p>
<h4 id="使用-static-assert-以调试">使用 static_assert 以调试</h4>
<p>因为在模板编译报错的时候，你是没有运行时的中断的，所以也看不到编译模板中到底发生了什么错，编辑器的报错信息里面也不会说</p>
<p>所以可以使用 <code>static_assert</code> 来 debug。比如模板中有一个类型是 <code>tuple_t</code>，我们想知道它的类型，那么就</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(std::is_same&lt;<span class="type">tuple_t</span>, TestClassType&gt;::value, <span class="string">&quot;Debug info&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但是要注意，为了方便 debug，这个模板只能被传入一种类型。这样，你要查看的那个类型也就是确定了的，这样才能跟你 hard code 的类型作比较</p>
<p>如果是多处代码调用了这个模板，发生了不同类型的生成，那这个模板里面你的 <code>static_assert</code> 虽然在你期望的某个调用处是通过了，但是在你忽略了的地方就没通过，程序还是编译失败</p>
<p>当然编译器虽然不会告诉你具体为什么编译失败，但还是会告诉谁调用这个模板失败了，这个时候你会找到你忽略的地方……但是如果你没有这个避免不同生成的意识，或许你会下意识忽略掉报错信息给你的答案……是，我犯了这样的错误</p>
<h4 id="简化代码以调试">简化代码以调试</h4>
<p>当我的代码结构比较复杂的时候，我的编译器只会报 <code>std::bad_any_cast</code> 但是不会说明具体是怎么出错了</p>
<p>等到我简化了代码之后，才出现了明显的报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;initializing&#x27;: cannot convert from &#x27;std::array&lt;ArgWrap,2&gt;&#x27; to &#x27;std::array&lt;ArgWrap,2&gt; &amp;&#x27;</span><br></pre></td></tr></table></figure>
<p>表明我是不可以把一个值类型转到引用类型</p>
<p>于是回去看了教程，他是先转成指针再解引用，就能得到引用类型</p>
<p>这就触及到了我的知识盲区……解引用 * 会返回引用类型</p>
<p>以前实现赋值运算符重载的时候，返回值类型是 T&amp; 然后函数体里面结尾是 return *this; 我还没多想</p>
<p>原来解引用还真的是解出了引用……</p>
<p>以下是简化出来的，能给予更多调试信息的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArgWrap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">ArgWrap</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// for debugging, delete all content</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemberFunction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MemberFunction</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">MemberFunction</span><span class="params">(R(C::* func)(Args...))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        fn_ = [<span class="keyword">this</span>, func](std::any obj_args) -&gt; std::any &#123;</span><br><span class="line">            <span class="comment">// auto&amp; warpped_args = std::any_cast&lt;std::array&lt;ArgWrap, sizeof...(Args) + 1&gt;&gt;(obj_args); // error, &#x27;initializing&#x27;: cannot convert from &#x27;std::array&lt;ArgWrap,2&gt;&#x27; to &#x27;std::array&lt;ArgWrap,2&gt; &amp;&#x27;</span></span><br><span class="line">            <span class="keyword">auto</span>&amp; warpped_args = *std::any_cast&lt;std::array&lt;ArgWrap, <span class="keyword">sizeof</span>...(Args) + <span class="number">1</span>&gt;*&gt;(obj_args); <span class="comment">// right</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> std::any&#123;&#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    std::any <span class="title">Invoke</span><span class="params">(C&amp; c, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::array&lt;ArgWrap, <span class="keyword">sizeof</span>...(Args) + 1&gt; args_arr = &#123; ArgWrap &#123;std::<span class="built_in">reference_wrapper</span>&lt;C&gt;(c)&#125;,</span><br><span class="line">                                                                 ArgWrap &#123;std::forward&lt;Args&gt;(args)&#125;... &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fn_</span>(&amp;args_arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    std::function&lt;std::any(std::any)&gt; fn_&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::unique_ptr will result in compile-time error</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">float</span>&gt; <span class="title">MakeFloatPtr</span><span class="params">(<span class="type">float</span> i)</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">float</span>&gt;(i); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">MemberFunction <span class="title">mem_fun</span><span class="params">(&amp;Foo::MakeFloatPtr)</span></span>;</span><br><span class="line"></span><br><span class="line">    mem_fun.<span class="built_in">Invoke</span>(foo, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出-typeid-T-name-以调试">输出 typeid(T).name() 以调试</h4>
<p>虽然我把 <code>ArgWrap</code> 装好了，但是测试不通过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> foo_pass_by_cref = <span class="type">foo_t</span>.<span class="built_in">GetMemberFunc</span>(<span class="string">&quot;PassByConstRef&quot;</span>);</span><br><span class="line">foo_pass_by_cref.<span class="built_in">Invoke</span>(f, std::<span class="built_in">ref</span>(hello_s));</span><br></pre></td></tr></table></figure>
<p>经过 debug 之后发现是参数转换到 tuple，传入函数的时候，Foo 对象能转出来，但是 string 转出来为空</p>
<p>于是我就在装入值的时候检查了类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="title">ArgWrap</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Debug type T</span></span><br><span class="line">    <span class="comment">// static_assert(std::is_same&lt;T, void&gt;::value, &quot;Hoi!&quot;);</span></span><br><span class="line">    m_ref_type = std::is_reference_v&lt;T&gt;;</span><br><span class="line">    m_is_const = std::is_const_v&lt;T&gt;;</span><br><span class="line">    <span class="keyword">if</span> (m_ref_type == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_storage = &amp;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_storage = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;typeid(std::decay_t&lt;T&gt;).name() = &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(std::<span class="type">decay_t</span>&lt;T&gt;).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;typeid(T).name() = &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> result = std::<span class="built_in">any_cast</span>&lt;<span class="type">const</span> std::string&amp;&gt;(m_storage);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;can any_cast to const std::string&amp;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::bad_any_cast&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;can not any_cast to const std::string&amp;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeid(std::decay_t&lt;T&gt;).name() = class std::reference_wrapper&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &gt;</span><br><span class="line">typeid(T).name() = class std::reference_wrapper&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &gt;</span><br><span class="line">can not any_cast to const std::string&amp;</span><br></pre></td></tr></table></figure>
<p>这就说明 any_cast 没法处理这个转换……</p>
<h4 id="any-cast-的严格">any_cast 的严格</h4>
<p>做个测试</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span>        str2 = std::<span class="built_in">ref</span>(str1);</span><br><span class="line">    <span class="keyword">auto</span>        str3 = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> std::string&amp;&gt;(str2); <span class="comment">// Ok</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::any str4 = std::<span class="built_in">ref</span>(str1);</span><br><span class="line">    <span class="comment">// auto     str5 = std::any_cast&lt;const std::string&amp;&gt;(str4); // Crash, std::bad_any_cast</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> str6 = std::<span class="built_in">any_cast</span>&lt;<span class="keyword">decltype</span>(str2)&gt;(str4);</span><br><span class="line">    <span class="keyword">auto</span> str7 = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> std::string&amp;&gt;(str6); <span class="comment">// Ok</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>std::ref</code> 返回出来的这个类型，<code>reference_wrapper&lt;T&gt;</code>，如果我 any 里面放的是 <code>reference_wrapper&lt;T&gt;</code>，我是不能直接 <code>any_cast</code> 到 <code>T&amp;</code> 的</p>
<p>我 <code>any</code> 里面放的是什么类型，<code>any_cast</code> 出来就必须是什么类型，他不会帮你做 <code>static_cast</code></p>
<p>如果真的有 <code>static_cast</code> 的需求，那么需要 <code>any_cast</code> 之后自己写</p>
<h4 id="总结">总结</h4>
<p>他也是静态反射，只是存储函数信息的时候，用模板元编程来生成那个被存的函数</p>
<p>如果不想用模板，那么用代码生成，也可以生成出被存储的函数，比如 Piccolo</p>
<p>在模板元编程时，因为需要操作类型，所以常用 <code>std::tuple</code> 打包类型。比如用这个 <code>std::tuple</code> 可以做出包含所有参数的类型的一个 tuple</p>
<p>他最后考虑到 <code>std::any_cast</code> 需要一一严格对应的类型转换，所以做了一个 <code>ArgWarp</code> 来做类型转换的适配</p>
<p>具体来说，<code>std::any_cast</code> 需要 cast 到 <code>const std::string&amp;</code> 但是实际 <code>any</code> 存储的如果是 <code>std::string</code> 的话，<code>std::any_cast</code> 就会出错</p>
<p>也就是输入的实参类型 <code>T1</code> 和记录的函数的形参的类型 <code>T2</code> 之间不匹配，<code>std::any</code> 里面存的是 <code>T1</code>，但是要 <code>std::any_cast</code> 到 <code>T2</code>。<code>std::any_cast</code> 里面是直接比较 <code>typeid</code> 的，所以不会成功，即使你 <code>static_cast</code> 从 <code>T1</code> 到 <code>T2</code> 可以成功</p>
<p>他做的 <code>ArgWarp</code> 的适配工作是，假设 <code>std::any</code> 存储的类型 <code>T1</code> 和 Cast 接口要输出的类型 <code>T2</code> 的原始类型，也就是 <code>std::decay_t</code> 出来的类型都相同，记为 <code>RawT</code></p>
<p>他就考虑到 <code>T1</code> <code>T2</code> 分别为 value、const ref、non-const ref 的时候的情况，做了一个 3*3 的转换表，使用 <code>RawT</code> 和指针和解引用配合，就能得到正确的 <code>std::any_cast</code> 方法，使得我能够利用原本严格的 <code>std::any_cast</code> 转换两个不同的但是原始类型相同的类型</p>
<p>但是他基于的假设是 <code>T1</code> <code>T2</code> 的 <code>std::decay_t</code> 出来的类型都相同</p>
<p>实际上别人调用你的反射函数的时候，<code>T1</code> <code>T2</code> 的 <code>std::decay_t</code> 出来的类型还真可能不相同</p>
<p>为什么他会这么用？<s>因为 <code>static_cast</code> 从 <code>T1</code> 到 <code>T2</code> 可以成功，这是不违背直觉的</s></p>
<p>因为使用者知道从 <code>T1</code> 到 <code>T2</code> 的隐式转换是可以成功的</p>
<p>这不局限于 <code>static_cast</code>，还有可能是调用了类型转换函数，例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">	<span class="keyword">auto</span> str2 = std::<span class="built_in">ref</span>(str1);</span><br><span class="line">	<span class="function">std::string&amp; <span class="title">str3</span><span class="params">(str2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过断点看到，构造 <code>std::string&amp;</code> 的时候，调用了 <code>reference_wrapper&lt;T&gt;</code> 里面的 <code>T&amp;</code> 类型转换函数</p>
<p>所以我觉得更省心智的方法应该是，不要在反射系统里面加入这个 <code>T1</code> <code>T2</code> 的 <code>std::decay_t</code> 出来的类型都相同 的隐性约束</p>
<h3 id="YKIKO-reflection">YKIKO reflection</h3>
<p>重新看了别人的文章</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/670191053">https://zhuanlan.zhihu.com/p/670191053</a></p>
<p>他没有写 registry 和 builder 模式，而是把类型信息存在了 Any 类的偏特化模板中</p>
<p>这让我想到，为什么我在包装参数的时候用 <code>std::any</code></p>
<p>为了避免 <code>std::any</code> 的限制，我尝试了使用 <code>void*</code> 来存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeAny</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputClass&gt;</span></span><br><span class="line"><span class="function">    <span class="title">UnsafeAny</span><span class="params">(InputClass&amp;&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_ref_type = std::is_reference_v&lt;InputClass&gt;;</span><br><span class="line">        <span class="keyword">if</span> (m_ref_type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_storage = &amp;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_storage = <span class="keyword">new</span> std::<span class="built_in">decay_t</span>&lt;InputClass&gt;(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">UnsafeAny</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_ref_type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_storage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OutputClass&gt;</span></span><br><span class="line"><span class="function">    OutputClass <span class="title">Cast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> RawTptr = std::<span class="type">decay_t</span>&lt;OutputClass&gt;*;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">static_cast</span>&lt;RawTptr&gt;(m_storage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span>* m_storage &#123;&#125;;</span><br><span class="line">    <span class="type">int</span>   m_ref_type &#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是传入 <code>reference_wrapper&lt;T&gt;</code> 的时候还是有问题</p>
<p>之前我是以为从 <code>reference_wrapper&lt;T&gt;</code> 到 <code>T</code> 的转换是隐式调用了 <code>static_cast</code>，实际上不是，实际上是调用了类型转换函数</p>
<p><code>reference_wrapper&lt;T&gt;</code> 到 <code>T</code> 用 <code>static_cast</code> 是转不了的，它们在类型上是没有关系的</p>
<p>你需要先从 <code>reference_wrapper&lt;T&gt;</code> 里面取出指针出来</p>
<p>但是这适用不到任意类型，比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你完全不知道他能这么类型转换</p>
<p>或许你在装箱的时候可以尝试把输入 cast 到一些确定的类型</p>
<p>但是这样总归是一个需要维护的地方，位于转换表中的东西可以从接口的角度来看可以隐式转换，不在表里面的就不行，行为不统一，还要维护，不如不搞</p>
<p>现在我完全理解了，如果想要使用这样的反射，还真的就要接受这个规则，就是接受这个无法做隐式类型转换的规则</p>
<p>只是在写代码的时候多写 cast 而已，可以接受</p>
<p>那么大的自由度也没必要</p>
<h3 id="使用-annotate-属性和-libclang-分析-AST-做代码生成">使用 annotate 属性和 libclang 分析 AST 做代码生成</h3>
<p>现在要解析 annotation，生成注册反射类的代码。原理上宏是可以完成这种任务，但是我感觉太丑，而且这样的话，反射就侵入式太重了。</p>
<p>虽然 annotation 也算侵入了，但是感觉，更轻量一点。如果写宏的话，人脑就要展开宏，虽然现在 IDE 也会展开</p>
<h4 id="链接-libclang">链接 libclang</h4>
<p>我之前在想怎么单纯依赖于 submodule，哪怕是这个 submodule 从某个地方把 llvm 发布版本下载过来的</p>
<p>比如这个 <a target="_blank" rel="noopener" href="https://github.com/deech/libclang-static-build?tab=readme-ov-file#windows-10">https://github.com/deech/libclang-static-build?tab=readme-ov-file#windows-10</a></p>
<p>搞了一下，还有动态库静态库，release 和 debug 之间的不匹配，也不知道他下载过来的发布版本是怎么构建出来的</p>
<p>不想去研究了，感觉麻烦</p>
<p>这种大型工具还是让用户安装吧。规定用户需要设置一个环境变量 <code>LLVM_DIR</code>，存储 LLVM 发布版本的根目录，然后直接链接</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;Your <span class="keyword">Target</span> Name&gt; PUBLIC $ENV&#123;LLVM_DIR&#125;/lib/libclang.lib)</span><br><span class="line"><span class="keyword">target_include_directories</span>(&lt;Your <span class="keyword">Target</span> Name&gt; PUBLIC $ENV&#123;LLVM_DIR&#125;/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<h4 id="annotate-属性">annotate 属性</h4>
<p>一些更痛苦的事情是，如果想坚持使用属性这个东西，非标准的属性会被编译器删除，所以查看 AST 的时候都看不到</p>
<p>所以你没有办法做</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[Reflectable]]</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>有两个解决办法，要么改 clang 的代码，参考 <a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~seth/llvm/llvmannotation.html">https://www.cs.cmu.edu/~seth/llvm/llvmannotation.html</a>，然后自己编译一遍 llvm</p>
<p>但是这样的话，你写出来的代码只有你自己的 clang 能编译通过</p>
<p>如果是想要把自己修改版本的 llvm 发布出来的话，维护也是一个问题</p>
<p>考虑到团队合作的话，别人能不能接受你自己编译的这个 llvm 是个问题……当然你可以把你自己的 llvm 的构建放到一个服务器上，让别人从这个服务器下载发布版本，但是这其中又会有静态库和动态库，debug 和 release 等问题，需要发布的 llvm 的库文件的这些设置与引擎的构建设置匹配才行。可能具体我也不太懂为什么，总之就是还是有坑</p>
<p>或者是想办法把自定义属性的参数都转成字符串给 <code>annotate</code> 这个属性。<code>annotate</code> 是标准里面的，所以能处理</p>
<p>这一种写法还挺好的 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/669360731">https://zhuanlan.zhihu.com/p/669360731</a></p>
<p>再参考虚幻那种格式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> reflectable_class(...)    clang::annotate(<span class="string">&quot;reflectable_class;&quot;</span> #__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reflectable_struct(...)   clang::annotate(<span class="string">&quot;reflectable_struct;&quot;</span> #__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reflectable_field(...)    clang::annotate(<span class="string">&quot;reflectable_field;&quot;</span> #__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> reflectable_function(...) clang::annotate(<span class="string">&quot;reflectable_function;&quot;</span> #__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> [[<span class="built_in">reflectable_struct</span>()]] Foo</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">reflectable_field</span>(blueprint_read_write)]]</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">reflectable_function</span>(blueprint_callable, category = <span class="string">&quot;Hello&quot;</span>)]]</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>达成了跟虚幻差不多的格式，虽然看上去没什么稀奇的。虚幻是自己写了一套分析代码的工具 UHT，它与属性相关的宏在编译的时候是被忽略的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObjectMacros.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// These macros wrap metadata parsed by the Unreal Header Tool, and are otherwise</span></span><br><span class="line"><span class="comment">// ignored when code containing them is compiled by the C++ compiler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPROPERTY(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UFUNCTION(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USTRUCT(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UMETA(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPARAM(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UENUM(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDELEGATE(...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGVM_METHOD(...)</span></span><br></pre></td></tr></table></figure>
<p>虚幻的解析文件的方法在 <code>FHeaderParser::ParseHeader</code></p>
<h4 id="libclang">libclang</h4>
<p>libclang 的使用方法是提供一个遍历 AST 每一个节点时的回调函数，例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;clang-c/Index.h&gt;</span> <span class="comment">// This is libclang.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; stream, <span class="type">const</span> CXString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    stream &lt;&lt; <span class="built_in">clang_getCString</span>(str);</span><br><span class="line">    <span class="built_in">clang_disposeString</span>(str);</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CXIndex           index = <span class="built_in">clang_createIndex</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    CXTranslationUnit unit  = <span class="built_in">clang_parseTranslationUnit</span>(</span><br><span class="line">        index, <span class="string">&quot;header.hpp&quot;</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, CXTranslationUnit_None);</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Unable to parse translation unit. Quitting.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CXCursor cursor = <span class="built_in">clang_getTranslationUnitCursor</span>(unit);</span><br><span class="line">    <span class="built_in">clang_visitChildren</span>(</span><br><span class="line">        cursor,</span><br><span class="line">        [](CXCursor c, CXCursor parent, CXClientData client_data) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Cursor &#x27;&quot;</span> &lt;&lt; <span class="built_in">clang_getCursorSpelling</span>(c) &lt;&lt; <span class="string">&quot;&#x27; of kind &#x27;&quot;</span></span><br><span class="line">                 &lt;&lt; <span class="built_in">clang_getCursorKindSpelling</span>(<span class="built_in">clang_getCursorKind</span>(c)) &lt;&lt; <span class="string">&quot;&#x27;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> CXChildVisit_Recurse;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clang_disposeTranslationUnit</span>(unit);</span><br><span class="line">    <span class="built_in">clang_disposeIndex</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>clang_visitChildren</code> 这里就是遍历每一个节点的时候都会调用传入的回调函数</p>
<p>但是我们可能会有一些复杂的匹配条件，来决定回调函数在这个节点是否被调用</p>
<p>使用它来处理之前的属性示例，得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cursor &#x27;Foo&#x27; of kind &#x27;StructDecl&#x27;</span><br><span class="line">Cursor &#x27;reflectable_struct;&#x27; of kind &#x27;attribute(annotate)&#x27;</span><br><span class="line">Cursor &#x27;x&#x27; of kind &#x27;FieldDecl&#x27;</span><br><span class="line">Cursor &#x27;reflectable_field;blueprint_read_write&#x27; of kind &#x27;attribute(annotate)&#x27;</span><br><span class="line">Cursor &#x27;&#x27; of kind &#x27;IntegerLiteral&#x27;</span><br><span class="line">Cursor &#x27;print&#x27; of kind &#x27;CXXMethod&#x27;</span><br><span class="line">Cursor &#x27;reflectable_function;blueprint_callable, category = &quot;Hello&quot;&#x27; of kind &#x27;attribute(annotate)&#x27;</span><br></pre></td></tr></table></figure>
<p>一个最简单的查找 annotation 属性的方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;clang-c/Index.h&gt;</span> <span class="comment">// This is libclang.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper function to convert CXString to std::string</span></span><br><span class="line"><span class="function">std::string <span class="title">toStdString</span><span class="params">(CXString cxStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string result = <span class="built_in">clang_getCString</span>(cxStr);</span><br><span class="line">    <span class="built_in">clang_disposeString</span>(cxStr);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">split</span><span class="params">(std::string text, <span class="type">char</span> delim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string              line;</span><br><span class="line">    std::vector&lt;std::string&gt; vec;</span><br><span class="line">    <span class="function">std::stringstream        <span class="title">ss</span><span class="params">(text)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, line, delim))</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CXIndex           index = <span class="built_in">clang_createIndex</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    CXTranslationUnit unit  = <span class="built_in">clang_parseTranslationUnit</span>(</span><br><span class="line">        index, <span class="string">&quot;header.hpp&quot;</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, CXTranslationUnit_None);</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to parse translation unit. Quitting.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CXCursor cursor = <span class="built_in">clang_getTranslationUnitCursor</span>(unit);</span><br><span class="line">    <span class="built_in">clang_visitChildren</span>(</span><br><span class="line">        cursor,</span><br><span class="line">        [](CXCursor c, CXCursor parent, CXClientData client_data) &#123;</span><br><span class="line">            std::vector&lt;std::string&gt;* fields = <span class="keyword">static_cast</span>&lt;std::vector&lt;std::string&gt;*&gt;(client_data);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">clang_getCursorKind</span>(c) == CXCursor_AnnotateAttr)</span><br><span class="line">            &#123;</span><br><span class="line">                std::vector&lt;std::string&gt; annotations = <span class="built_in">split</span>(<span class="built_in">toStdString</span>(<span class="built_in">clang_getCursorSpelling</span>(c)), <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (annotations.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> CXChildVisit_Recurse;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (annotations[<span class="number">0</span>] == <span class="string">&quot;reflectable_class&quot;</span>)</span><br><span class="line">                    std::cout &lt;&lt; annotations[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (annotations[<span class="number">0</span>] == <span class="string">&quot;reflectable_struct&quot;</span>)</span><br><span class="line">                    std::cout &lt;&lt; annotations[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> CXChildVisit_Recurse;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clang_disposeTranslationUnit</span>(unit);</span><br><span class="line">    <span class="built_in">clang_disposeIndex</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然现在确定了 libclang 能够找到这个属性，但是还是不知道怎么建立属性和他所修饰的成员变量之间的关系</p>
<p>所以还是输出 AST 才能看到节点之间的关系</p>
<p>以下是反射示例的 AST 的部分输出，可以看到 <code>AnnotateAttr</code> 是 <code>CXXRecordDecl</code> <code>FieldDecl</code> <code>CXXMethodDecl</code> 的子节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PS ...&gt; clang -Xclang -ast-dump header.hpp</span><br><span class="line">...</span><br><span class="line">`-CXXRecordDecl 0x197c6538cf8 &lt;header.hpp:6:1, line:13:1&gt; line:6:36 struct Foo definition</span><br><span class="line">  |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable literal has_constexpr_non_copy_move_ctor can_const_default_init</span><br><span class="line">  | |-DefaultConstructor exists non_trivial constexpr needs_implicit defaulted_is_constexpr</span><br><span class="line">  | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param</span><br><span class="line">  | |-MoveConstructor exists simple trivial needs_implicit</span><br><span class="line">  | |-CopyAssignment simple trivial has_const_param needs_implicit implicit_has_const_param</span><br><span class="line">  | |-MoveAssignment exists simple trivial needs_implicit</span><br><span class="line">  | `-Destructor simple irrelevant trivial needs_implicit</span><br><span class="line">  |-AnnotateAttr 0x197c6538e18 &lt;line:2:35, col:85&gt; &quot;reflectable_struct;&quot;</span><br><span class="line">  |-CXXRecordDecl 0x197c6538ec0 &lt;line:6:1, col:36&gt; col:36 implicit struct Foo</span><br><span class="line">  |-FieldDecl 0x197c6538fb0 &lt;line:9:5, col:13&gt; col:9 x &#x27;int&#x27;</span><br><span class="line">  | |-IntegerLiteral 0x197c6539328 &lt;col:13&gt; &#x27;int&#x27; 1</span><br><span class="line">  | `-AnnotateAttr 0x197c6539008 &lt;line:3:35, col:84&gt; &quot;reflectable_field;blueprint_read_write&quot;</span><br><span class="line">  `-CXXMethodDecl 0x197c65391a0 &lt;line:12:5, col:16&gt; col:10 print &#x27;void ()&#x27;</span><br><span class="line">    `-AnnotateAttr 0x197c6539248 &lt;line:4:35, col:87&gt; &quot;reflectable_function;blueprint_callable, category = &quot;Hello&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>所以我们需要获得父节点</p>
<p><code>clang_getCursorSemanticParent</code> 和 <code>clang_getCursorLexicalParent</code> 都不顶用，它们获得父节点的逻辑不一样，具体我也不懂</p>
<p><code>clang_visitChildren</code> 的回调函数的参数里面直接就有 parent，我之前没注意到，直接用这个就可以了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clang_visitChildren</span>(</span><br><span class="line">    cursor,</span><br><span class="line">    [](CXCursor c, CXCursor parent, CXClientData client_data) &#123;</span><br><span class="line">        std::vector&lt;std::string&gt;* fields = <span class="keyword">static_cast</span>&lt;std::vector&lt;std::string&gt;*&gt;(client_data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">clang_getCursorKind</span>(c) == CXCursor_AnnotateAttr)</span><br><span class="line">        &#123;</span><br><span class="line">            std::vector&lt;std::string&gt; annotations = <span class="built_in">split</span>(<span class="built_in">toStdString</span>(<span class="built_in">clang_getCursorSpelling</span>(c)), <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (annotations.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> CXChildVisit_Recurse;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (annotations[<span class="number">0</span>] == <span class="string">&quot;reflectable_class&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">clang_getCursorKind</span>(parent) == CXCursor_ClassDecl)</span><br><span class="line">                &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;CXCursor_ClassDecl&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (annotations[<span class="number">0</span>] == <span class="string">&quot;reflectable_struct&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="built_in">toStdString</span>(<span class="built_in">clang_getCursorSpelling</span>(parent)) &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">clang_getCursorKind</span>(parent) == CXCursor_StructDecl)</span><br><span class="line">                &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;CXCursor_StructDecl&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CXChildVisit_Recurse;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<h4 id="clang-visitChildren-回调里面的用户数据指针">clang_visitChildren 回调里面的用户数据指针</h4>
<p>因为 clang_visitChildren 是 C 接口，所以并没有 C++ 标准的东西</p>
<p>用的参数是函数指针，不能存储状态</p>
<p>所以需要最后一个 <code>CXClientData client_data</code> 来存储用户提供的数据指针</p>
<p>如果你有多个数据的话……那就打包成结构体吧</p>
<p>lambda 只有在不捕获的时候才能退化成函数指针，std::function 也转不了函数指针，根本原因就是因为函数指针是没有上下文的，所以 <code>CXClientData client_data</code> 这里始终是绕不开的</p>
<h4 id="生成文件">生成文件</h4>
<p>思路是，先构建代码生成器，然后生成代码，获取源码文件列表 + 生成代码列表，填到 CMakeLists.txt 里面，然后再构建 Runtime 和 Editor</p>
<p>因为每处理一个新文件，就要在 include 和函数体两个位置更新，我一开始使用 <code>tellp</code> <code>seekp</code> 的组合，但是后面我搞不懂它为什么会产生 bug，为什么移动输出位置之后，输出一行会直接消除掉下面的两三行</p>
<p>为了省心，还是使用 <code>std::stringstream</code> 吧</p>
<h4 id="为-libclang-提供编译选项">为 libclang 提供编译选项</h4>
<p>libclang 读取头文件的时候，如果后缀是 <code>.h</code> 那么会认为是 C 文件。这样，就会发生解析错误。为了不修改头文件的后缀的同时，还能让 libclang 知道这是 C++，要传入 <code>-xc++</code> 编译选项</p>
<script src="https://utteranc.es/client.js"
        repo="CheapMeow/cheapmeow.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2024/01/10/2024-01-10-fluid_simulation_for_computer_graphics_reading_note/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2025-06-01 10:52:45
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Cpp/" title="Cpp">
                        #Cpp
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Reflection/" title="Reflection">
                        #Reflection
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Template-programming/" title="Template programming">
                        #Template programming
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2024/07/21/2024-07-21-cpp_multiple_dimensional_array/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E9%9D%99%E6%80%81%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0"><span class="toc-text">C++静态反射学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Piccolo-%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%8D%E5%B0%84"><span class="toc-text">Piccolo 中的静态反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-text">存储类型信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA-GUI-%E6%A0%91"><span class="toc-text">使用反射创建 GUI 树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">序列化与反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReflectionPtr-%E5%92%8C-ReflectionInstance-%E7%94%A8%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-text">ReflectionPtr 和 ReflectionInstance 用于类型擦除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReflectionPtr-%E5%92%8C-ReflectionInstance-%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">ReflectionPtr 和 ReflectionInstance 的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReflectionPtr-%E5%86%85%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">ReflectionPtr 内使用智能指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Taichi-Graphics-cpp-reflection"><span class="toc-text">Taichi Graphics cpp reflection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-static-assert-%E4%BB%A5%E8%B0%83%E8%AF%95"><span class="toc-text">使用 static_assert 以调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81%E4%BB%A5%E8%B0%83%E8%AF%95"><span class="toc-text">简化代码以调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-typeid-T-name-%E4%BB%A5%E8%B0%83%E8%AF%95"><span class="toc-text">输出 typeid(T).name() 以调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#any-cast-%E7%9A%84%E4%B8%A5%E6%A0%BC"><span class="toc-text">any_cast 的严格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YKIKO-reflection"><span class="toc-text">YKIKO reflection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-annotate-%E5%B1%9E%E6%80%A7%E5%92%8C-libclang-%E5%88%86%E6%9E%90-AST-%E5%81%9A%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-text">使用 annotate 属性和 libclang 分析 AST 做代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5-libclang"><span class="toc-text">链接 libclang</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#annotate-%E5%B1%9E%E6%80%A7"><span class="toc-text">annotate 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#libclang"><span class="toc-text">libclang</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clang-visitChildren-%E5%9B%9E%E8%B0%83%E9%87%8C%E9%9D%A2%E7%9A%84%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8C%87%E9%92%88"><span class="toc-text">clang_visitChildren 回调里面的用户数据指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6"><span class="toc-text">生成文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA-libclang-%E6%8F%90%E4%BE%9B%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="toc-text">为 libclang 提供编译选项</span></a></li></ol></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2025 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + C%2B%2B%20%E9%9D%99%E6%80%81%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0 + '&url=' + https%3A%2F%2Fcheapmeow.github.io%2F2024%2F05%2F13%2F2024-05-13-cpp_static_reflection%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://cheapmeow.github.io/2024/05/13/2024-05-13-cpp_static_reflection/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
